#+TAGS: SIMPLE(s) MEDIUM(m) HARD(h) TOBEORG(t) UNRESOLVED(u)
* 数组 
** 1-Two Sum                                                         :SIMPLE:
*** 暴力解法
    #+begin_src java :classname 
      class Solution {
          public int[] twoSum(int[] nums, int target) {
              for (int i=0; i < nums.length; i++) {
                  int other = target - nums[i];
                  for (int j = i + 1; j < nums.length; j++) {
                      if (other == nums[j]) {
                          return new int[] {i, j};
                      }
                  }
              }
              throw new IllegalArgumentException("No two sum solution");
          }
      }
    #+end_src 
    - ~new int[] {i, j}~
    - 复杂度
      - $O(n^2)$
      - $O(1)$
*** 哈希表
    - Two-pass
      #+begin_src java :classname 
        class Solution {
            public int[] twoSum(int[] nums, int target) {
                Map<Integer, Integer> map = new HashMap<>();
                for (int i = 0; i < nums.length; i++) {
                    map.put(nums[i], i);
                }
                for (int j = 0; j < nums.length; j++) {
                    int rest = target - nums[j];
                    if (map.containsKey(rest) && map.get(rest) != j) {
                        return new int[] {j, map.get(rest)};
                    }
                }
                throw new IllegalArgumentException("No two sum solution");
            }
        }
      #+end_src
      - ~Map<Integer, Integer> map = new HashMap<>()~
      - ~map.put(nums[i], i)~, ~map.containsKey(rest)~ and ~map.get(rest) != j~
      - 复杂度
        - $O(n)$: 哈希表的查找时间复杂度为 $O(1)$
        - $O(n)$: 哈希表大小为 $n$
    - One-pass
      #+begin_src java :classname 
        class Solution {
            public int[] twoSum(int[] nums, int target) {
                Map<Integer, Integer> map = new HashMap<>();
                for (int i = 0; i < nums.length; i++) {
                    int rest = target - nums[i];
                    if (map.containsKey(rest)) {
                        return new int[] {map.get(rest), i};
                    }
                    map.put(nums[i], i);
                }
                throw new IllegalArgumentException("No two sum solution");
            }
        }
      #+end_src
      - 复杂度: 和 Two-pass 一样
** 11-Container With Most Water                                      :MEDIUM:
** 15-3Sum                                                           :MEDIUM:
** 16-3Sum Closest                                                   :MEDIUM:
* 随机
** 803 打砖块                                                  :HARD:TOBEORG:
   #+begin_src java :classname 
     public class Solution {

         public int[] hitBricks(int[][] grid, int[][] hits) {
             // TODO
             if (grid == null || grid.length == 0 || grid[0].length == 0) return null;
             if (hits == null || hits.length == 0 || hits[0].length != 2) return null;
             int row = grid.length, col = grid[0].length, hitsNum = hits.length;
             for (int[] dart: hits) {
                 if (dart[0] < 0 || dart[0] >= row ||
                         dart[1] < 0 || dart[1] >= col) return null;
             }

             int[] ur = {1, 0, -1, 0};
             int[] uc = {0, 1, 0, -1};
             int root = row * col;
             UnionFind union = new UnionFind(root + 1);
             int[][] copy = new int[row][col];

             for (int i = 0; i < row; i++) {
                 copy[i] = grid[i].clone();
             }

             for (int[] dart: hits) {
                 copy[dart[0]][dart[1]] = 0;
             }

             for (int i = 0; i < row; i++) {
                 for (int j = 0; j < col; j++) {
                     if (copy[i][j] == 1) {
                         if (i == 0) {
                             union.union(xyToint(col, i, j), root);
                             continue;
                         }
                         if (i - 1 >= 0 && copy[i-1][j] == 1) {
                             union.union(xyToint(col, i, j), xyToint(col, i-1, j));
                         }
                         if (j - 1 >= 0 && copy[i][j-1] == 1) {
                             union.union(xyToint(col, i, j), xyToint(col, i, j-1));
                         }
                     }
                 }
             }


             int[] bubbles = new int[hitsNum];

             for (int i = hitsNum - 1; i >= 0; i--) {
                 int afterPop = union.sizeOf(root);
                 int r = hits[i][0];
                 int c = hits[i][1];
                 if (grid[r][c] == 0) continue;
                 if (r == 0) union.union(xyToint(col, r, c), root);
                 for (int j = 0; j < 4; j++) {
                     int nr = r + ur[j];
                     int nc = c + uc[j];
                     if (nr >= 0 && nr < row &&
                             nc >=0 && nc < col && copy[nr][nc] == 1) {
                         union.union(xyToint(col, r, c), xyToint(col, nr, nc));
                     }
                 }
                 int pops = union.sizeOf(root) - afterPop - 1;
                 bubbles[i] = pops > 0 ? pops : 0;
                 copy[r][c] = 1;
             }
             return bubbles;
         }


         private int xyToint(int col, int r, int c) {
             return r * col + c;
         }

     }


     class UnionFind {

         private int[] vertice;

         // TODO - Add instance variables?

         /* Creates a UnionFind data structure holding n vertices. Initially, all
            vertices are in disjoint sets. */
         public UnionFind(int n) {
             // TODO
             vertice = new int[n];
             for (int i = 0; i < n; i++) {
                 vertice[i] = -1;
             }
         }

         /* Throws an exception if v1 is not a valid index. */
         private void validate(int vertex) {
             // TODO
             if (vertex < 0 || vertex >= this.vertice.length) {
                 throw new IllegalArgumentException(vertex
                         + "is not a valid index.");
             }
         }

         /* Returns the size of the set v1 belongs to. */
         public int sizeOf(int v1) {
             // TODO
             return - vertice[find(v1)];
         }

         /* Returns the parent of v1. If v1 is the root of a tree, returns the
            negative size of the tree for which v1 is the root. */
         public int parent(int v1) {
             // TODO
             return vertice[v1] < 0 ? v1 : vertice[v1];
         }

         /* Returns true if nodes v1 and v2 are connected. */
         public boolean connected(int v1, int v2) {
             // TODO
             int r1 = find(v1);
             int r2 = find(v2);
     //        int p1 = parent(v1);
     //        int p2 = parent(v2);
     //
     //        while (p1 != r1) {
     //            vertice[v1] = r1;
     //            v1 = p1;
     //            p1 = parent(v1);
     //        }
     //        while (p2 != r2) {
     //            vertice[v2] = r2;
     //            v2 = p2;
     //            p2 = parent(v2);
     //        }

             return r1 == r2;
         }

         /* Connects two elements v1 and v2 together. v1 and v2 can be any valid
            elements, and a union-by-size heuristic is used. If the sizes of the sets
            are equal, tie break by connecting v1's root to v2's root. Unioning a 
            vertex with itself or vertices that are already connected should not 
            change the sets but may alter the internal structure of the data. */
         public void union(int v1, int v2) {
             // TODO
             validate(v1);
             validate(v2);
             if (!connected(v1, v2)) {
                 if (sizeOf(v1) <= sizeOf(v2)) {
                     vertice[find(v2)] += vertice[find(v1)];
                     vertice[find(v1)] = find(v2);
                 } else {
                     vertice[find(v1)] += vertice[find(v2)];
                     vertice[find(v2)] = find(v1);
                 }
             }
         }

         /* Returns the root of the set V belongs to. Path-compression is employed
            allowing for fast search-time. */
         public int find(int vertex) {
             // TODO
             return vertice[vertex] < 0 ? vertex : find(parent(vertex));
         }

         public int[] getSet() {
             return vertice;
         }
     }
   #+end_src 
** 637 二叉树的层平均值                                   :SIMPLE:UNRESOLVED:
*** DFS
*** BFS
