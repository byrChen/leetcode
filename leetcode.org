#+TAGS: SIMPLE(s) MEDIUM(m) HARD(h) TOBEORG(t) UNRESOLVED(u)
* 1 两数之和                                                           :数组:
** 暴力解法
   #+begin_src java :classname 
     class Solution {
         public int[] twoSum(int[] nums, int target) {
             for (int i=0; i < nums.length; i++) {
                 int other = target - nums[i];
                 for (int j = i + 1; j < nums.length; j++) {
                     if (other == nums[j]) {
                         return new int[] {i, j};
                     }
                 }
             }
             throw new IllegalArgumentException("No two sum solution");
         }
     }
   #+end_src 
   - ~new int[] {i, j}~
   - 复杂度
     - $O(n^2)$
     - $O(1)$
** 哈希映射
   - Two-pass
     #+begin_src java :classname 
       class Solution {
           public int[] twoSum(int[] nums, int target) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int i = 0; i < nums.length; i++) {
                   map.put(nums[i], i);
               }
               for (int j = 0; j < nums.length; j++) {
                   int rest = target - nums[j];
                   if (map.containsKey(rest) && map.get(rest) != j) {
                       return new int[] {j, map.get(rest)};
                   }
               }
               throw new IllegalArgumentException("No two sum solution");
           }
       }
     #+end_src
     - ~Map<Integer, Integer> map = new HashMap<>()~
     - ~map.put(nums[i], i)~, ~map.containsKey(rest)~ and ~map.get(rest) != j~
     - 复杂度
       - $O(n)$: 哈希表的查找时间复杂度为 $O(1)$
       - $O(n)$: 哈希表大小为 $n$
   - One-pass
     #+begin_src java :classname 
       class Solution {
           public int[] twoSum(int[] nums, int target) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int i = 0; i < nums.length; i++) {
                   int rest = target - nums[i];
                   if (map.containsKey(rest)) {
                       return new int[] {map.get(rest), i};
                   }
                   map.put(nums[i], i);
               }
               throw new IllegalArgumentException("No two sum solution");
           }
       }
     #+end_src
     - 复杂度: 和 Two-pass 一样
* 2 两数相加                                                           :链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            ListNode head = new ListNode(0), p = head;
            int carry = 0;
            while (l1 != null || l2 != null) {
                int sum = carry;
                if (l1 != null) sum += l1.val;
                if (l2 != null) sum += l2.val;
                p.next = new ListNode(sum % 10);
                carry = sum / 10;
                p = p.next;
                if (l1 != null) l1 = l1.next;
                if (l2 != null) l2 = l2.next;
            }
            if (carry != 0) p.next = new ListNode(carry);
            return head.next;
        }
    }
  #+end_src 
* 3 无重复字符的最长子串 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink8>>][offer48]]                           :DP:双指针:字符串:
  #+begin_src java :classname 
    class Solution {
        public int lengthOfLongestSubstring(String s) {
            if (s == null || s.length() <= 0) return 0;
            int max = 0, start = 0, len = s.length();
            Map<Character, Integer> map = new HashMap<>();
            for (int i = 0; i < len; i++) {
                char ch = s.charAt(i);
                if (map.containsKey(ch) && map.get(ch) >= start) {
                    int next = map.get(ch);
                    if (i - start > max) max = i - start;
                    start = next + 1;
                }
                map.put(ch, i);
            }
            if (len - start > max) max = len - start;
            return max;
        }
    }
  #+end_src 
* 4 寻找两个有序数组的中位数                                     :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        }
    }
  #+end_src 
* 5 最长回文子串                                  :DP:扩展窗口:双指针:字符串:
** 中心扩展算法
   #+begin_src java :classname 
     class Solution {
         public String longestPalindrome(String s) {
             if (s == null || s.length() <= 1) return "";
             int start = 0, end = 0;
             for (int i = 0; i < s.length(); i++) {
                 int oddL = expandAroundCenter(s, i, i);
                 int evenL = expandAroundCenter(s, i, i+1);
                 int len = Math.max(oddL, evenL);
                 if (len > end-start+1) {
                     start = i - (len-1) / 2;
                     end = i + len / 2;
                 }
             }
             return s.substring(start, end+1);
         }

         private int expandAroundCenter(String s, int l, int r) {
             while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
                 l -= 1;
                 r += 1;
             }
             return r - l - 1;
         }
     }
   #+end_src 
** 最长公共子串                                                  :UNRESOLVED:
** DP                                                            :UNRESOLVED:
* 10 正则表达式匹配 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink9>>][offer19]]                         :DP:DFS:回溯:递归:字符串:
** 递归
   #+begin_src java :classname 
     class Solution {
         public boolean isMatch(String s, String p) {
             if (s == null || p == null) return false;
             return matchHelper(s.toCharArray(), 0, p.toCharArray(), 0);
         }

         private boolean matchHelper(char[] s, int i, char[] p, int j) {
             if (i == s.length && j == p.length) return true;
             else if (j == p.length) return false;

             if (j+1 < p.length && p[j+1] == '*') {
                 if (i < s.length && (s[i] == p[j] || p[j] == '.')) return matchHelper(s, i+1, p, j) || matchHelper(s, i, p, j+2);
                 return matchHelper(s, i, p, j+2);
             }

             if (i < s.length && (s[i] == p[j] || p[j] == '.')) return matchHelper(s, i+1, p, j+1);
             return false;
         }
     }
   #+end_src 
** 回溯
** DP
* 11 盛最多水的容器                                             :双指针:数组:
** 双指针
   #+begin_src java :classname 
     class Solution {
         public int maxArea(int[] height) {
             int max = 0, left = 0, right = height.length-1;
             while (left < right) {
                 int cur = (right-left) * Math.min(height[left], height[right]);
                 if (cur > max) max = cur;
                 if (height[left] < height[right]) left+= 1;
                 else right -= 1;
             }
             return max;
         }
     }
   #+end_src 
* 15 三数之和                                                :双指针:DP:数组:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> threeSum(int[] nums) {
            List<List<Integer>> lists= new ArrayList<>();
            if (nums == null || nums.length < 3) return lists;
            Arrays.sort(nums);
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] > 0) break;
                if (i > 0 && nums[i] == nums[i-1]) continue;
                int left = i + 1, right = nums.length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[left] + nums[right];
                    if (sum > 0)      right -= 1;
                    else if (sum < 0) left += 1;
                    else {
                        // List<Integer> list = new ArrayList<>();
                        // list.add(nums[i]);
                        // list.add(nums[left]);
                        // list.add(nums[right]);
                        // lists.add(list);
                        lists.add(Arrays.asList(nums[i], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left+1])   left += 1;
                        while (left < right && nums[right] == nums[right-1]) right -= 1;
                        left += 1;
                        right -= 1;
                    }
                }
            }
            return lists;
        }
    }
  #+end_src 
* 17 电话号码的字母组合                       :DFS:回溯:递归:排列组合:字符串:
  #+begin_src java :classname 
    class Solution {
        Map<Character, String> phone = new HashMap<Character, String>() {{
                put('2', "abc");
                put('3', "def");
                put('4', "ghi");
                put('5', "jkl");
                put('6', "mno");
                put('7', "pqrs");
                put('8', "tuv");
                put('9', "wxyz");
            }};
        List<String> combinations = new ArrayList<>();
        public List<String> letterCombinations(String digits) {
            if (digits == null || digits.length() <= 0) return combinations;
            combinationsHelper("", digits, 0);
            return combinations;
        }
        private void combinationsHelper(String combination, String digits, int pos) {
            if (pos == digits.length()) combinations.add(combination);
            else {
                String s = phone.get(digits.charAt(pos));
                for (int i = 0; i < s.length(); i++) {
                    combinationsHelper(combination+s.substring(i, i+1), digits, pos+1);
                }
            }
        }
    }
  #+end_src 
* 19 删除链表的倒数第N个节点                                    :双指针:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode removeNthFromEnd(ListNode head, int n) {
            ListNode pivot = new ListNode(0);
            pivot.next = head;
            ListNode prev = pivot, p = head, tail = head;
            for (int i = 0; i < n; i++) tail = tail.next;
            while (tail != null) {
                prev = prev.next;
                p = p.next;
                tail = tail.next;
            }
            prev.next = p.next;
            return pivot.next;
        }
    }
  #+end_src 
* 20 有效的括号                                                   :栈:字符串:
  #+begin_src java :classname 
    class Solution {
        public boolean isValid(String s) {
            Stack<Character> stack = new Stack<>();
            for (int i = 0; i < s.length(); i++) {
                char ch = s.charAt(i);
                if (ch == '(' || ch == '[' || ch == '{') {
                    stack.push(ch);
                } else {
                    if (stack.empty()) return false;
                    switch (ch) {
                    case ')':
                        if (stack.peek() != '(') return false;
                        stack.pop();
                        break;
                    case ']':
                        if (stack.peek() != '[') return false;
                        stack.pop();
                        break;
                    case '}':
                        if (stack.peek() != '{') return false;
                        stack.pop();
                        break;
                    }
                }
            }
            return stack.empty();
        }
    }
  #+end_src 
* 21 合并有序链表                                                 :递归:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if (l1 == null) return l2;
            if (l2 == null) return l1;
            ListNode head = l1.val > l2.val ? l2 : l1;
            head.next = head == l1 ? mergeTwoLists(l1.next, l2) : mergeTwoLists(l1, l2.next);
            return head;
        }
    }
  #+end_src 
* 22 括号生成                              :DP:DFS:回溯:递归:排列组合:字符串:
** 回溯
   #+begin_src java :classname 
     class Solution {
         public List<String> generateParenthesis(int n) {
             List<String> list = new ArrayList<>();
             if (n != 0) dfs("", n, n, list);
             return list;
         }

         private void dfs(String s, int left, int right, List<String> list) {

             if (left == 0 && right == 0) {
                 list.add(s);
                 return;
             }

             if (left > right) return;
             if (left > 0) dfs(s+"(", left-1, right, list);
             if (right > 0) dfs(s+")", left, right-1, list);
         }
     }
   #+end_src 
** DP(闭合数)                                                    :UNRESOLVED:
* 23 合并K个排序链表                                             :UNRESOLVED:
* 31 下一个排列                                          :排序:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        public void nextPermutation(int[] nums) {
            int i = nums.length - 2;
            while (i >= 0 && nums[i] >= nums[i+1]) i -= 1;
            if (i >= 0) {
                for (int j = nums.length-1; j >= i+1; j--) {
                    if (nums[j] > nums[i]) {
                        swap(nums, i, j);
                        break;
                    }
                }
            }
            reverse(nums, i+1);
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }

        private void reverse(int[] nums, int start) {
            int end = nums.length - 1;
            while (start < end) {
                swap(nums, start, end);
                start += 1;
                end -= 1;
            }
        }
    }
  #+end_src 
* 32 最长有效括号                                                :UNRESOLVED:
* 33 搜索旋转排序数组 [[file:~/csnds/Dropbox/orglife/offer.org::<<ilink15>>][offer11]]                            :二分查找:查找:数组:
  #+begin_src java :classname 
    class Solution {
        public int search(int[] nums, int target) {
            if (nums == null || nums.length <= 0) return -1;
            int start = 0, end = nums.length - 1;
            if (nums[start] > nums[end]) {
                while (start < end) {
                    int mid = (start+end) >> 1;
                    if (nums[mid] > nums[end]) start = mid + 1;
                    else {
                        if (mid == 0 || nums[mid] < nums[mid-1]) {
                            end = nums.length - 1;
                            start = mid;
                            break;
                        }
                        end = mid;
                    }
                }
            }
            if (target > nums[end]) {
                end = start - 1;
                start = 0;
            }
            while (start < end) {
                int mid = (start+end) >> 1;
                if (nums[mid] == target) return mid;
                if (nums[mid] < target) start = mid + 1;
                else end = mid;
            }
            return nums[start] == target ? start : -1;
        }
    }
  #+end_src 
* 34 在排序数组中查找元素的第一个和最后一个位置 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink10>>][offer53]]  :二分查找:查找:数组:
  #+begin_src java :classname 
    class Solution {
        public int[] searchRange(int[] nums, int target) {
            if (nums == null || nums.length <= 0) return new int[] {-1, -1};
            int start = 0, end = nums.length - 1, mid = (start+end) >> 1;
            while (start < end) {
                if (nums[mid] == target) break;
                if (nums[mid] > target) end = mid;
                else start = mid + 1;
                mid = (start+end) >> 1;
            }
            if (nums[mid] != target) return new int[] {-1, -1};
            int[] res = new int[2];
            start = 0; end = mid;
            int left = (start+end) >> 1;
            while (start < end) {
                if (nums[left] < target) start = left + 1;
                else {
                    if (left == start || nums[left-1] != target) break;
                    end = left;
                }
                left = (start+end) >> 1;
            }
            res[0] = left;
            start = mid; end = nums.length - 1;
            int right = (start+end) >> 1;
            while (start < end) {
                if (nums[right] > target) end = right;
                else {
                    if (right == end || nums[right+1] != target) break;
                    start = right + 1;
                }
                right = (start+end) >> 1;
            }
            res[1] = right;
            return res;
        }
    }
  #+end_src 
* 39 组合总数                                   :DFS:回溯:递归:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        private List<List<Integer>> res = new ArrayList<>();
        private List<Integer> path = new ArrayList<>();
        public List<List<Integer>> combinationSum(int[] candidates, int target) {
            if (candidates == null || candidates.length <= 0) return res;
            Arrays.sort(candidates);
            combinationHelper(candidates, 0, target);
            return res;
        }

        private void combinationHelper(int[] candidates, int start, int target) {
            if (target == 0) {
                res.add(new ArraysList<Integer>(path));
                return;
            }
            for (int i = start; i < candidates.length; i++) {
                if (candidates[i] > target) break;
                path.add(candidates[i]);
                combinationHelper(candidates, i, target-candidates[i]);
                path.remove(path.size()-1);
            }
        }
    }
  #+end_src 
* 42 接雨水                                                      :UNRESOLVED:
* 46 全排列                                     :DFS:回溯:递归:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new ArrayList<>();
            if (nums == null || nums.length <= 0) return res;
            permuteHelper(nums, nums.length, 0, res);
            return res;
        }

        private void permuteHelper(int[] nums, int len, int pos, List<List<Integer>> res) {
            if (pos == len-1) {
                List<Integer> arr = new ArrayList<>();
                for (int i : nums) arr.add(i);
                res.add(arr);
                return;
            }
            for (int i = pos; i < len; i++) {
                swap(nums, pos, i);
                permuteHelper(nums, len, pos+1, res);
                swap(nums, pos, i);
            }
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
  #+end_src 
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new ArrayList<>();
            if (nums == null || nums.length <= 0) return res;
            List<Integer> arr = new ArrayList<>();
            for (int i : nums) arr.add(i);
            permuteHelper(arr, nums.length, 0, res);
            return res;
        }

        private void permuteHelper(List<Integer> arr, int len, int pos, List<List<Integer>> res) {
            if (pos == len-1) {
                res.add(new ArrayList<Integer>(arr));
                return;
            }
            for (int i = pos; i < len; i++) {
                Collections.swap(arr, pos, i);
                permuteHelper(arr, len, pos+1, res);
                Collections.swap(arr, pos, i);
            }
        }
    }
  #+end_src 
* 48 旋转图像                                            :矩阵:二维数组:数组:
** 旋转4个矩形(直接规律)
   #+begin_src java :classname 
     class Solution {
         public void rotate(int[][] matrix) {
             if (matrix == null || matrix.length <= 0 || matrix[0].length <= 0) return;
             int len = matrix.length, cir = len / 2;
             for (int i = 0; i < cir; i++) {
                 int endi = len - i - 1;
                 for (int j = i; j < endi; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[endi+i-j][i];
                     matrix[endi+i-j][i] = matrix[endi][endi+i-j];
                     matrix[endi][endi+i-j] = matrix[j][endi];
                     matrix[j][endi] = temp;
                 }
             }
         }
      }
   #+end_src 
** 转置+翻转(间接规律)
   #+begin_src java :classname 
     class Solution {
         public void rotate(int[][] matrix) {
             if (matrix == null || matrix.length <= 0 || matrix[0].length <= 0) return;
             int len = matrix.length;
             for (int i = 0; i < len; i++) {
                 for (int j = 0; j < i; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[j][i];
                     matrix[j][i] = temp;
                 }
             }
             for (int i = 0; i < len; i++) {
                 for (int j = 0; j < len/2; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[i][len-1-j];
                     matrix[i][len-1-j] = temp;
                 }
             }
         }
     }
   #+end_src 
   - 顺时针 -> 转置+按行翻转
   - 逆时针 -> 转置+按列翻转
* 49 字母异位词分组                              :排序:映射:数组:字符:字符串:
** 暴力
   #+begin_src java :classname 
     class Solution {
         public List<List<String>> groupAnagrams(String[] strs) {
             List<List<String>> res = new ArrayList<>();
             if (strs == null || strs.length <= 0) return res;
             boolean[] added = new boolean[strs.length];
             for (int i = 0; i < strs.length; i++) {
                 List<String> list = new ArrayList<>();
                 if (added[i]) continue;
                 list.add(strs[i]);
                 added[i] = true;
                 for (int j = i+1; j < strs.length; j++) {
                     if (added[j]) continue;
                     if (strs[i].length() == strs[j].length()) {
                         if (strs[i].equals(strs[j]) || isAnagram(strs[i], strs[j])) {
                             list.add(strs[j]);
                             added[j] = true;
                         }
                     }
                 }
                 if (!list.isEmpty()) res.add(list);
             }
             return res;
         }

         private boolean isAnagram(String s1, String s2) {
             int[] set = new int[26];
             for (int i = 0; i < s1.length(); i++) set[s1.charAt(i)-'a'] += 1;
             for (int i = 0; i < s2.length(); i++) set[s2.charAt(i)-'a'] -= 1;
             for (int i = 0; i < 26; i++) if(set[i] != 0) return false;
             return true;
         }
     }
   #+end_src 
** 排序+映射
   #+begin_src java :classname 
     class Solution {
         public List<List<String>> groupAnagrams(String[] strs) {
             List<List<String>> res = new ArrayList<>();
             if (strs == null || strs.length <= 0) return res;
             Map<String, List<String>> map = new HashMap<>();
             for (String s : strs) {
                 char[] chs = s.toCharArray();
                 Arrays.sort(chs);
                 // String key = String.valueOf(chs);
                 String key = new String(chs); // 更快
                 if (!map.containsKey(key)) map.put(key, new ArrayList<String>());
                 map.get(key).add(s);
             }
             // return new ArrayList<>(map.values());
             res.addAll(map.values());
             return res;
         }
     }
   #+end_src 
* 53 最大子序和                                                     :DP:数组:
  #+begin_src java :classname 
    class Solution {
        public int maxSubArray(int[] nums) {
            int maxSum = Integer.MIN_VALUE, curSum = 0;
            if (nums == null || nums.length <= 0) return max;
            for (int i = 0; i < nums; i++) {
                curSum += nums[i];
                if (maxSum < curSum) maxSum = curSum;
                if (curSum < 0) curSum = 0;
            }
            return maxSum;
        }
    }
  #+end_src 
* 55 跳跃游戏                                        :DP:贪心:回溯:递归:数组:
** 递归(回溯)
   #+begin_src java :classname 
     class Solution {
         public boolean canJump(int[] nums) {
             if (nums == null || nums.length <= 0) return false;
             return canJumpHelper(nums, 0, nums.length-1);
         }

         private boolean canJumpHelper(int[] nums, int pos, int end) {
             if (pos == end) return true;
             for (int i = i; i <= nums[pos]; i++) {
                 if (pos+i > end) return false;
                 if (canJumpHelper(nums, pos+i, end)) return true;
             }
             return false;
         }
     }
   #+end_src 
** DP                                                            :UNRESOLVED:
** 贪心
   #+begin_src java :classname 
     class Solution {
         public boolean canJump(int[] nums) {
             if (nums == null || nums.length <= 0) return false;
             int lastPos = nums.length - 1;
             for (int i = nums.length-1; i >= 0; i--) {
                 if (i + nums[i] >= lastPos) lastPos = i;
             }
             return lastPos == 0;
         }
     }
   #+end_src 
* 56 合并区间                                            :排序:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int[][] merge(int[][] intervals) {
            if (intervals == null || intervals.length <= 0 || intervals[0].length <= 0) return new int[][] {}; // new int[0][];

            // Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

            // Comparator<int[]> intervalComparator = (int[] interval1, int[] interval2) -> {
            //     return interval1[0] - interval2[0];
            // };
            // Arrays.sort(intervals, intervalComparator);

            Arrays.sort(intervals, new Comparator<int[]>() {
                    @Override
                    public int compare(int[] interval1, int[] interval2) {
                        return Integer.compare(interval1[0], interval2[0]);
                        // return interval1[0] - interval2[0];
                    }
                });
            List<int[]> res = new ArrayList<>();
            for (int i = 0; i < intervals.length; i++) {
                int start = intervals[i][0];
                int end = intervals[i][1];
                int j = i + 1;
                for (; j < intervals.length; j++) {
                    if (intervals[j][0] > end) break;
                    if (intervals[j][1] > end) end = intervals[j][1];
                }
                res.add(new int[]{start, end});
                i = j - 1;
            }

            return res.toArray(new int[res.size()][]);

            // int[][] combineIntervals = new int[res.size()][];
            // for (int i = 0; i < res.size(); i++) {
            //     combineIntervals[i] = res.get(i);
            // }
            // return combineIntervals;
        }
    }
  #+end_src 
* 62 不同路径                                              :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int uniquePaths(int m, int n) {
            int[][] paths = new int[m][n];
            for (int i = 0; i < m; i++) paths[i][0] = 1;
            for (int i = 1; i < n; i++) paths[0][i] = 1;
            for (int i = 1; i < m; i++) {
                for (int j = 1; j < n; j++) paths[i][j] = paths[i-1][j] + paths[i][j-1];
            }
            return paths[m-1][n-1];
        }
    }
  #+end_src 
* 64 最小路径和                                            :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int minPathSum(int[][] grid) {
            if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
            int rows = grid.length, cols = grid[0].length;
            for (int row = 1; row < rows; row++) grid[row][0] += grid[row-1][0];
            for (int col = 1; col < cols; col++) grid[0][col] += grid[0][col-1];
            for (int row = 1; row < rows; row++) {
                for (int col = 1; col < cols; col++) grid[row][col] += Math.min(grid[row-1][col], grid[row][col-1]);
            }
            return grid[rows-1][cols-1];
        }
    }
  #+end_src 
* 70 爬楼梯                                                              :DP:
** DP
   #+begin_src java :classname 
     class Solution {
         public int climbStairs(int n) {
             int a1 = 1, a2 = 1;
             while (n > 1) {
                 int a3 = a1 + a2;
                 a1 = a2;
                 a2 = a3;
                 n -= 1;
             }
             return a2;
         }
     }
   #+end_src 
** Binets法                                                      :UNRESOLVED:
** 斐波那契公式                                                  :UNRESOLVED:
* 72 编辑距离                                                    :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int minDistance(String word1, String word2) {

        }
    }
  #+end_src 
* 75 颜色分类                                         :三指针:快排:排序:数组:
** 三路快排 [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink19>>][Hoare Partition]]
   #+begin_src java :classname 
     class Solution {
         public void sortColors(int[] nums) {
             int next0 = 0, next2 = nums.length - 1;
             while (next0 < nums.length && nums[next0] == 0) next0 += 1;
             while (next2 >= 0 && nums[next2] == 2) next2 -= 1;
             int cur = next0;
             while (cur <= next2) {
                 switch (nums[cur]) {
                 case 0:
                     swap(nums, cur, next0);
                     while (next0 < nums.length && nums[next0] == 0) next0 += 1;
                     cur = next0;
                     break;
                 case 2:
                     swap(nums, cur, next2);
                     while (next2 >= 0 && nums[next2] == 2) next2 -= 1;
                     break;
                 case 1:
                     cur += 1;
                     break;
                 }
             }
         }

         private void swap(int[] nums, int i, int j) {
             int temp = nums[i];
             nums[i] = nums[j];
             nums[j] = temp;
         }
     }
   #+end_src 
* 76 最小覆盖子串                                                :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public String minWindow(String s, String t) {

        }
    }
  #+end_src 
* 78 子集                                                    :回溯:递归:数组:
** 迭代
   #+begin_src java :classname 
     class Solution {
         public List<List<Integer>> subsets(int[] nums) {
             List<List<Integer>> res = new ArrayList<>();
             if (nums == null || nums.length <= 0) return res;
             res.add(new ArrayList<Integer>());
             for (int i = 0; i < nums.length; i++) {
                 int news = res.size();
                 for (int j = 0; j < news; j++) {
                     List<Integer> newSubSet = new ArrayList<>(res.get(j));
                     newSubSet.add(nums[i]);
                     res.add(newSubSet);
                 }
             }
             return res;
         }
     }
   #+end_src 
** 回溯
   #+begin_src java :classname 
     class Solution {
         public List<List<Integer>> subsets(int[] nums) {
             List<List<Integer>> res = new ArrayList<>();
             if (nums == null || nums.length <= 0) return res;
             backtrack(res, nums, 0, nums.length, new ArrayList<Integer>());
             return res;
         }

         private void backtrack(List<List<Integer>> res, int[] nums, int start, int len, ArrayList<Integer> newSubSet) {
             res.add(new ArrayList<>(newSubSet));
             for (int i = start; i < len; i++) {
                 newSubSet.add(nums[i]);
                 backtrack(res, nums, i+1, len, newSubSet);
                 newSubSet.remove(newSubSet.size()-1);
             }
         }
     }
   #+end_src 
** 字典排序(二进制排序)                                          :UNRESOLVED:
* 79 单词搜索                                   :DFS:回溯:递归:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public boolean exist(char[][] board, String word) {
            if (board == null || board.length <= 0 || board[0].length <= 0) return false;
            int rows = board.length, cols = board[0].length;
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    boolean[][] visited = new boolean[rows][cols];
                    if (existHelper(board, word, i, rows, j, cols, 0, visited)) return true;
                }
            }
            return false;
        }

        private boolean existHelper(char[][] board, String word, int row, int rows, int col, int cols, int pos, boolean[][] visited) {
            if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
            if (visited[row][col] || board[row][col] != word.charAt(pos)) return false;
            if (pos == word.length()-1) return true;
            visited[row][col] = true;
            pos += 1;
            if (existHelper(board, word, row-1, rows, col, cols, pos, visited) ||
                existHelper(board, word, row+1, rows, col, cols, pos, visited) ||
                existHelper(board, word, row, rows, col-1, cols, pos, visited) ||
                existHelper(board, word, row, rows, col+1, cols, pos, visited)) return true;
            visited[row][col] = false;
            return false;
        }
    }
  #+end_src 
* 84 柱状图中最大的矩形                                          :UNRESOLVED:
  #+begin_src java :classname 
  #+end_src 
* 85 最大矩形                                                    :UNRESOLVED:
* 94 二叉树的中序遍历                           :DFS:递归:中序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> order = new ArrayList<>();
            inorderHelper(root, order);
            return order;
        }

        private void inorderHelper(TreeNode root, List<Integer> order) {
            if (root == null) return;
            inorderHelper(root.left, order);
            order.add(root.val);
            inorderHelper(root.right, order);
        }
    }
  #+end_src 
* 96 不同的二叉搜索树                          :DP:递归:二叉搜索树:二叉树:树:
** 递归
   #+begin_src java :classname 
     class Solution {
         public int numTrees(int n) {
             if (n <= 1) return n;
             return numHelper(1, n);
         }

         private int numHelper(int start, int end) {
             if (start >= end) return 1;
             int num = 0;
             for (int i = start; i <= end; i++) {
                 int left = numHelper(start, i - 1);
                 int right = numHelper(i+1, end);
                 num += left * right;
             }
             return num;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         public int numTrees(int n) {
             int[] res = new int[n+1];
             res[0] = 1;
             for (int i = 1; i <= n; i++) {
                 for (int j = 1; j <= i; j++) {
                     res[i] += res[j-1]*res[i-j];
                 }
             }
             return res[n];
         }
     }
   #+end_src 
** 数学演绎法                                                    :UNRESOLVED:
* 97 验证二叉搜索树                               :递归:二叉搜索树:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public boolean isValidBST(TreeNode root) {
            if (root == null) return true;
            boolean isBST = true;
            if (root.left != null) isBST = isBST && maxVal(root.left) < root.val && isValidBST(root.left);
            if (root.right != null) isBST = isBST && minVal(root.right) > root.val && isValidBST(root.right);
            return isBST;
        }

        private int maxVal(TreeNode root) {
            while (root.right != null) root = root.right;
            return root.val;
        }

        private int minVal(TreeNode root) {
            while (root.left != null) root = root.left;
            return root.val;
        }
    }
  #+end_src 
* 101 对称二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink11>>][offer28]]                                     :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public boolean isSymmetric(TreeNode root) {
            if (root == null) return true;
            return isSymmetricHelper(root.left, root.right);
        }

        private boolean isSymmetricHelper(TreeNode n1, TreeNode n2) {
            if (n1 == null && n2 == null) return true;
            if (n1 == null || n2 == null) return false;
            return n1.val == n2.val && isSymmetricHelper(n1.left, n2.right) && isSymmetricHelper(n1.right, n2.left);
        }
    }
  #+end_src 
* 102 二叉树的层序遍历                               :BFS:层序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();
            if (root == null) return res;
            Queue<TreeNode> que = new LinkedList<>();
            que.offer(root);
            while (!que.isEmpty()) {
                int len = que.size();
                List<Integer> list = new ArrayList<>();
                for (int i = 0; i < len; i++) {
                    TreeNode poll = que.poll();
                    list.add(poll.val);
                    if (poll.left != null) que.offer(poll.left);
                    if (poll.right != null) que.offer(poll.right);
                }
                res.add(list);
            }
            return res;
        }
    }
  #+end_src 

* 104 二叉树的最大深度 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink13>>][offer55]]                               :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public int maxDepth(TreeNode root) {
            if (root == null) return 0;
            return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
        }
    }
  #+end_src 
* 105 从前序和中序遍历序列构造二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink14>>][offer7]] :数组:递归:中序遍历:前序遍历:二叉树:树:
** 直接递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode buildTree(int[] preorder, int[] inorder) {
             if (preorder == null || inorder == null || preorder.length != inorder.length || preorder.length <= 0) return null;
             int len = preorder.length, rootVal = preorder[0], pos = -1;
             TreeNode root = new TreeNode(rootVal);
             for (int i = 0; i < len; i++) {
                 if (inorder[i] == rootVal) {
                     pos = i;
                     break;
                 }
             }
             if (pos == -1) return null;
             root.left = buildTree(Arrays.copyOfRange(preorder, 1, pos+1), Arrays.copyOfRange(inorder, 0, pos));
             root.right = buildTree(Arrays.copyOfRange(preorder, pos+1, len), Arrays.copyOfRange(inorder, pos+1, len));
             return root;
         }
     }


   #+end_src 
** 辅助递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode buildTree(int[] preorder, int[] inorder) {
             if (preorder == null || inorder == null || preorder.length != inorder.length || preorder.length <= 0) return null;

             // int rootVal = preorder[0], index = -1, len = preorder.length;
             // TreeNode root = new TreeNode(preorder[0]);
             // for (int i = 0; i < len; i++) {
             //     if (inorder[i] == rootVal) index = i;
             // }
             // if (index == -1) return null;
             // root.left = buildTree(Arrays.copyOfRange(preorder, 1, index+1), Arrays.copyOfRange(inorder, 0, index));
             // root.right = buildTree(Arrays.copyOfRange(preorder, index+1, len), Arrays.copyOfRange(inorder, index+1, len));
             // return root;

             return buildHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
         }
         private TreeNode buildHelper(int[] preorder, int s1, int e1, int[] inorder, int s2, int e2) {
             if (s1 == e1 && s2 == e2) return null;
             int rootVal = preorder[s1], index = -1;
             TreeNode root = new TreeNode(rootVal);
             for (int i = s2; i < e2; i++) {
                 if (inorder[i] == rootVal) index = i;
             }
             if (index == -1) return null;
             root.left = buildHelper(preorder, s1+1, s1+1+index-s2, inorder, s2, index);
             root.right = buildHelper(preorder, s1+1+index-s2, e1, inorder, index+1, e2);
             return root;
         }
     }
   #+end_src 
* 114 二叉树展开为链表
  #+begin_src java :classname 
    class Solution {
        public void flatten(TreeNode root) {
        }
    }
  #+end_src 
* 121 买卖股票的最佳时机                                               :数组:
  #+begin_src java :classname 
    class Solution {
        public int maxProfit(int[] prices) {
            int max = 0, buy = 0, len = prices.length;
            for (int i = 0; i < len; i++) {
                int cur = prices[i] - prices[buy];
                if (max < cur) max = cur;
                if (cur < 0) buy = i;
            }
            return max;
        }
    }
  #+end_src 
* 124 二叉树中的最大路径和                                       :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int maxPathSum(TreeNode root) {

        }
    }
  #+end_src 
* 128 最长连续序列                                               :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int longestConsecutive(int[] nums) {

        }
    }
  #+end_src 
* 136 只出现一次的数字                                          :位运算:数组:
  #+begin_src java :classname 
    class Solution {
        public int singleNumber(int[] nums) {
            int xor = 0;
            for (int i = 0; i < nums.length; i++) xor ^= nums[i];
            return xor;
        }
    }
  #+end_src 
* 139 单词拆分
  #+begin_src java :classname 
    class Solution {
        public boolean wordBreak(String s, List<String> wordDict) {

        }
    }
  #+end_src 
* 141 环形链表                                         :快慢指针:双指针:链表:
  #+begin_src java :classname 
    public class Solution {
        public boolean hasCycle(ListNode head) {
            ListNode p1 = head, p2 = head;
            while (p1 != null && p2 != null) {
                p1 = p1.next;
                if (p2.next == null) break;
                p2 = p2.next.next;
                if (p1 == p2) return true;
            }
            return false;
        }
    }
  #+end_src 
* 142 环形链表 2
  #+begin_src java :classname 
    public class Solution {
        public ListNode detectCycle(ListNode head) {

        }
    }
  #+end_src 
* 803 打砖块                                                   :HARD:TOBEORG:
  #+begin_src java :classname 
    public class Solution {

        public int[] hitBricks(int[][] grid, int[][] hits) {
            // TODO
            if (grid == null || grid.length == 0 || grid[0].length == 0) return null;
            if (hits == null || hits.length == 0 || hits[0].length != 2) return null;
            int row = grid.length, col = grid[0].length, hitsNum = hits.length;
            for (int[] dart: hits) {
                if (dart[0] < 0 || dart[0] >= row ||
                        dart[1] < 0 || dart[1] >= col) return null;
            }

            int[] ur = {1, 0, -1, 0};
            int[] uc = {0, 1, 0, -1};
            int root = row * col;
            UnionFind union = new UnionFind(root + 1);
            int[][] copy = new int[row][col];

            for (int i = 0; i < row; i++) {
                copy[i] = grid[i].clone();
            }

            for (int[] dart: hits) {
                copy[dart[0]][dart[1]] = 0;
            }

            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (copy[i][j] == 1) {
                        if (i == 0) {
                            union.union(xyToint(col, i, j), root);
                            continue;
                        }
                        if (i - 1 >= 0 && copy[i-1][j] == 1) {
                            union.union(xyToint(col, i, j), xyToint(col, i-1, j));
                        }
                        if (j - 1 >= 0 && copy[i][j-1] == 1) {
                            union.union(xyToint(col, i, j), xyToint(col, i, j-1));
                        }
                    }
                }
            }


            int[] bubbles = new int[hitsNum];

            for (int i = hitsNum - 1; i >= 0; i--) {
                int afterPop = union.sizeOf(root);
                int r = hits[i][0];
                int c = hits[i][1];
                if (grid[r][c] == 0) continue;
                if (r == 0) union.union(xyToint(col, r, c), root);
                for (int j = 0; j < 4; j++) {
                    int nr = r + ur[j];
                    int nc = c + uc[j];
                    if (nr >= 0 && nr < row &&
                            nc >=0 && nc < col && copy[nr][nc] == 1) {
                        union.union(xyToint(col, r, c), xyToint(col, nr, nc));
                    }
                }
                int pops = union.sizeOf(root) - afterPop - 1;
                bubbles[i] = pops > 0 ? pops : 0;
                copy[r][c] = 1;
            }
            return bubbles;
        }


        private int xyToint(int col, int r, int c) {
            return r * col + c;
        }

    }


    class UnionFind {

        private int[] vertice;

        // TODO - Add instance variables?

        /* Creates a UnionFind data structure holding n vertices. Initially, all
           vertices are in disjoint sets. */
        public UnionFind(int n) {
            // TODO
            vertice = new int[n];
            for (int i = 0; i < n; i++) {
                vertice[i] = -1;
            }
        }

        /* Throws an exception if v1 is not a valid index. */
        private void validate(int vertex) {
            // TODO
            if (vertex < 0 || vertex >= this.vertice.length) {
                throw new IllegalArgumentException(vertex
                        + "is not a valid index.");
            }
        }

        /* Returns the size of the set v1 belongs to. */
        public int sizeOf(int v1) {
            // TODO
            return - vertice[find(v1)];
        }

        /* Returns the parent of v1. If v1 is the root of a tree, returns the
           negative size of the tree for which v1 is the root. */
        public int parent(int v1) {
            // TODO
            return vertice[v1] < 0 ? v1 : vertice[v1];
        }

        /* Returns true if nodes v1 and v2 are connected. */
        public boolean connected(int v1, int v2) {
            // TODO
            int r1 = find(v1);
            int r2 = find(v2);
    //        int p1 = parent(v1);
    //        int p2 = parent(v2);
    //
    //        while (p1 != r1) {
    //            vertice[v1] = r1;
    //            v1 = p1;
    //            p1 = parent(v1);
    //        }
    //        while (p2 != r2) {
    //            vertice[v2] = r2;
    //            v2 = p2;
    //            p2 = parent(v2);
    //        }

            return r1 == r2;
        }

        /* Connects two elements v1 and v2 together. v1 and v2 can be any valid
           elements, and a union-by-size heuristic is used. If the sizes of the sets
           are equal, tie break by connecting v1's root to v2's root. Unioning a 
           vertex with itself or vertices that are already connected should not 
           change the sets but may alter the internal structure of the data. */
        public void union(int v1, int v2) {
            // TODO
            validate(v1);
            validate(v2);
            if (!connected(v1, v2)) {
                if (sizeOf(v1) <= sizeOf(v2)) {
                    vertice[find(v2)] += vertice[find(v1)];
                    vertice[find(v1)] = find(v2);
                } else {
                    vertice[find(v1)] += vertice[find(v2)];
                    vertice[find(v2)] = find(v1);
                }
            }
        }

        /* Returns the root of the set V belongs to. Path-compression is employed
           allowing for fast search-time. */
        public int find(int vertex) {
            // TODO
            return vertice[vertex] < 0 ? vertex : find(parent(vertex));
        }

        public int[] getSet() {
            return vertice;
        }
    }
  #+end_src 
* 637 二叉树的层平均值                                    :SIMPLE:UNRESOLVED:
*** DFS
*** BFS





* Mysql
** 511 游戏玩法分析1
 #+begin_src sql
   SELECT player_id, min(event_date) 'first_login' FROM Activity GROUP BY player_id ORDER BY player_id ASC;
 #+end_src
** 512 游戏玩法分析2
   #+begin_src sql
     SELECT a.player_id, a.device_id FROM Activity a WHERE (a.player_id, a.event_date) IN (SELECT player_id, min(event_date) AS first_login FROM Activity GROUP BY player_id);
   #+end_src
** 577 员工奖金
   #+begin_src sql
     SELECT a.name, b.bonus FROM Employee a LEFT JOIN Bonus b ON a.empId = b.empId WHERE b.bonus IS NULL OR b.bonus < 1000;
   #+end_src
** 584 寻找用户推荐人
   #+begin_src sql
     SELECT name FROM customer WHERE referee_id != 2 OR referee_id IS NULL;
   #+end_src
** 586 订单最多的用户
   #+begin_src sql
     SELECT
         customer_number
     FROM
         orders
     GROUP BY customer_number
     ORDER BY COUNT(*) DESC
     LIMIT 1
     ;
   #+end_src

** 597 好友申请1 总体通过率
   #+begin_src sql
     SELECT
     ROUND(
         IFNULL(
         (SELECT COUNT(DISTINCT requester_id, accepter_id) FROM request_accepted as A)
         /
         (SELECT COUNT(DISTINCT sender_id, send_to_id) FROM friend_request as B),
         0)
     , 2) as accept_rate;
   #+end_src

** 603 连续空余座位
   #+begin_src sql
     SELECT DISTINCT a.seat_id
       FROM cinema a JOIN cinema b
       ON ABS(a.seat_id - b.seat_id) = 1
       AND a.free = TRUE AND b.free = TRUE
       ORDER BY a.seat_id;
   #+end_src
** 607 销售员
   #+begin_src sql
     SELECT
         name
     FROM
         salesperson
     WHERE
         sales_id NOT IN (SELECT
               a.sales_id
           FROM
               orders a
                   LEFT JOIN
               company b ON b.com_id = a.com_id
           WHERE
               b.name = 'RED');
   #+end_src

** 610 判断三角形
   #+begin_src sql
     SELECT x, y, z, CASE
                         WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
                         ELSE 'No'
                     END AS 'triangle' FROM triangle;
   #+end_src

** 613 直线上的最近距离
   #+begin_src sql
     SELECT
         MIN(ABS(p1.x - p2.x)) as shortest
     FROM
         point p1
             JOIN
         point p2 on p1.x != p2.x;
   #+end_src
** 619 只出现一次的最大数字
   - 错误
     #+begin_src sql
       SELECT a.num FROM (SELECT num, COUNT(*) AS times FROM my_numbers GROUP BY num) AS a WHERE a.times = 1 ORDER BY a.num DESC LIMIT 1;
     #+end_src
   - 正确
     #+begin_src sql
       SELECT MAX(num) AS num FROM (SELECT num FROM my_numbers GROUP BY num HAVING COUNT(num) = 1) AS t;
     #+end_src
** 1050 合作过至少三次的演员和导演
   #+begin_src sql
     SELECT actor_id, director_id FROM ActorDirector GROUP BY actor_id, director_id HAVING COUNT(*) > 2;
   #+end_src
** 1068 产品销售分析 1
   - 不使用链接
     #+begin_src sql
       SELECT a.product_name, b.year, b.price FROM Product a, Sales b WHERE a.product_id = b.product_id;
     #+end_src
   - 使用链接
     #+begin_src sql
       SELECT a.product_name, b.year, b.price FROM Product a RIGHT JOIN Sales b ON a.product_id = b.product_id;
     #+end_src
** 1069 产品销售分析 2
   #+begin_src sql
     SELECT product_id, SUM(quantity) as total_quantity FROM Sales GROUP BY product_id;
   #+end_src
** 1075 项目员工 1
   #+begin_src sql
     SELECT a.project_id, ROUND(AVG(b.experience_years), 2) AS average_years FROM Project a LEFT JOIN Employee b ON a.employee_id = b.employee_id GROUP BY a.project_id ORDER BY a.project_id ASC;
   #+end_src
** 1076 项目员工 2
   #+begin_src sql
     SELECT project_id FROM project GROUP BY project_id HAVING COUNT(*) = (SELECT COUNT(*) times FROM project GROUP BY project_id ORDER BY times DESC LIMIT 1);
   #+end_src
** 1082 销售分析 1
   #+begin_src sql
     SELECT seller_id FROM Sales GROUP BY seller_id HAVING SUM(price) = (SELECT SUM(price) total_sale FROM Sales GROUP BY seller_id ORDER BY total_sale DESC LIMIT 1);
   #+end_src
** 1083 销售分析 2
   #+begin_src sql
     SELECT DISTINCT buyer_id
     FROM Product a RIGHT JOIN Sales b
     ON a.product_id = b.product_id
     WHERE product_name = 'S8'
     AND (buyer_id NOT IN (
     SELECT buyer_id FROM Product a RIGHT JOIN Sales b
     ON a.product_id = b.product_id
     WHERE a.product_name = 'iPhone'));
   #+end_src
** 1084 销售分析 4
   #+begin_src sql
     -- SELECT DISTINCT b.product_id, a.product_name
     -- FROM Product a RIGHT JOIN Sales b
     -- ON a.product_id = b.product_id
     -- GROUP BY b.product_id
     -- HAVING SUM(b.sale_date NOT BETWEEN
     -- "2019-01-01" AND "2019-03-31") = 0;

     SELECT S.product_id, P.product_name
     FROM Product P, Sales S
     WHERE P.product_id = S.product_id
     GROUP BY S.product_id
     HAVING SUM(S.sale_date NOT BETWEEN
     "2019-01-01" AND "2019-03-31") = 0;
   #+end_src
** 1113 报告的记录
   #+begin_src sql
     SELECT extra report_reason, COUNT(DISTINCT post_id, extra) report_count
     FROM Actions
     WHERE DATEDIFF('2019-07-05', action_date) = 1
     AND action = 'report'
     GROUP BY report_reason
     ORDER BY report_count ASC;
   #+end_src
** 1141 查询近30天活跃用户数
   #+begin_src sql
     SELECT activity_date day, COUNT(DISTINCT user_id) active_users
     FROM Activity
     WHERE DATEDIFF('2019-07-27', activity_date) < 30
     -- AND (activity_type = 'scroll_down' OR activity_type = 'send_message')
     GROUP BY day
     ORDER BY day ASC;
   #+end_src
** 1142 过去30天的用户活动 2
   #+begin_src sql
     SELECT IFNULL(ROUND(COUNT(DISTINCT session_id)/COUNT(DISTINCT user_id), 2), 0) average_sessions_per_user
     FROM Activity
     WHERE DATEDIFF('2019-07-27', activity_date) < 30;
   #+end_src
** 1143 文章浏览 1
   #+begin_src sql
     SELECT DISTINCT author_id id
     FROM Views
     WHERE author_id = viewer_id
     ORDER BY author_id ASC;
   #+end_src
