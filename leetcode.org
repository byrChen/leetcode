#+TAGS: TOBEORG(t) UNRESOLVED(u) QUESTIONS(q)
* 1 两数之和                                                           :数组:
** 暴力解法
   #+begin_src java :classname 
     class Solution {
         public int[] twoSum(int[] nums, int target) {
             for (int i=0; i < nums.length; i++) {
                 int other = target - nums[i];
                 for (int j = i + 1; j < nums.length; j++) {
                     if (other == nums[j]) {
                         return new int[] {i, j};
                     }
                 }
             }
             throw new IllegalArgumentException("No two sum solution");
         }
     }
   #+end_src 
   - ~new int[] {i, j}~
   - 复杂度
     - $O(n^2)$
     - $O(1)$
** 哈希映射
   - Two-pass
     #+begin_src java :classname 
       class Solution {
           public int[] twoSum(int[] nums, int target) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int i = 0; i < nums.length; i++) {
                   map.put(nums[i], i);
               }
               for (int j = 0; j < nums.length; j++) {
                   int rest = target - nums[j];
                   if (map.containsKey(rest) && map.get(rest) != j) {
                       return new int[] {j, map.get(rest)};
                   }
               }
               throw new IllegalArgumentException("No two sum solution");
           }
       }
     #+end_src
     - ~Map<Integer, Integer> map = new HashMap<>()~
     - ~map.put(nums[i], i)~, ~map.containsKey(rest)~ and ~map.get(rest) != j~
     - 复杂度
       - $O(n)$: 哈希表的查找时间复杂度为 $O(1)$
       - $O(n)$: 哈希表大小为 $n$
   - One-pass
     #+begin_src java :classname 
       class Solution {
           public int[] twoSum(int[] nums, int target) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int i = 0; i < nums.length; i++) {
                   int rest = target - nums[i];
                   if (map.containsKey(rest)) {
                       return new int[] {map.get(rest), i};
                   }
                   map.put(nums[i], i);
               }
               throw new IllegalArgumentException("No two sum solution");
           }
       }
     #+end_src
     - 复杂度: 和 Two-pass 一样
* 2 两数相加                                                           :链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            ListNode head = new ListNode(0), p = head;
            int carry = 0;
            while (l1 != null || l2 != null) {
                int sum = carry;
                if (l1 != null) sum += l1.val;
                if (l2 != null) sum += l2.val;
                p.next = new ListNode(sum % 10);
                carry = sum / 10;
                p = p.next;
                if (l1 != null) l1 = l1.next;
                if (l2 != null) l2 = l2.next;
            }
            if (carry != 0) p.next = new ListNode(carry);
            return head.next;
        }
    }
  #+end_src 
* 3 无重复字符的最长子串 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink8>>][offer48]]                           :DP:双指针:字符串:
  #+begin_src java :classname 
    class Solution {
        public int lengthOfLongestSubstring(String s) {
            if (s == null || s.length() <= 0) return 0;
            int max = 0, start = 0, len = s.length();
            Map<Character, Integer> map = new HashMap<>();
            for (int i = 0; i < len; i++) {
                char ch = s.charAt(i);
                if (map.containsKey(ch) && map.get(ch) >= start) {
                    int next = map.get(ch);
                    if (i - start > max) max = i - start;
                    start = next + 1;
                }
                map.put(ch, i);
            }
            if (len - start > max) max = len - start;
            return max;
        }
    }
  #+end_src 
* 4 寻找两个有序数组的中位数                                     :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        }
    }
  #+end_src 
* 5 最长回文子串                         :DP:扩展窗口:双指针:中心扩展:字符串:
** 中心扩展算法 <<ilink5>>
   #+begin_src java :classname 
     class Solution {
         public String longestPalindrome(String s) {
             if (s == null || s.length() <= 1) return "";
             int start = 0, end = 0;
             for (int i = 0; i < s.length(); i++) {
                 int oddL = expandAroundCenter(s, i, i);
                 int evenL = expandAroundCenter(s, i, i+1);
                 int len = Math.max(oddL, evenL);
                 if (len > end-start+1) {
                     start = i - (len-1) / 2;
                     end = i + len / 2;
                 }
             }
             return s.substring(start, end+1);
         }

         private int expandAroundCenter(String s, int l, int r) {
             while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
                 l -= 1;
                 r += 1;
             }
             return r - l - 1;
         }
     }
   #+end_src 
** 最长公共子串(DP)                                              :UNRESOLVED:
* 7 整数翻转
  #+begin_src java :classname 
    class Solution {
        public int reverse(int x) {
            long res = 0;
            while (x != 0) {
                res = res*10 + x % 10;
                if (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) return 0;
                x = x / 10;
            }
            return (int)res;
        }
    }
  #+end_src 
* 8 字符串转换整数(atoi)                                        :大数:字符串:
  #+begin_src java :classname 
    class Solution {
        public int myAtoi(String str) {
            str = str.trim();
            if (str == null || str.length() == 0) return 0;
            char cur = str.charAt(0);
            boolean neg = cur == '-' ? true : false;
            int i = 0;
            if (neg || cur == '+') i++;
            long res = 0;
            for (; i < str.length(); i++) {
                cur = str.charAt(i);
                if (cur < '0' || cur > '9') break;
                res = neg ? 10*res+'0'-cur : 10*res + cur-'0';
                if (res < Integer.MIN_VALUE) return Integer.MIN_VALUE;
                if (res > Integer.MAX_VALUE) return Integer.MAX_VALUE;
            }
            return (int)res;
        }
    }
  #+end_src 
* 10 正则表达式匹配 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink9>>][offer19]]                         :DP:DFS:回溯:递归:字符串:
** 递归
   #+begin_src java :classname 
     class Solution {
         public boolean isMatch(String s, String p) {
             if (s == null || p == null) return false;
             return matchHelper(s.toCharArray(), 0, p.toCharArray(), 0);
         }

         private boolean matchHelper(char[] s, int i, char[] p, int j) {
             if (i == s.length && j == p.length) return true;
             else if (j == p.length) return false;

             if (j+1 < p.length && p[j+1] == '*') {
                 if (i < s.length && (s[i] == p[j] || p[j] == '.')) return matchHelper(s, i+1, p, j) || matchHelper(s, i, p, j+2);
                 return matchHelper(s, i, p, j+2);
             }

             if (i < s.length && (s[i] == p[j] || p[j] == '.')) return matchHelper(s, i+1, p, j+1);
             return false;
         }
     }
   #+end_src 
** 回溯
** DP
* 11 盛最多水的容器                                             :双指针:数组:
** 双指针
   #+begin_src java :classname 
     class Solution {
         public int maxArea(int[] height) {
             int max = 0, left = 0, right = height.length-1;
             while (left < right) {
                 int cur = (right-left) * Math.min(height[left], height[right]);
                 if (cur > max) max = cur;
                 if (height[left] < height[right]) left+= 1;
                 else right -= 1;
             }
             return max;
         }
     }
   #+end_src 
* 13 罗马数字转整数                                                  :字符串:
  #+begin_src java :classname 
    class Solution {
        public int romanToInt(String s) {
            char[] chs = s.toCharArray();
            int res = 0, len = chs.length;
            for (int i = 0; i < len; i++) {
                switch (chs[i]) {
                case 'I':
                    if (i+1 < len && (chs[i+1] == 'V' || chs[i+1] == 'X')) res -= 1;
                    else res += 1;
                    break;
                case 'V':
                    res += 5;
                    break;
                case 'X':
                    if (i+1 < len && (chs[i+1] == 'L' || chs[i+1] == 'C')) res -= 10;
                    else res += 10;
                    break;
                case 'L':
                    res += 50;
                    break;
                case 'C':
                    if (i+1 < len && (chs[i+1] == 'D' || chs[i+1] == 'M')) res -= 100;
                    else res += 100;
                    break;
                case 'D':
                    res += 500;
                    break;
                case 'M':
                    res += 1000;
                    break;
                }
            }
            return res;
        }
    }
  #+end_src 
* 14 最长公共前缀                                                    :字符串:
** 扫描
   - 横向扫描
     #+begin_src java :classname 
       class Solution {
           public String longestCommonPrefix(String[] strs) {
               if (strs == null || strs.length == 0) return "";
               StringBuilder sb = new StringBuilder();
               sb.append(strs[0]);
               for (int i = 1; i < strs.length; i++) {
                   int len = Math.min(sb.length(), strs[i].length());
                   int j = 0;
                   for (; j < len; j++) {
                       if (sb.charAt(j) != strs[i].charAt(j)) break;
                   }
                   sb.delete(j, sb.length());
                   if (sb.length() == 0) return "";
               }
               return sb.toString();
           }
       }
     #+end_src
   - 纵向扫描
     #+begin_src java :classname 
       class Solution {
           public String longestCommonPrefix(String[] strs) {
               if (strs == null || strs.length == 0) return "";
               int len = Integer.MAX_VALUE;
               for (String str : strs) {
                   if (str.length() < len) len = str.length();
               }
               StringBuilder sb = new StringBuilder();
               for (int i = 0; i < len; i++) {
                   boolean isCommon = true;
                   sb.append(strs[0].charAt(i));
                   for (int j = 1; j < strs.length; j++) {
                       if (sb.charAt(i) != strs[j].charAt(i)) {
                           sb.deleteCharAt(i);
                           isCommon = false;
                           break;
                       }
                   }
                   if (!isCommon) break;
               }
               return sb.toString();
           }
       }
     #+end_src
** 字典树                                                        :UNRESOLVED:
   #+begin_src java :classname 
   #+end_src 
* 15 三数之和                                                :双指针:DP:数组:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> threeSum(int[] nums) {
            List<List<Integer>> lists= new ArrayList<>();
            if (nums == null || nums.length < 3) return lists;
            Arrays.sort(nums);
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] > 0) break;
                if (i > 0 && nums[i] == nums[i-1]) continue;
                int left = i + 1, right = nums.length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[left] + nums[right];
                    if (sum > 0)      right -= 1;
                    else if (sum < 0) left += 1;
                    else {
                        // List<Integer> list = new ArrayList<>();
                        // list.add(nums[i]);
                        // list.add(nums[left]);
                        // list.add(nums[right]);
                        // lists.add(list);
                        lists.add(Arrays.asList(nums[i], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left+1])   left += 1;
                        // while (left < right && nums[right] == nums[right-1]) right -= 1;
                        left += 1;
                        // right -= 1;
                    }
                }
            }
            return lists;
        }
    }
  #+end_src 
* 17 电话号码的字母组合                       :DFS:回溯:递归:排列组合:字符串:
  #+begin_src java :classname 
    class Solution {
        Map<Character, String> phone = new HashMap<Character, String>() {{
                put('2', "abc");
                put('3', "def");
                put('4', "ghi");
                put('5', "jkl");
                put('6', "mno");
                put('7', "pqrs");
                put('8', "tuv");
                put('9', "wxyz");
            }};
        List<String> combinations = new ArrayList<>();
        public List<String> letterCombinations(String digits) {
            if (digits == null || digits.length() <= 0) return combinations;
            combinationsHelper("", digits, 0);
            return combinations;
        }
        private void combinationsHelper(String combination, String digits, int pos) {
            if (pos == digits.length()) combinations.add(combination);
            else {
                String s = phone.get(digits.charAt(pos));
                for (int i = 0; i < s.length(); i++) {
                    combinationsHelper(combination+s.substring(i, i+1), digits, pos+1);
                }
            }
        }
    }
  #+end_src 
* 19 删除链表的倒数第N个节点                                    :双指针:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode removeNthFromEnd(ListNode head, int n) {
            ListNode pivot = new ListNode(0);
            pivot.next = head;
            ListNode prev = pivot, p = head, tail = head;
            for (int i = 0; i < n; i++) tail = tail.next;
            while (tail != null) {
                prev = prev.next;
                p = p.next;
                tail = tail.next;
            }
            prev.next = p.next;
            return pivot.next;
        }
    }
  #+end_src 
* 20 有效的括号                                            :辅助栈:栈:字符串:
  #+begin_src java :classname 
    class Solution {
        public boolean isValid(String s) {
            Stack<Character> stack = new Stack<>();
            for (int i = 0; i < s.length(); i++) {
                char ch = s.charAt(i);
                if (ch == '(' || ch == '[' || ch == '{') {
                    stack.push(ch);
                } else {
                    if (stack.empty()) return false;
                    switch (ch) {
                    case ')':
                        if (stack.peek() != '(') return false;
                        stack.pop();
                        break;
                    case ']':
                        if (stack.peek() != '[') return false;
                        stack.pop();
                        break;
                    case '}':
                        if (stack.peek() != '{') return false;
                        stack.pop();
                        break;
                    }
                }
            }
            return stack.empty();
        }
    }
  #+end_src 
* 21 合并有序链表                                                 :递归:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if (l1 == null) return l2;
            if (l2 == null) return l1;
            ListNode head = l1.val > l2.val ? l2 : l1;
            head.next = head == l1 ? mergeTwoLists(l1.next, l2) : mergeTwoLists(l1, l2.next);
            return head;
        }
    }
  #+end_src 
* 22 括号生成                              :DP:DFS:回溯:递归:排列组合:字符串:
** 回溯
   #+begin_src java :classname 
     class Solution {
         public List<String> generateParenthesis(int n) {
             List<String> list = new ArrayList<>();
             if (n != 0) dfs("", n, n, list);
             return list;
         }

         private void dfs(String s, int left, int right, List<String> list) {

             if (left == 0 && right == 0) {
                 list.add(s);
                 return;
             }

             if (left > right) return;
             if (left > 0) dfs(s+"(", left-1, right, list);
             if (right > 0) dfs(s+")", left, right-1, list);
         }
     }
   #+end_src 
** DP(闭合数)                                                    :UNRESOLVED:
* 23 合并K个排序链表                                             :UNRESOLVED:
* 26 删除排序数组中的重复项                                            :数组:
  #+begin_src java :classname 
    class Solution {
        public int removeDuplicates(int[] nums) {
            if (nums == null || nums.length == 0) return 0;
            int next = 1;
            for (int i = 1; i < nums.length; i++) {
                if (nums[i] != nums[next-1]) {
                    nums[next] = nums[i];
                    next++;
                }
            }
            return next;
        }
    }
  #+end_src 
* 28 实现strStr()                                                    :字符串:
  #+begin_src java :classname 
    class Solution {
        public int strStr(String haystack, String needle) {
            if (haystack == null || needle == null || haystack.length() < needle.length()) return -1;
            if (needle.length() == 0) return 0;
            for (int i = 0; i <= haystack.length()-needle.length(); i++) {
                if (haystack.charAt(i) != needle.charAt(0)) continue;
                if (haystack.substring(i, i+needle.length()).equals(needle)) return i;
            }
            return -1;
        }
    }
  #+end_src 
* 29 两数相除                                          :溢出:位运算:数值计算:
** 逐次相减(超时)
   #+begin_src java :classname 
     class Solution {
         public int divide(int dividend, int divisor) {
             if (dividend == 0) return 0;
             boolean neg = (dividend ^ divisor) < 0;
             long dividendL = Math.abs((long)dividend);
             long divisorL = Math.abs((long)divisor);
             long res = 0;
             dividendL -= divisorL;
             while (dividendL >= 0) {
                 res = neg ? res-1 : res+1;
                 dividendL -= divisorL;
                 if (res < Integer.MIN_VALUE) return Integer.MIN_VALUE;
                 if (res > Integer.MAX_VALUE) return Integer.MAX_VALUE;
             }
             return (int)res;
         }
     }
   #+end_src 
** 位运算                                                        :UNRESOLVED:
   - 借用 ~long~ 
     #+begin_src java :classname 
       class Solution {
           public int divide(int dividend, int divisor) {
               if (dividend == 0) return 0;
               if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
               boolean neg = (dividend ^ divisor) < 0;
               // boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);
               long dividendL = Math.abs((long)dividend);
               long divisorL = Math.abs((long)divisor);
               long res = 0;
               for (int i = 31; i >= 0; i--) {
                   if ((dividendL>>i) >= divisorL) {
                       res = neg ? res-(1<<i) : res+(1<<i);
                       if ((int)res >= Integer.MAX_VALUE) return Integer.MAX_VALUE;
                       if ((int)res <= Integer.MIN_VALUE) return Integer.MIN_VALUE;
                       dividendL -= divisorL<<i;
                   }
               }
               return (int)res;
           }
       }
     #+end_src
   - 不用 ~long~, 转化为负数考虑
     #+begin_src java :classname 
       class Solution {
           public int divide(int dividend, int divisor) {
               boolean sign = (dividend > 0) ^ (divisor > 0);
               int result = 0;
               if(dividend>0) {
                   dividend = -dividend;
               }
               if(divisor>0) divisor = -divisor;
               while(dividend <= divisor) {
                   int temp_result = -1;
                   int temp_divisor = divisor;
                   while(dividend <= (temp_divisor << 1)) {
                       if(temp_divisor <= (Integer.MIN_VALUE >> 1))break;
                       temp_result = temp_result << 1;
                       temp_divisor = temp_divisor << 1;
                   }
                   dividend = dividend - temp_divisor;
                   result += temp_result;
               }
               if(!sign) {
                   if(result <= Integer.MIN_VALUE) return Integer.MAX_VALUE;
                   result = - result;
               }
               return result;
           }
       }
     #+end_src 
* 31 下一个排列                                          :排序:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        public void nextPermutation(int[] nums) {
            int i = nums.length - 2;
            while (i >= 0 && nums[i] >= nums[i+1]) i -= 1;
            if (i >= 0) {
                for (int j = nums.length-1; j >= i+1; j--) {
                    if (nums[j] > nums[i]) {
                        swap(nums, i, j);
                        break;
                    }
                }
            }
            reverse(nums, i+1);
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }

        private void reverse(int[] nums, int start) {
            int end = nums.length - 1;
            while (start < end) {
                swap(nums, start, end);
                start += 1;
                end -= 1;
            }
        }
    }
  #+end_src 
* 32 最长有效括号                                                :UNRESOLVED:
* 33 搜索旋转排序数组 [[file:~/csnds/Dropbox/orglife/offer.org::<<ilink15>>][offer11]]                            :二分查找:查找:数组:
  #+begin_src java :classname 
    class Solution {
        public int search(int[] nums, int target) {
            if (nums == null || nums.length <= 0) return -1;
            int start = 0, end = nums.length - 1;
            if (nums[start] > nums[end]) {
                while (start < end) {
                    int mid = (start+end) >> 1;
                    if (nums[mid] > nums[end]) start = mid + 1;
                    else {
                        if (mid == 0 || nums[mid] < nums[mid-1]) {
                            end = nums.length - 1;
                            start = mid;
                            break;
                        }
                        end = mid;
                    }
                }
            }
            if (target > nums[end]) {
                end = start - 1;
                start = 0;
            }
            while (start < end) {
                int mid = (start+end) >> 1;
                if (nums[mid] == target) return mid;
                if (nums[mid] < target) start = mid + 1;
                else end = mid;
            }
            return nums[start] == target ? start : -1;
        }
    }
  #+end_src 
* 34 在排序数组中查找元素的第一个和最后一个位置 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink10>>][offer53]]  :二分查找:查找:数组:
  #+begin_src java :classname 
    class Solution {
        public int[] searchRange(int[] nums, int target) {
            if (nums == null || nums.length <= 0) return new int[] {-1, -1};
            int start = 0, end = nums.length - 1, mid = (start+end) >> 1;
            while (start < end) {
                if (nums[mid] == target) break;
                if (nums[mid] > target) end = mid;
                else start = mid + 1;
                mid = (start+end) >> 1;
            }
            if (nums[mid] != target) return new int[] {-1, -1};
            int[] res = new int[2];
            start = 0; end = mid;
            int left = (start+end) >> 1;
            while (start < end) {
                if (nums[left] < target) start = left + 1;
                else {
                    if (left == start || nums[left-1] != target) break;
                    end = left;
                }
                left = (start+end) >> 1;
            }
            res[0] = left;
            start = mid; end = nums.length - 1;
            int right = (start+end) >> 1;
            while (start < end) {
                if (nums[right] > target) end = right;
                else {
                    if (right == end || nums[right+1] != target) break;
                    start = right + 1;
                }
                right = (start+end) >> 1;
            }
            res[1] = right;
            return res;
        }
    }
  #+end_src 
* 36 有效的数独                                        :位运算:二维数组:数组:
** 借用 ~Set~ 逐行逐列逐块
   #+begin_src java :classname 
     class Solution {
         public boolean isValidSudoku(char[][] board) {
             for (int i = 0; i < 9; i++) {
                 if (!isValidRnC(board, i)) return false;
                 if (i%3 == 0) {
                     for (int j = 0; j < 9; j+=3) {
                         if (!isValidBlock(board, i, j)) return false;
                     }
                 }
             }
             return true;
         }

         private boolean isValidRnC(char[][] board, int i) {
             Set<Character> rowSet = new HashSet();
             Set<Character> colSet = new HashSet();
             for (int j = 0; j < 9; j++) {
                 if (board[i][j] != '.') {
                     if (rowSet.contains(board[i][j])) return false;
                     rowSet.add(board[i][j]);
                 }
                 if (board[j][i] != '.') {
                     if (colSet.contains(board[j][i])) return false;
                     colSet.add(board[j][i]);
                 }
             }
             return true;
         }

         private boolean isValidBlock(char[][] board, int i, int j) {
             Set<Character> blockSet = new HashSet();
             for (int row = i; row < i+3; row++) {
                 for (int col = j; col < j+3; col++) {
                     if (board[row][col] != '.') {
                         if (blockSet.contains(board[row][col])) return false;
                         blockSet.add(board[row][col]);
                     }
                 }
             }
             return true;
         }
     }
   #+end_src
** 逐个字符判断所在行所在列所在块
   - 直接判断
     #+begin_src java :classname 
       class Solution {
           public boolean isValidSudoku(char[][] board) {
               if(board == null || board.length <= 1){
                   return false;
               }
               for(int i = 0;i < board.length;i++){
                   for(int j = 0;j < board[0].length;j++){
                       if(board[i][j] != '.'){
                           if(!isValidHelp(board, board[i][j], i, j)){
                               return false;
                           }
                       }
                   }
               }
               return true;
           }


           public boolean isValidHelp(char[][] board,char c,int row,int column){
            
               if(board == null) return false;
            
               for(int i = 0;i < row;i++){
                   if(board[i][column] == c && i != row){
                       return false;
                   }
               }
               for(int i = 0;i < column;i++){
                   if(board[row][i] == c && i != column){
                       return false;
                   }
               }
        
               int n = row/3;
               int m = column/3;

               for(int i = n * 3;i < n * 3 + 3;i++){
                   for(int j = m * 3;j < m * 3 + 3;j++){
                       if(board[i][j] == c ){
                           if(i != row && j != column){
                               return false;
                           }
                       }
                   }
               }
               return true;
           }
       }
     #+end_src
   - 存储辅助判断
     #+begin_src java :classname 
         class Solution {
             public boolean isValidSudoku(char[][] board) {
                 boolean[][] row = new boolean[9][9];
                 boolean[][] col = new boolean[9][9];
                 boolean[][] block = new boolean[9][9];
                 for (int i = 0; i < 9; i++) {
                     for (int j = 0; j < 9; j++) {
                         if (board[i][j] != '.') {
                             int num = board[i][j] - '1';
                             int blockIndex = i / 3 * 3 + j / 3;
                             if (row[i][num] || col[j][num] || block[blockIndex][num]) {
                                 return false;
                             } else {
                                 row[i][num] = true;
                                 col[j][num] = true;
                                 block[blockIndex][num] = true;
                             }
                         }
                     }
                 }
                 return true;
             }

             public boolean isValidSudoku(char[][] board) {
                 int[] rows = new int[9];
                 int[] columns = new int[9];
                 int[] boxes = new int[9];
                 for (int row = 0; row < 9; row++) {
                     for (int column = 0; column < 9; column++) {
                         char c = board[row][column];
                         if (c == '.') {
                             continue;
                         }
                         int val = 1 << c - '1';
                         int i = row/3*3 + column/3;
                         if (((rows[row] | columns[column] | boxes[i]) & val) > 0) {
                             return false;
                         }
                         rows[row] |= val;
                         columns[column] |= val;
                         boxes[i] |= val;
                     }
                 }
                 return true;
             }
         }
       #+end_src
* 37 解数独                                                      :UNRESOLVED:
* 38 外观数列                                                   :递归:字符串:
  #+begin_src java :classname 
    class Solution {
        public String countAndSay(int n) {
            if (n == 1) return "1";
            return describeHelper(countAndSay(n-1).toCharArray());
        }

        private String describeHelper(char[] chs) {
            StringBuilder sb = new StringBuilder();
            char cur = chs[0]
            int count = 0;
            for (char ch : chs) {
                if (ch != cur) {
                    sb.append(count);
                    sb.append(cur);
                    cur = ch;
                    count = 1;
                } else {
                    count += 1;
                }
            }
            sb.append(count);
            sb.append(cur);
            return sb.toString();
        }
    }
  #+end_src 
* 39 组合总数                                   :DFS:回溯:递归:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        private List<List<Integer>> res = new ArrayList<>();
        private List<Integer> path = new ArrayList<>();
        public List<List<Integer>> combinationSum(int[] candidates, int target) {
            if (candidates == null || candidates.length <= 0) return res;
            Arrays.sort(candidates);
            combinationHelper(candidates, 0, target);
            return res;
        }

        private void combinationHelper(int[] candidates, int start, int target) {
            if (target == 0) {
                res.add(new ArraysList<Integer>(path));
                return;
            }
            for (int i = start; i < candidates.length; i++) {
                if (candidates[i] > target) break;
                path.add(candidates[i]);
                combinationHelper(candidates, i, target-candidates[i]);
                path.remove(path.size()-1);
            }
        }
    }
  #+end_src 
* 41 缺失的第一个正数                                            :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int firstMissingPositive(int[] nums) {

        }
    }
  #+end_src 
* 42 接雨水                                                      :UNRESOLVED:
* 44 通配符匹配                                                  :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public boolean isMatch(String s, String p) {

        }
    }
  #+end_src 
* 46 全排列                                     :DFS:回溯:递归:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new ArrayList<>();
            if (nums == null || nums.length <= 0) return res;
            permuteHelper(nums, nums.length, 0, res);
            return res;
        }

        private void permuteHelper(int[] nums, int len, int pos, List<List<Integer>> res) {
            if (pos == len-1) {
                List<Integer> arr = new ArrayList<>();
                for (int i : nums) arr.add(i);
                res.add(arr);
                return;
            }
            for (int i = pos; i < len; i++) {
                swap(nums, pos, i);
                permuteHelper(nums, len, pos+1, res);
                swap(nums, pos, i);
            }
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
  #+end_src 
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new ArrayList<>();
            if (nums == null || nums.length <= 0) return res;
            List<Integer> arr = new ArrayList<>();
            for (int i : nums) arr.add(i);
            permuteHelper(arr, nums.length, 0, res);
            return res;
        }

        private void permuteHelper(List<Integer> arr, int len, int pos, List<List<Integer>> res) {
            if (pos == len-1) {
                res.add(new ArrayList<Integer>(arr));
                return;
            }
            for (int i = pos; i < len; i++) {
                Collections.swap(arr, pos, i);
                permuteHelper(arr, len, pos+1, res);
                Collections.swap(arr, pos, i);
            }
        }
    }
  #+end_src 
* 48 旋转图像                                                 :二维数组:数组:
** 旋转4个矩形(直接规律)
   #+begin_src java :classname 
     class Solution {
         public void rotate(int[][] matrix) {
             if (matrix == null || matrix.length <= 0 || matrix[0].length <= 0) return;
             int len = matrix.length, cir = len / 2;
             for (int i = 0; i < cir; i++) {
                 int endi = len - i - 1;
                 for (int j = i; j < endi; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[endi+i-j][i];
                     matrix[endi+i-j][i] = matrix[endi][endi+i-j];
                     matrix[endi][endi+i-j] = matrix[j][endi];
                     matrix[j][endi] = temp;
                 }
             }
         }
      }
   #+end_src 
** 转置+翻转(间接规律)
   #+begin_src java :classname 
     class Solution {
         public void rotate(int[][] matrix) {
             if (matrix == null || matrix.length <= 0 || matrix[0].length <= 0) return;
             int len = matrix.length;
             for (int i = 0; i < len; i++) {
                 for (int j = 0; j < i; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[j][i];
                     matrix[j][i] = temp;
                 }
             }
             for (int i = 0; i < len; i++) {
                 for (int j = 0; j < len/2; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[i][len-1-j];
                     matrix[i][len-1-j] = temp;
                 }
             }
         }
     }
   #+end_src 
   - 顺时针 -> 转置+按行翻转
   - 逆时针 -> 转置+按列翻转
* 49 字母异位词分组                              :排序:映射:数组:字符:字符串:
** 暴力
   #+begin_src java :classname 
     class Solution {
         public List<List<String>> groupAnagrams(String[] strs) {
             List<List<String>> res = new ArrayList<>();
             if (strs == null || strs.length <= 0) return res;
             boolean[] added = new boolean[strs.length];
             for (int i = 0; i < strs.length; i++) {
                 List<String> list = new ArrayList<>();
                 if (added[i]) continue;
                 list.add(strs[i]);
                 added[i] = true;
                 for (int j = i+1; j < strs.length; j++) {
                     if (added[j]) continue;
                     if (strs[i].length() == strs[j].length()) {
                         if (strs[i].equals(strs[j]) || isAnagram(strs[i], strs[j])) {
                             list.add(strs[j]);
                             added[j] = true;
                         }
                     }
                 }
                 if (!list.isEmpty()) res.add(list);
             }
             return res;
         }

         private boolean isAnagram(String s1, String s2) {
             int[] set = new int[26];
             for (int i = 0; i < s1.length(); i++) set[s1.charAt(i)-'a'] += 1;
             for (int i = 0; i < s2.length(); i++) set[s2.charAt(i)-'a'] -= 1;
             for (int i = 0; i < 26; i++) if(set[i] != 0) return false;
             return true;
         }
     }
   #+end_src 
** 排序+映射
   #+begin_src java :classname 
     class Solution {
         public List<List<String>> groupAnagrams(String[] strs) {
             List<List<String>> res = new ArrayList<>();
             if (strs == null || strs.length <= 0) return res;
             Map<String, List<String>> map = new HashMap<>();
             for (String s : strs) {
                 char[] chs = s.toCharArray();
                 Arrays.sort(chs);
                 // String key = String.valueOf(chs);
                 String key = new String(chs); // 更快
                 if (!map.containsKey(key)) map.put(key, new ArrayList<String>());
                 map.get(key).add(s);
             }
             // return new ArrayList<>(map.values());
             res.addAll(map.values());
             return res;
         }
     }
   #+end_src 
* 50 Pow(x, n)                                  :溢出:递归:数值规律:数值计算:
** 暴力
   #+begin_src java :classname 
     public class Solution {
         public double myPow(double base, int exponent) {
             if (base == 0) return 0.0;
             if (exponent == 0) return 1;
             if (Math.abs(base) == 1) {
                 if (base > 0 || (exponent&1) == 0) return 1;
                 else return -1;
             }
             if (exponent == Integer.MIN_VALUE) {
                 if (Math.abs(base) >= 1) return 0.0;
                 else return Integer.MAX_VALUE;
             }
             if (exponent < 0) {
                 exponent = 0 - exponent;
                 base = 1 / base;
             }
             double result = base;
             while (exponent > 1) {
                 result *= base;
                 exponent -= 1;
             }
             return result;
         }
     }
   #+end_src 
** 快速幂
*** 递归
   #+begin_src java :classname 
     public class Solution {
         public double myPow(double base, int exponent) {
             return myPow(base, (long)exponent);
         }

         private double myPow(double base, long exponent) {
             if (exponent == 0) return 1;
             if (exponent > 0) return (exponent&1) == 1 ? base*myPow(base, exponent-1) : myPow(base*base, exponent>>1);
             return 1 / myPow(base, -exponent);
         }
     }
   #+end_src 
*** 迭代
   #+begin_src java :classname 
     public class Solution {
         public double myPow(double base, int exponent) {
             double res = 1.0;
             boolean neg = exponent < 0;
             while (exponent != 0) {
                 if ((exponent&1) == 1) res *= jbase;
                 base *= base;
                 exponent /= 2;
             }
             return neg ? 1/res : res;
         }
     }
   #+end_src 
* 53 最大子序和                                                     :DP:数组:
  #+begin_src java :classname 
    class Solution {
        public int maxSubArray(int[] nums) {
            int maxSum = Integer.MIN_VALUE, curSum = 0;
            if (nums == null || nums.length <= 0) return max;
            for (int i = 0; i < nums; i++) {
                curSum += nums[i];
                if (maxSum < curSum) maxSum = curSum;
                if (curSum < 0) curSum = 0;
            }
            return maxSum;
        }
    }
  #+end_src 
* 54 螺旋矩阵 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink29>>][offer29]]                                         :二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public List<Integer> spiralOrder(int[][] matrix) {
            List<Integer> res = new LinkedList<>();
            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;
            int up = 0, down = matrix.length-1;
            int left = 0, right = matrix[0].length-1;
            while (up <= down && left <= right) {
                for (int col = left; col <= right; col++) res.add(matrix[up][col]);
                up++;
                for (int row = up; row <= down; row++) res.add(matrix[row][right]);
                right--;
                if (up > down) break;
                for (int col = right; col >= left; col--) res.add(matrix[down][col]);
                down--;
                if (left > right) break;
                for (int row = down; row >= up; row--) res.add(matrix[row][left]);
                left++;
            }
            return res;
        }
    }
  #+end_src 
* 55 跳跃游戏                                        :DP:贪心:回溯:递归:数组:
** 递归(回溯)
   #+begin_src java :classname 
     class Solution {
         public boolean canJump(int[] nums) {
             if (nums == null || nums.length <= 0) return false;
             return canJumpHelper(nums, 0, nums.length-1);
         }

         private boolean canJumpHelper(int[] nums, int pos, int end) {
             if (pos == end) return true;
             for (int i = 1; i <= nums[pos]; i++) {
                 if (pos+i > end) return false;
                 if (canJumpHelper(nums, pos+i, end)) return true;
             }
             return false;
         }
     }
   #+end_src 
** DP                                                            :UNRESOLVED:
** 贪心
   #+begin_src java :classname 
     class Solution {
         public boolean canJump(int[] nums) {
             if (nums == null || nums.length <= 0) return false;
             int lastPos = nums.length - 1;
             for (int i = nums.length-2; i >= 0; i--) {
                 if (i + nums[i] >= lastPos) lastPos = i;
             }
             return lastPos == 0;
         }
     }
   #+end_src 
* 56 合并区间                                            :排序:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int[][] merge(int[][] intervals) {
            if (intervals == null || intervals.length <= 0 || intervals[0].length <= 0) return new int[][] {}; // new int[0][];

            // Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

            // Comparator<int[]> intervalComparator = (int[] interval1, int[] interval2) -> {
            //     return interval1[0] - interval2[0];
            // };
            // Arrays.sort(intervals, intervalComparator);

            Arrays.sort(intervals, new Comparator<int[]>() {
                    @Override
                    public int compare(int[] interval1, int[] interval2) {
                        return Integer.compare(interval1[0], interval2[0]);
                        // return interval1[0] - interval2[0];
                    }
                });
            List<int[]> res = new ArrayList<>();
            for (int i = 0; i < intervals.length; i++) {
                int start = intervals[i][0];
                int end = intervals[i][1];
                int j = i + 1;
                for (; j < intervals.length; j++) {
                    if (intervals[j][0] > end) break;
                    if (intervals[j][1] > end) end = intervals[j][1];
                }
                res.add(new int[]{start, end});
                i = j - 1;
            }

            return res.toArray(new int[res.size()][]);

            // int[][] combineIntervals = new int[res.size()][];
            // for (int i = 0; i < res.size(); i++) {
            //     combineIntervals[i] = res.get(i);
            // }
            // return combineIntervals;
        }
    }
  #+end_src 
* 62 不同路径                                              :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int uniquePaths(int m, int n) {
            int[][] paths = new int[m][n];
            for (int i = 0; i < m; i++) paths[i][0] = 1;
            for (int i = 1; i < n; i++) paths[0][i] = 1;
            for (int i = 1; i < m; i++) {
                for (int j = 1; j < n; j++) paths[i][j] = paths[i-1][j] + paths[i][j-1];
            }
            return paths[m-1][n-1];
        }
    }
  #+end_src 
* 64 最小路径和                                            :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int minPathSum(int[][] grid) {
            if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
            int rows = grid.length, cols = grid[0].length;
            for (int row = 1; row < rows; row++) grid[row][0] += grid[row-1][0];
            for (int col = 1; col < cols; col++) grid[0][col] += grid[0][col-1];
            for (int row = 1; row < rows; row++) {
                for (int col = 1; col < cols; col++) grid[row][col] += Math.min(grid[row-1][col], grid[row][col-1]);
            }
            return grid[rows-1][cols-1];
        }
    }
  #+end_src 
* 66 加一                                                              :数组:
  #+begin_src java :classname 
    class Solution {
        public int[] plusOne(int[] digits) {
            int[] res = new int[digits.length+1];
            int carry = 1;
            for (int i = digits.length-1; i >= 0; i--) {
                carry += digits[i];
                res[i+1] = carry % 10;
                carry /= 10;
            }
            if (carry != 0) res[0] = carry;
            return res[0] != 0 ? res : Arrays.copyOfRange(res, 1, res.length);
        }
    }
  #+end_src 
* 69 x的平方根                                            :数值规律:数值计算:
** 暴力
   #+begin_src java :classname 
     class Solution {
         public int mySqrt(int x) {
             if (x <= 1) return x;
             int res = 1;
             // 防止res*res溢出
             while (res <= x/res) res += 1;
             return res-1;
         }
     }
   #+end_src 
** 袖珍计算器算法
   #+begin_src java :classname 
     class Solution {
         public int mySqrt(int x) {
             if (x <= 1) return x;
             int res = (int)Math.exp(0.5 * Math.log(x));
             return (long)(res+1) * (res+1) <= x ? res+1 : res;
         }
     }
   #+end_src 
** 二分法
   #+begin_src java :classname 
     class Solution {
         public int mySqrt(int x) {
             if (x <= 1) return x;
             int left = 1, right = (x>>1) + 1, mid = (left+right) >> 1;
             while (left < right) {
                 if (mid < x/mid) left = mid + 1;
                 else if (mid > x/mid) right = mid;
                 else return mid;
                 mid = (left+right) >> 1;
             }
             return left > x/left ? left-1 : left;
         }
     }
   #+end_src 
** 牛顿迭代法
   #+begin_src java :classname 
     class Solution {
         public int mySqrt(int x) {
             if (x <= 1) return x;
             double res = (double)x;
             while (true) {
                 double next = (res+x/res)*0.5;
                 if (Math.abs(res-next) < 1e-7) break;
                 res = next;
             }
             return (int)res;
         }
     }
   #+end_src 
* 70 爬楼梯                                                              :DP:
** DP
   #+begin_src java :classname 
     class Solution {
         public int climbStairs(int n) {
             int a1 = 1, a2 = 1;
             while (n > 1) {
                 int a3 = a1 + a2;
                 a1 = a2;
                 a2 = a3;
                 n -= 1;
             }
             return a2;
         }
     }
   #+end_src 
** Binets法                                                      :UNRESOLVED:
** 斐波那契公式                                                  :UNRESOLVED:
* 72 编辑距离                                                    :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int minDistance(String word1, String word2) {

        }
    }
  #+end_src 
* 73 矩阵置零                                                 :二维数组:数组:
** 先遍历再置零
*** 暴力
    #+begin_src java :classname 
      class Solution {
          public void setZeroes(int[][] matrix) {
              Set<Integer> rows = new HashSet<>();
              Set<Integer> cols = new HashSet<>();

              for (int row = 0; row < matrix.length; row++) {
                  for (int col = 0; col < matrix[0].length; col++) {
                      if (matrix[row][col] == 0) {
                          rows.add(row);
                          cols.add(col);
                      }
                  }
              }

              for (int row : rows) {
                  for (int col = 0; col < matrix[0].length; col++) {
                      matrix[row][col] = 0;
                  }
              }

              for (int col : cols) {
                  for (int row = 0; row < matrix.length; row++) {
                      matrix[row][col] = 0;
                  }
              }
          }
      }
    #+end_src 
*** 本地记录信息
    - 利用第一行和第一列
      #+begin_src java :classname 
        class Solution {
            public void setZeroes(int[][] matrix) {
                boolean row0_flag = false, col0_flag = false;
                int rows = matrix.length, cols = matrix[0].length;
                for (int row = 0; row < rows; row++) {
                    if (matrix[row][0] == 0) {
                        col0_flag = true;
                        break;
                    }
                }

                for (int col = 0; col < cols; col++) {
                    if (matrix[0][col] == 0) {
                        row0_flag = true;
                        break;
                    }
                }

                for (int row = 1; row < rows; row++) {
                    for (int col = 1; col < cols; col++) {
                        if (matrix[row][col] == 0) {
                            matrix[row][0] = matrix[0][col] = 0;
                        }
                    }
                }

                for (int row = 1; row < rows; row++) {
                    for (int col = 1; col < cols; col++) {
                        if (matrix[row][0] == 0 || matrix[0][col] == 0) matrix[row][col] = 0;
                    }
                }

                if (row0_flag) {
                    for (int col = 0; col < cols; col++) {
                        matrix[0][col] = 0;
                    }
                }

                if (col0_flag) {
                    for (int row = 0; row < rows; row++) {
                        matrix[row][0] = 0;
                    }
                }
            }
        }
      #+end_src
    - 简化-仅利用第一列
      #+begin_src java :classname 
        class Solution {
            public void setZeroes(int[][] matrix) {
                boolean col0_flag = false;
                int rows = matrix.length, cols = matrix[0].length;
                for (int row = 0; row < rows; row++) {
                    if (matrix[row][0] == 0) col0_flag = true;
                    for (int col = 1; col < cols; col++) {
                        if (matrix[row][col] == 0) {
                            matrix[row][0] = matrix[0][col] = 0;
                        }
                    }
                }

                for (int row = rows-1; row >= 0; row--) {
                    for (int col = cols-1; col >= 1; col--) {
                        if (matrix[row][0] == 0 || matrix[0][col] == 0) matrix[row][col] = 0;
                    }
                    if (col0_flag) matrix[row][0] = 0;
                }
            }
        }
      #+end_src
** 边遍历边置零                                                  :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public void setZeroes(int[][] matrix) {
             if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
                 return;
             }
             // 前一行为0标志
             boolean isLastRowZero = false;
             for (int i = 0; i < matrix.length; i ++) {
                 // 当前行为0标志
                 boolean isCurrRowZero = false;
                 for (int j = 0; j < matrix[0].length; j ++) {
                     if (matrix[i][j] == 0) {
                         isCurrRowZero = true;
                         // 纵向上一个值不是零，说明纵向第一次出现零，需要把纵向前面的值都置为零
                         if (i > 0 && matrix[i - 1][j] != 0) {
                             for (int k = 0; k < i; k ++) {
                                 matrix[k][j] = 0;
                             }
                         }
                     }
                     // 纵向上一个值如果为零，则把纵向的零延伸到此行
                     else if (i > 0 && matrix[i - 1][j] == 0){
                         matrix[i][j] = 0;
                     }
                
                     // 如果上一行为零标志为真,则上一行这个位置置为零（纵向为零的判断在上面处理过，所以到这里才可以设置为0）
                     if (isLastRowZero) {
                         matrix[i - 1][j] = 0;
                     }
                 }
                 isLastRowZero = isCurrRowZero;
             }

             // 处理最后一行为零的情况
             if (isLastRowZero) {
                 for (int i = 0; i < matrix[0].length; i ++) {
                     matrix[matrix.length - 1][i] = 0;
                 }
             }
         }
     }
   #+end_src 
* 75 颜色分类                                         :三指针:快排:排序:数组:
** 三路快排 [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink19>>][Hoare Partition]] <<ilink1>>
   #+begin_src java :classname 
     class Solution {
         public void sortColors(int[] nums) {
             int next0 = 0, next2 = nums.length - 1;
             while (next0 < nums.length && nums[next0] == 0) next0 += 1;
             while (next2 >= 0 && nums[next2] == 2) next2 -= 1;
             int cur = next0;
             while (cur <= next2) {
                 switch (nums[cur]) {
                 case 0:
                     swap(nums, cur, next0);
                     while (next0 < nums.length && nums[next0] == 0) next0 += 1;
                     cur = next0;
                     break;
                 case 2:
                     swap(nums, cur, next2);
                     while (next2 >= 0 && nums[next2] == 2) next2 -= 1;
                     break;
                 case 1:
                     cur += 1;
                     break;
                 }
             }
         }

         private void swap(int[] nums, int i, int j) {
             int temp = nums[i];
             nums[i] = nums[j];
             nums[j] = temp;
         }
     }
   #+end_src 
* 76 最小覆盖子串                                                :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public String minWindow(String s, String t) {

        }
    }
  #+end_src 
* 78 子集                                                    :回溯:递归:数组:
** 迭代
   #+begin_src java :classname 
     class Solution {
         public List<List<Integer>> subsets(int[] nums) {
             List<List<Integer>> res = new ArrayList<>();
             if (nums == null || nums.length <= 0) return res;
             res.add(new ArrayList<Integer>());
             for (int i = 0; i < nums.length; i++) {
                 int news = res.size();
                 for (int j = 0; j < news; j++) {
                     List<Integer> newSubSet = new ArrayList<>(res.get(j));
                     newSubSet.add(nums[i]);
                     res.add(newSubSet);
                 }
             }
             return res;
         }
     }
   #+end_src 
** 回溯
   #+begin_src java :classname 
     class Solution {
         public List<List<Integer>> subsets(int[] nums) {
             List<List<Integer>> res = new ArrayList<>();
             if (nums == null || nums.length <= 0) return res;
             backtrack(res, nums, 0, nums.length, new ArrayList<Integer>());
             return res;
         }

         private void backtrack(List<List<Integer>> res, int[] nums, int start, int len, ArrayList<Integer> newSubSet) {
             res.add(new ArrayList<>(newSubSet));
             for (int i = start; i < len; i++) {
                 newSubSet.add(nums[i]);
                 backtrack(res, nums, i+1, len, newSubSet);
                 newSubSet.remove(newSubSet.size()-1);
             }
         }
     }
   #+end_src 
** 字典排序(二进制排序)                                          :UNRESOLVED:
* 79 单词搜索 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink20>>][offer12]]                             :DFS:回溯:递归:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public boolean exist(char[][] board, String word) {
            if (board == null || board.length <= 0 || board[0].length <= 0) return false;
            int rows = board.length, cols = board[0].length;
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    boolean[][] visited = new boolean[rows][cols];
                    if (existHelper(board, word, i, rows, j, cols, 0, visited)) return true;
                }
            }
            return false;
        }

        private boolean existHelper(char[][] board, String word, int row, int rows, int col, int cols, int pos, boolean[][] visited) {
            if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
            if (visited[row][col] || board[row][col] != word.charAt(pos)) return false;
            if (pos == word.length()-1) return true;
            visited[row][col] = true;
            pos += 1;
            if (existHelper(board, word, row-1, rows, col, cols, pos, visited) ||
                existHelper(board, word, row+1, rows, col, cols, pos, visited) ||
                existHelper(board, word, row, rows, col-1, cols, pos, visited) ||
                existHelper(board, word, row, rows, col+1, cols, pos, visited)) return true;
            visited[row][col] = false;
            return false;
        }
    }
  #+end_src 
* 84 柱状图中最大的矩形                                          :UNRESOLVED:
  #+begin_src java :classname 
  #+end_src 
* 85 最大矩形                                                    :UNRESOLVED:
* 88 合并两个有序数组                                             :排序:数组:
  #+begin_src java :classname 
    class Solution {
        public void merge(int[] nums1, int m, int[] nums2, int n) {
            int i = m-1, j = n-1;
            for (int k = m+n-1; k >= 0; k--) {
                if (j < 0) nums1[k] = nums1[i--];
                else if (i < 0) nums1[k] = nums2[j--];
                else if (nums1[i] < nums2[j]) nums1[k] = nums2[j--];
                else nums1[k] = nums1[i--];
            }
        }
    }
  #+end_src 
* 91 解码方法 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink30>>][offer46]]                                             :DP:字符串:
  #+begin_src java :classname 
    class Solution {
        public int numDecodings(String s) {
            int len = s.length();
            int[] dp = new int[len+1];
            dp[0] = 1;
            dp[1] = s.charAt(0) != '0' ? 1 : 0;
            for (int i = 1; i < len; i++) {
                char ch1 = s.charAt(i-1), ch2 = s.charAt(i);
                int subint = (ch1-'0')*10 + (ch2-'0');
                if (ch2 != '0') dp[i+1] = dp[i];
                if (ch1 != '0' && subint <= 26) dp[i+1] += dp[i-1];
            }
            return dp[len];
        }
    }
  #+end_src 
* 94 二叉树的中序遍历                           :DFS:递归:中序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> order = new ArrayList<>();
            inorderHelper(root, order);
            return order;
        }

        private void inorderHelper(TreeNode root, List<Integer> order) {
            if (root == null) return;
            inorderHelper(root.left, order);
            order.add(root.val);
            inorderHelper(root.right, order);
        }
    }
  #+end_src 
* 96 不同的二叉搜索树                          :DP:递归:二叉搜索树:二叉树:树:
** 递归
   #+begin_src java :classname 
     class Solution {
         public int numTrees(int n) {
             if (n <= 1) return n;
             return numHelper(1, n);
         }

         private int numHelper(int start, int end) {
             if (start >= end) return 1;
             int num = 0;
             for (int i = start; i <= end; i++) {
                 int left = numHelper(start, i - 1);
                 int right = numHelper(i+1, end);
                 num += left * right;
             }
             return num;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         public int numTrees(int n) {
             int[] res = new int[n+1];
             res[0] = 1;
             for (int i = 1; i <= n; i++) {
                 for (int j = 1; j <= i; j++) {
                     res[i] += res[j-1]*res[i-j];
                 }
             }
             return res[n];
         }
     }
   #+end_src 
** 数学演绎法                                                    :UNRESOLVED:
* 97 验证二叉搜索树                               :递归:二叉搜索树:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public boolean isValidBST(TreeNode root) {
            if (root == null) return true;
            boolean isBST = true;
            if (root.left != null) isBST = isBST && maxVal(root.left) < root.val && isValidBST(root.left);
            if (root.right != null) isBST = isBST && minVal(root.right) > root.val && isValidBST(root.right);
            return isBST;
        }

        private int maxVal(TreeNode root) {
            while (root.right != null) root = root.right;
            return root.val;
        }

        private int minVal(TreeNode root) {
            while (root.left != null) root = root.left;
            return root.val;
        }
    }
  #+end_src 
* 101 对称二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink11>>][offer28]]                                     :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public boolean isSymmetric(TreeNode root) {
            if (root == null) return true;
            return isSymmetricHelper(root.left, root.right);
        }

        private boolean isSymmetricHelper(TreeNode n1, TreeNode n2) {
            if (n1 == null && n2 == null) return true;
            if (n1 == null || n2 == null) return false;
            return n1.val == n2.val && isSymmetricHelper(n1.left, n2.right) && isSymmetricHelper(n1.right, n2.left);
        }
    }
  #+end_src 
* 102 二叉树的层序遍历                               :BFS:层序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();
            if (root == null) return res;
            Queue<TreeNode> que = new LinkedList<>();
            que.offer(root);
            while (!que.isEmpty()) {
                int len = que.size();
                List<Integer> list = new ArrayList<>();
                for (int i = 0; i < len; i++) {
                    TreeNode poll = que.poll();
                    list.add(poll.val);
                    if (poll.left != null) que.offer(poll.left);
                    if (poll.right != null) que.offer(poll.right);
                }
                res.add(list);
            }
            return res;
        }
    }
  #+end_src 
* 103 二叉树的锯齿形层次遍历 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink31>>][offer32]]                 :BFS:层序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
            List<List<Integer>> res = new LinkedList<>();
            if (root == null) return res;
            boolean l2r = true;
            Deque<TreeNode> dq = new LinkedList<>();
            dq.offer(root);
            while (!dq.isEmpty()) {
                int size = dq.size();
                List<Integer> list = new LinkedList<>();
                for (int i = 0; i < size; i++) {
                    if (l2r) {
                        TreeNode cur = dq.removeFirst();
                        if (cur.left != null) dq.addLast(cur.left);
                        if (cur.right != null) dq.addLast(cur.right);
                        list.add(cur.val);
                    } else {
                        TreeNode cur = dq.removeLast();
                        if (cur.right != null) dq.addFirst(cur.right);
                        if (cur.left != null) dq.addFirst(cur.left);
                        list.add(cur.val);
                    }
                }
                res.add(list);
                l2r = !l2r;
            }
            return res;
        }
    }
  #+end_src 
* 104 二叉树的最大深度 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink13>>][offer55]]                               :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public int maxDepth(TreeNode root) {
            if (root == null) return 0;
            return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
        }
    }
  #+end_src 
* 105 从前序和中序遍历序列构造二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink14>>][offer7]] :数组:递归:中序遍历:前序遍历:二叉树:树:
** 直接递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode buildTree(int[] preorder, int[] inorder) {
             if (preorder == null || inorder == null || preorder.length != inorder.length || preorder.length <= 0) return null;
             int len = preorder.length, rootVal = preorder[0], pos = -1;
             TreeNode root = new TreeNode(rootVal);
             for (int i = 0; i < len; i++) {
                 if (inorder[i] == rootVal) {
                     pos = i;
                     break;
                 }
             }
             if (pos == -1) return null;
             root.left = buildTree(Arrays.copyOfRange(preorder, 1, pos+1), Arrays.copyOfRange(inorder, 0, pos));
             root.right = buildTree(Arrays.copyOfRange(preorder, pos+1, len), Arrays.copyOfRange(inorder, pos+1, len));
             return root;
         }
     }
   #+end_src 
** 辅助递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode buildTree(int[] preorder, int[] inorder) {
             if (preorder == null || inorder == null || preorder.length != inorder.length || preorder.length <= 0) return null;

             // int rootVal = preorder[0], index = -1, len = preorder.length;
             // TreeNode root = new TreeNode(preorder[0]);
             // for (int i = 0; i < len; i++) {
             //     if (inorder[i] == rootVal) index = i;
             // }
             // if (index == -1) return null;
             // root.left = buildTree(Arrays.copyOfRange(preorder, 1, index+1), Arrays.copyOfRange(inorder, 0, index));
             // root.right = buildTree(Arrays.copyOfRange(preorder, index+1, len), Arrays.copyOfRange(inorder, index+1, len));
             // return root;

             return buildHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
         }
         private TreeNode buildHelper(int[] preorder, int s1, int e1, int[] inorder, int s2, int e2) {
             if (s1 == e1 && s2 == e2) return null;
             int rootVal = preorder[s1], index = -1;
             TreeNode root = new TreeNode(rootVal);
             for (int i = s2; i < e2; i++) {
                 if (inorder[i] == rootVal) index = i;
             }
             if (index == -1) return null;
             root.left = buildHelper(preorder, s1+1, s1+1+index-s2, inorder, s2, index);
             root.right = buildHelper(preorder, s1+1+index-s2, e1, inorder, index+1, e2);
             return root;
         }
     }
   #+end_src 
* 108 将有序数组转换为二叉搜索树            :递归:DFS:前序遍历:二叉搜索树:树:
  #+begin_src java :classname 
    class Solution {
        public TreeNode sortedArrayToBST(int[] nums) {
            if (nums == null || nums.length == 0) return null;
            TreeNode root = 0;
            int len = nums.length;
            root = new TreeNode(nums[len/2]);
            root.left = sortedArrayToBST(Arrays.copyOfRange(nums, 0, len/2));
            root.right = sortedArrayToBST(Arrays.copyOfRange(nums, len/2+1, len));
            return root;
        }
    }
  #+end_src 
* 114 二叉树展开为链表 :DFS:递归:对称后序遍历:中序遍历:后序遍历:链表:二叉树:树:
** 迭代
   #+begin_src java :classname 
     class Solution {
         public void flatten(TreeNode root) {
             while (root != null) {
                 if (root.left != null) {
                     TreeNode tail = root.left;
                     while (tail.right != null) tail = tail.right;
                     tail.right = root.right;
                     root.right = root.left;
                     root.left = null;
                 }
                 root = root.right;
             }
         }
     }
   #+end_src 
** 递归
   - 对称后序
     #+begin_src java :classname 
       class Solution {
           private TreeNode head = null;
           public void flatten(TreeNode root) {
               if (root == null) return;
               flatten(root.right);
               flatten(root.left);
               root.right = head;
               root.left = null;
               head = root;
           }
       }
     #+end_src
   - 中序
     #+begin_src java :classname 
       class Solution {
           public void flatten(TreeNode root) {
               if (root == null) return;
               flatten(root.left);
               TreeNode tmp = root.right;
               root.right = root.left;
               root.left = null;
               while (root.right != null) root = root.right;
               root.right = tmp;
               flatten(tmp);
           }
       }
     #+end_src
   - 后序
     #+begin_src java :classname 
       class Solution {
           public void flatten(TreeNode root) {
               if (root == null) return;
               flatten(root.left);
               flatten(root.right);
               TreeNode tmp = root.right;
               root.right = root.left;
               root.left = null;
               while (root.right != null) root = root.right;
               root.right = tmp;
           }
       }
     #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 前序遍历递归实现？类比对称后序记录左子树尾节点的递归实现？
** 关于树的DFS(前中后)遍历的迭代实现
   - 前序
     #+begin_src java :classname 
       Stack<TreeNode> stack = new Stack<>();
       stack.push(root);
       while (!stack.empty()) {
           TreeNode n = stack.pop();
           if (n.right != null) stack.push(n.right);
           if (n.left != null) stack.push(n.left);
       }
     #+end_src 
   - 中序
     #+begin_src java :classname 
       Stack<TreeNode> stack = new Stack<>();
       TreeNode cur = root;
       while (!stack.empty() || cur != null) {
           if (cur != null) {
               stack.push(cur);
               cur = cur.left;
           } else {
               cur = stack.pop();
               cur = cur.right;
           }
       }
     #+end_src 
   - 后序
     #+begin_src java :classname 
       Stack<TreeNode> stack1 = new Stack<>();
       Stack<TreeNode> stack2 = new Stack<>();
       stack1.push(root);
       while (!stack1.empty()) {
           TreeNode n = stack1.pop();
           stack2.push(n);
           if (n.left != null) stack1.push(n.left);
           if (n.right != null) stack1.push(n.right);
       }

       while (!stack2.empty()) stack2.pop();
     #+end_src 
* 116 填充每个节点的下一个右侧节点指针 :BFS:层序遍历:递归:DFS:前序遍历:二叉树:树:
** 层序遍历BFS
   #+begin_src java :classname 
     class Solution {
         public Node connect(Node root) {
             if (root == null) return null;
             Queue<Node> que = new LinkedList<>();
             que.offer(root);
             while (!que.isEmpty()) {
                 int size = que.size();
                 Node pre = null;
                 for (int i = 0; i < size; i++) {
                     Node cur = que.poll();
                     cur.next = pre;
                     pre = cur;
                     if (cur.left != null) {
                         que.offer(cur.right);   
                         que.offer(cur.left);
                     }
                 }
             }
             return root;
         }
     }
   #+end_src 
** 前序遍历DFS
   #+begin_src java :classname 
     class Solution {
         public Node connect(Node root) {
             if (root == null || root.left == null) return root;
             root.left.next = root.right;
             if (root.next != null) root.right.next = root.next.left;
             root.left = connect(root.left);
             root.right = connect(root.right);
             return root;
         }
     }
   #+end_src 
* 118 杨辉三角                                                           :DP:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> generate(int numRows) {
            List<List<Integer>> res = new ArrayList<>();
            if (numRows <= 0) return res;

            res.add(new ArrayList<>());
            res.get(0).add(1);
            for (int i = 1; i < numRows; i++) {
                List<Integer> curRow = new ArrayList<>();
                List<Integer> preRow = res.get(i-1);
                curRow.add(1);
                for (int j = 1; j <= i-1; j++) {
                    curRow.add(preRow.get(j)+preRow.get(j-1));
                }
                curRow.add(1);
                res.add(curRow);
            }
            return res;
        }
    }
  #+end_src 
* 120 三角形最小路径和                                              :DP:数组:
** 自底向上
  - 二维
    #+begin_src java :classname 
      class Solution {
          public int minimumTotal(List<List<Integer>> triangle) {
              if (triangle == null) return 0;
              int len = triangle.size();
              int[][] res = new int[len][len];
              for (int i = 0; i < len; i++) {
                  res[len-1][i] = triangle.get(len-1).get(i);
              }
              for (int i = len-2; i >= 0; i--) {
                  for (int j = 0; j <= i; j++) {
                      res[i][j] = Math.min(res[i+1][j], res[i+1][j+1]) + triangle.get(i).get(j);
                  }
              }
              return res[0][0];
          }
      }
    #+end_src
  - 一维(空间优化)
    #+begin_src java :classname 
      class Solution {
          public int minimumTotal(List<List<Integer>> triangle) {
              if (triangle == null) return 0;
              int len = triangle.size();
              int[] res = new int[len];
              for (int i = 0; i < len; i++) {
                  res[i] = triangle.get(len-1).get(i);
              }

              for (int i = len-2; i >= 0; i--) {
                  for (int j = 0; j <= i; j++) {
                      res[j] = Math.min(res[j], res[j+1]) + triangle.get(i).get(j);
                  }
              }
              return res[0];
          }
      }
    #+end_src
* 121 买卖股票的最佳时机                                               :数组:
  #+begin_src java :classname 
    class Solution {
        public int maxProfit(int[] prices) {
            int max = 0, buy = 0, len = prices.length;
            for (int i = 0; i < len; i++) {
                int cur = prices[i] - prices[buy];
                if (max < cur) max = cur;
                if (cur < 0) buy = i;
            }
            return max;
        }
    }
  #+end_src 
* 122 买卖股票的最佳时机 II                                            :数组:
  #+begin_src java :classname 
    class Solution {
        public int maxProfit(int[] prices) {
            int res = 0;
            for (int i = 1; i < prices.length; i++) {
                if (prices[i] > prices[i-1]) res += prices[i]-prices[i-1];
            }
            return res;
        }
    }
  #+end_src 
* 124 二叉树中的最大路径和                                       :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int maxPathSum(TreeNode root) {

        }
    }
  #+end_src 
* 125 验证回文子串                                            :双指针:字符串:
  #+begin_src java :classname 
    class Solution {
        public boolean isPalindrome(String s) {
            if (s == null) return false;
            if (s.length() <= 1) return true;
            int left = 0, right = s.length()-1;
            s = s.toLowerCase();
            while (left < right) {
                // while (left < right && !Character.isLetterOrDigit(s.charAt(left))) left++;
                // while (left < right && !Character.isLetterOrDigit(s.charAt(right))) right--;
                while (left < right && notNumOrAz(s.charAt(left))) left++;
                while (left < right && notNumOrAz(s.charAt(right))) right--;
                if (left >= right) break;
                if (s.charAt(left) != s.charAt(right)) return false;
                left++;
                right--;
            }
            return true;
        }

        private boolean notNumOrAz(char ch) {
            return ch < '0' || (ch > '9' && ch < 'a') || ch > 'z';
        }
    }
  #+end_src 
* 127 单词接龙                                           :双向BFS:BFS:字符串:
** BFS
*** 单向
    #+begin_src java :classname 
      class Solution {
          public int ladderLength(String beginWord, String endWord, List<String> wordList) {
              Set<String> wordSet = new HashSet<>(wordList);
              if (wordSet.size() == 0 || !wordSet.contains(endWord)) return 0;
              Queue<String> que = new LinkedList<>();
              que.offer(beginWord);
              wordSet.remove(beginWord);
              int wordLen = beginWord.length();
              int res = 1;
              while (!que.isEmpty()) {
                  int size = que.size();
                  for (int i = 0; i < size; i++) {
                      String curWord = que.poll();
                      char[] chs = curWord.toCharArray();
                      for (int j = 0; j < wordLen; j++) {
                          char originCh = chs[j];
                          for (char ch = 'a'; ch <= 'z'; ch++) {
                              if (originCh == ch) continue;
                              chs[j] = ch;
                              // String nextWord = new String(chs);
                              String nextWord = String.valueOf(chs);
                              if (wordSet.contains(nextWord)) {
                                  if (nextWord.equals(endWord)) return res+1;
                                  que.add(nextWord);
                                  wordSet.remove(nextWord);
                              }
                          }
                          chs[j] = originCh;
                      }
                  }
                  res++;
              }
              return 0;
          }
      }
    #+end_src 
*** 双向                                                         :UNRESOLVED:
    #+begin_src java :classname 
      public class Solution {

          public int ladderLength(String beginWord, String endWord, List<String> wordList) {
              // 先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里
              Set<String> wordSet = new HashSet<>(wordList);
              if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
                  return 0;
              }

              // 标准写法，总的 visited 数组
              Set<String> visited = new HashSet<>();

              // 分别用左边和右边扩散的哈希表代替单向 BFS 里的队列
              Set<String> beginVisited = new HashSet<>();
              beginVisited.add(beginWord);

              Set<String> endVisited = new HashSet<>();
              endVisited.add(endWord);

              int len = beginWord.length();
              int step = 1;
              while (!beginVisited.isEmpty() && !endVisited.isEmpty()) {
                  // 优先选择小的哈希表进行扩散，考虑到的情况更少
                  if (beginVisited.size() > endVisited.size()) {
                      Set<String> temp = beginVisited;
                      beginVisited = endVisited;
                      endVisited = temp;
                  }

                  // 逻辑到这里，保证 beginVisited 是相对较小的集合
                  // nextLevelVisited 在扩散完成以后，会成为新的 beginVisited
                  Set<String> nextLevelVisited = new HashSet<>();
                  for (String word : beginVisited) {
                      char[] charArray = word.toCharArray();
                      for (int i = 0; i < len; i++) {
                          char originChar = charArray[i];
                          for (char c = 'a'; c <= 'z'; c++) {
                              if (originChar == c) {
                                  continue;
                              }
                              charArray[i] = c;
                              String nextWord = String.valueOf(charArray);
                              if (wordSet.contains(nextWord)) {
                                  if (endVisited.contains(nextWord)) {
                                      return step + 1;
                                  }
                                  if (!visited.contains(nextWord)) {
                                      nextLevelVisited.add(nextWord);
                                      visited.add(nextWord);
                                  }
                              }
                          }
                          // 恢复，下次再用
                          charArray[i] = originChar;
                      }
                  }

                  // 这一行代表表示从 begin 这一侧向外扩散了一层
                  beginVisited = nextLevelVisited;
                  step++;
              }
              return 0;
          }
      }
    #+end_src 
* 128 最长连续序列                                               :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int longestConsecutive(int[] nums) {

        }
    }
  #+end_src 
* 130 被围绕的区域
  #+begin_src java :classname 
    class Solution {
        public void solve(char[][] board) {

        }
    }
  #+end_src 
* 131 分割回文串
  #+begin_src java :classname 
    class Solution {
        public List<List<String>> partition(String s) {

        }
    }
  #+end_src 
* 134 加油站
  #+begin_src java :classname 
    class Solution {
        public int canCompleteCircuit(int[] gas, int[] cost) {

        }
    }
  #+end_src 
* 136 只出现一次的数字                                          :位运算:数组:
  #+begin_src java :classname 
    class Solution {
        public int singleNumber(int[] nums) {
            int xor = 0;
            for (int i = 0; i < nums.length; i++) xor ^= nums[i];
            return xor;
        }
    }
  #+end_src 
* 138 复制带随机指针的链表
  #+begin_src java :classname 
    class Solution {
        public Node copyRandomList(Node head) {
            if (head == null) return null;
            Node p, cp, cpHead;
            p = head;
            while (p != null) {
                cp = new Node(p.val);
                cp.next = p.next;
                p.next = cp;
                p = cp.next;
            }
            cpHead = head.next;
            p = head;
            while (p != null) {
                cp = p.next;
                if (p.random != null) {
                    cp.random = p.random.next;
                }
                p = cp.next;
            }
            p = head;
            cp = p.next;
            while (cp.next != null) {
                p.next = cp.next;
                p = p.next;
                cp.next = p.next;
                cp = cp.next;
            }
            p.next = null;
            return cpHead;
        }
    }
  #+end_src 
* 139 单词拆分                                          :DP:回溯:递归:字符串:
** 回溯(记忆剪枝)
   #+begin_src java :classname 
     class Solution {
         public boolean wordBreak(String s, List<String> wordDict) {
             return Helper(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);
         }

         private boolean Helper(String s, Set<String> set, int start, Boolean[] memo) {
             if (start == s.length()) return true;

             if (memo[start] != null) return memo[start];

             for (int i = start+1; i <= s.length(); i++) {
                 if (set.contains(s.substring(start, i)) && Helper(s, set, i, memo)) return memo[start] = true;
             }
             return memo[start] = false;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         public boolean wordBreak(String s, List<String> wordDict) {
             Set<String> set = new HashSet<>(wordDict);
             boolean[] word = new boolean[s.length()+1];
             word[0] = true;
             for (int i = 1; i <= s.length(); i++) {
                 for (int j = 0; j < i; j++) {
                     if (word[j] && set.contains(s.substring(j, i))) {
                         word[i] = true;
                         break;
                     }
                 }
             }
             return word[s.length()];
         }
     }
   #+end_src 
** BFS                                                           :UNRESOLVED:
* 140 单词拆分 II                                                :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public List<String> wordBreak(String s, List<String> wordDict) {

        }
    }
  #+end_src 
* 141 环形链表                                         :快慢指针:双指针:链表:
  #+begin_src java :classname 
    public class Solution {
        public boolean hasCycle(ListNode head) {
            ListNode p1 = head, p2 = head;
            while (p1 != null && p2 != null) {
                p1 = p1.next;
                if (p2.next == null) break;
                p2 = p2.next.next;
                if (p1 == p2) return true;
            }
            return false;
        }
    }
  #+end_src 
* 142 环形链表 2 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink15>>][offer23]]                               :快慢指针:双指针:链表:
  #+begin_src java :classname 
    public class Solution {
        public ListNode detectCycle(ListNode head) {
            ListNode n1 = head, n2 = head;
            while (true) {
                if (n1 == null || n2 == null || n2.next == null) return null;
                n1 = n1.next;
                n2 = n2.next.next;
                if (n1 == n2) break;
            }
            int len = 0;
            while (true) {
                n1 = n1.next;
                len += 1;
                if (n1 == n2) {
                    n1 = n2 = head;
                    break;
                }
            }
            for (int i = 0; i < len; i++) n2 = n2.next;
            while (n1 != n2) {
                n1 = n1.next;
                n2 = n2.next;
            }
            return n1;
        }
    }
  #+end_src 
* 146 LRU缓存机制                                                       :LRU:
** LinkedHashMap
   #+begin_src java :classname 
     class LRUCache extends LinkedHashMap<Integer, Integer>{
         private int capacity;
    
         public LRUCache(int capacity) {
             super(capacity, 0.75F, true);
             this.capacity = capacity;
         }

         public int get(int key) {
             return super.getOrDefault(key, -1);
         }

         public void put(int key, int value) {
             super.put(key, value);
         }

         @Override
         protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
             return size() > capacity; 
         }
     }
   #+end_src 
** Hashtable+链表                                                :UNRESOLVED:
   #+begin_src java :classname 
     import java.util.Hashtable;
     public class LRUCache {

       class DLinkedNode {
         int key;
         int value;
         DLinkedNode prev;
         DLinkedNode next;
       }

       private void addNode(DLinkedNode node) {
         /**
          ,* Always add the new node right after head.
          ,*/
         node.prev = head;
         node.next = head.next;

         head.next.prev = node;
         head.next = node;
       }

       private void removeNode(DLinkedNode node){
         /**
          ,* Remove an existing node from the linked list.
          ,*/
         DLinkedNode prev = node.prev;
         DLinkedNode next = node.next;

         prev.next = next;
         next.prev = prev;
       }

       private void moveToHead(DLinkedNode node){
         /**
          ,* Move certain node in between to the head.
          ,*/
         removeNode(node);
         addNode(node);
       }

       private DLinkedNode popTail() {
         /**
          ,* Pop the current tail.
          ,*/
         DLinkedNode res = tail.prev;
         removeNode(res);
         return res;
       }

       private Hashtable<Integer, DLinkedNode> cache =
               new Hashtable<Integer, DLinkedNode>();
       private int size;
       private int capacity;
       private DLinkedNode head, tail;

       public LRUCache(int capacity) {
         this.size = 0;
         this.capacity = capacity;

         head = new DLinkedNode();
         // head.prev = null;

         tail = new DLinkedNode();
         // tail.next = null;

         head.next = tail;
         tail.prev = head;
       }

       public int get(int key) {
         DLinkedNode node = cache.get(key);
         if (node == null) return -1;

         // move the accessed node to the head;
         moveToHead(node);

         return node.value;
       }

       public void put(int key, int value) {
         DLinkedNode node = cache.get(key);

         if(node == null) {
           DLinkedNode newNode = new DLinkedNode();
           newNode.key = key;
           newNode.value = value;

           cache.put(key, newNode);
           addNode(newNode);

           ++size;

           if(size > capacity) {
             // pop the tail
             DLinkedNode tail = popTail();
             cache.remove(tail.key);
             --size;
           }
         } else {
           // update the value.
           node.value = value;
           moveToHead(node);
         }
       }
     }

     /**
      ,* LRUCache 对象会以如下语句构造和调用:
      ,* LRUCache obj = new LRUCache(capacity);
      ,* int param_1 = obj.get(key);
      ,* obj.put(key,value);
      ,*/
   #+end_src 
* 148 排序链表                             :递归:快排:归并排序:排序:链表:
** 归并排序
*** 递归(自顶而下)
    #+begin_src java :classname 
      class Solution {
          public ListNode sortList(ListNode head) {
              if (head == null) return null;
              return mergeSort(head);
          }

          private ListNode mergeSort(ListNode head) {
              if (head.next == null) return head;
              ListNode half = halfList(head);
              return mergeSortedList(mergeSort(head), mergeSort(half));
          }

          private ListNode halfList(ListNode head) {
              ListNode p1 = head, p2 = head, pre = null;
              while (p2 != null && p2.next != null) {
                  pre = p1;
                  p1 = p1.next;
                  p2 = p2.next.next;
              }
              pre.next = null;
              return p1;
          }

          private ListNode mergeSortedList(ListNode p1, ListNode p2) {
              ListNode p = new ListNode(-1), cur = p;
              while (p1 != null && p2 != null) {
                  if (p1.val < p2.val) {
                      cur.next = p1;
                      p1 = p1.next;
                  } else {
                      cur.next = p2;
                      p2 = p2.next;
                  }
                  cur = cur.next;
              }

              cur.next = p1 == null ? p2 : p1;
              return p.next;
          }
      }
    #+end_src 
*** 迭代(自底向上)                                               :UNRESOLVED:
** 快排
   #+begin_src java :classname 
     class Solution {
         public ListNode sortList(ListNode head) {
             if (head == null || head.next == null) return head;
             ListNode tail = head;
             while (tail.next != null) tail = tail.next;
             quickSortList(head, tail);
             return head;
         }

         private void quickSortList(ListNode head, ListNode tail) {
             if (head == null || tail == null || head == tail) return;
             List<ListNode > res = partitionList(head, tail);
             ListNode beforeLess = res.get(0), less = res.get(1);
             quickSortList(head, beforeLess);
             if (less != tail) {
                 quickSortList(less.next, tail);
             }
         }

         private List<ListNode> partitionList(ListNode head, ListNode tail) {
             List<ListNode> res = new ArrayList<>();
             ListNode less = null, beforeLess = null, cur = head;
             swap(head, tail);
             while (cur != tail) {
                 if (cur.val < tail.val) {
                     beforeLess = less;
                     if (less == null) less = head;
                     else less = less.next;
                     if (less != cur) swap(less, cur);
                 }
                 cur = cur.next;
             }
             beforeLess = less;
             if (less == null) less = head;
             else less = less.next;
             if (less != null && less != tail) swap(less, tail);
             res.add(beforeLess);
             res.add(less);
             return res;
         }

         private void swap(ListNode p1, ListNode p2) {
             int temp = p1.val;
             p1.val = p2.val;
             p2.val = temp;
         }
     }
   #+end_src 
* 149 直线上最多的点数                                           :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int maxPoints(int[][] points) {

        }
    }
  #+end_src 
* 150 逆波兰表达式求值
  #+begin_src java :classname 
    class Solution {
        public int evalRPN(String[] tokens) {

        }
    }
  #+end_src 
* 152 乘积最大子数组                                                   :数组:
  #+begin_src java :classname 
    class Solution {
        public int maxProduct(int[] nums) {
            int max = Integer.MIN_VALUE, max1 = 1, max2 = 1, len = nums.length;
            for (int i = 0; i < len; i++) {
                max1 *= nums[i];
                max2 *= nums[len-i-1];
                int curMax = Math.max(max1, max2);
                if (max < curMax) max = curMax;
                if (nums[i] == 0) max1 = 1;
                if (nums[len-i-1] == 0) max2 = 1;
            }
            return max;
        }
    }
  #+end_src 
* 155 最小栈                                                      :辅助栈:栈:
  #+begin_src java :classname 
    class MinStack {

        private Stack<Integer> data;
        private Stack<Integer> min;

        /** initialize your data structure here. */
        public MinStack() {
            data = new Stack<>();
            min = new Stack<>();
        }

        public void push(int x) {
            data.push(x);
            if (min.empty() || min.peek() >= x) min.push(x);
        }

        public void pop() {
            if (!data.empty()) {
                int x = data.pop();
                if (x == min.peek()) min.pop();
            }
        }

        public int top() {
            return data.peek();
        }

        public int getMin() {
            return min.peek();
        }
    }
  #+end_src 
* 160 相交链表 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink17>>][offer52]]                                                 :链表:
  #+begin_src java :classname 
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            int l1 = 0, l2 = 0;
            ListNode p1 = headA, p2 = headB;
            while (p1 != null) {
                p1 = p1.next;
                l1 += 1;
            }
            while (p2 != null) {
                p2 = p2.next;
                l2 += 1;
            }
            p1 = headA;
            p2 = headB;
            int l = l1 - l2;
            if (l < 0) {
                p1 = headB;
                p2 = headA;
                l = -l;
            }
            for (int i = 0; i < l; i++) p1 = p1.next;
            while (p1 != p2) {
                p1 = p1.next;
                p2 = p2.next;
            }
            return p1;
        }
    }
  #+end_src 
* 162 寻找峰值
  #+begin_src java :classname 
    class Solution {
        public int findPeakElement(int[] nums) {

        }
    }
  #+end_src 
* 163 缺失的区间                                                 :UNRESOLVED:
* 166 分数到小数
  #+begin_src java :classname 
    class Solution {
        public String fractionToDecimal(int numerator, int denominator) {

        }
    }
  #+end_src 
* 169 多数元素 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink21>>][offer39]]                                                :数组:
  #+begin_src java :classname 
    class Solution {
        public int majorityElement(int[] nums) {
            int target = nums[0], n = 1;
            for (int i = 1; i < nums.length; i++) {
                if (n == 0) {
                    target = nums[i];
                    n = 1;
                    continue;
                }
                if (nums[i] == target) n += 1;
                else n -= 1;
            }
            return target;
        }
    }
  #+end_src 
* 171 Excel表序列号
  #+begin_src java :classname 
    class Solution {
        public int titleToNumber(String s) {

        }
    }
  #+end_src 
* 172 阶乘后的零
  #+begin_src java :classname 
    class Solution {
        public int trailingZeroes(int n) {

        }
    }
  #+end_src 
* 179 最大数
  #+begin_src java :classname 
    class Solution {
        public String largestNumber(int[] nums) {

        }
    }
  #+end_src 
* 189 旋转数组
  #+begin_src java :classname 
    class Solution {
        public void rotate(int[] nums, int k) {

        }
    }
  #+end_src 
* 190 颠倒二进制位
  #+begin_src java :classname 
    public class Solution {
        // you need treat n as an unsigned value
        public int reverseBits(int n) {
        
        }
    }
  #+end_src 
* 191 位1的个数                                                      :位运算:
  #+begin_src java :classname 
    public class Solution {
        // you need to treat n as an unsigned value
        public int hammingWeight(int n) {
            int res = 0;
            while (n != 0) {
                // if ((n&1) == 1) res++;
                // n >>= 1;
                res++;
                n &= (n-1);
            }
            return res;
        }
    }
  #+end_src 
* 198 打家劫舍                                                      :DP:数组:
  #+begin_src java :classname 
    class Solution {
        public int rob(int[] nums) {
            if (nums == null || nums.length <= 0) return 0;
            int prevMax = 0, currMax = 0;
            for (int x : nums) {
                int temp = currMax;
                currMax = Math.max(prevMax+x, currMax);
                prevMax = temp;
            }
            return currMax;
        }
    }
  #+end_src 
* 200 岛屿数量                            :BFS:DFS:递归:并查集:二维数组:数组:
** DFS
   #+begin_src java :classname 
     class Solution {
         public int numIslands(char[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
             int rn = grid.length, cn = grid[0].length, num = 0;
             for (int i = 0; i < rn; i++) {
                 for (int j = 0; j < cn; j++) {
                     if (grid[i][j] == '1') {
                         num += 1;
                         dfs(grid, rn, cn, i, j);
                     }
                 }
             }
             return num;
         }

         private void dfs(char[][] grid, int rn, int cn, int r, int c) {
             if (r < 0 || r >= rn || c < 0 || c >= cn) return;
             if (grid[r][c] == '0') return;
             grid[r][c] = '0';
             dfs(grid, rn, cn, r-1, c);
             dfs(grid, rn, cn, r+1, c);
             dfs(grid, rn, cn, r, c-1);
             dfs(grid, rn, cn, r, c+1);
         }
     }
   #+end_src 
** 并查集
   #+begin_src java :classname 
     class Solution {
         class UnionFind {

             int[] vertices;
             int count;

             public UnionFind(char[][] grid) {
                 int rn = grid.length, cn = grid[0].length;
                 vertices = new int[rn*cn];
                 count = 0;
                 for (int i = 0; i < rn; i++) {
                     for (int j = 0; j < cn; j++) {
                         if (grid[i][j] == '1') {
                             count += 1;
                             vertices[i*cn+j] = -1;
                         }
                     }
                 }
             }

             public int sizeOf(int x) {
                 return -vertices[find(x)];
             }

             public int parent(int x) {
                 return vertices[x] < 0 ? x : vertices[x];
             }

             public boolean connected(int x, int y) {
                 int rx = find(x), ry = find(y), px = parent(x), py = parent(y);

                 while (px != rx) {
                     vertices[x] = rx;
                     x = px;
                     px = parent(x);
                 }

                 while (py != ry) {
                     vertices[y] = ry;
                     y = py;
                     py = parent(y);
                 }

                 return rx == ry;
             }

             public void union(int x, int y) {
                 if (!connected(x, y)) {
                     if (sizeOf(x) < sizeOf(y)) {
                         vertices[find(y)] += vertices[find(x)];
                         vertices[find(x)] = find(y);
                     } else {
                         vertices[find(x)] += vertices[find(y)];
                         vertices[find(y)] = find(x);
                     }
                     count -= 1;
                 }
             }

             public int find(int x) {
                 int px = parent(x);
                 return vertices[px] < 0 ? px : find(px);
             }

             public int[] getSet() {
                 return vertices;
             }

             public int getCount() {
                 return count;
             }
         }

         public int numIslands(char[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
             int rn = grid.length, cn = grid[0].length;
             UnionFind uf = new UnionFind(grid);
             for (int i = 0; i < rn; i++){
                 for (int j = 0; j < cn; j++) {
                     if (grid[i][j] == '1') {
                         grid[i][j] = '0';
                         if (i-1 >= 0 && grid[i-1][j] == '1') uf.union((i-1)*cn+j, i*cn+j);
                         if (i+1 < rn && grid[i+1][j] == '1') uf.union((i+1)*cn+j, i*cn+j);
                         if (j-1 >= 0 && grid[i][j-1] == '1') uf.union(i*cn+j-1, i*cn+j);
                         if (j+1 < cn && grid[i][j+1] == '1') uf.union(i*cn+j+1, i*cn+j);
                     }
                 }
             }
             return uf.getCount();
         }
     }
   #+end_src 
** BFS                                                           :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int numIslands(char[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
         }
     }
   #+end_src 
* 202 快乐数
  #+begin_src java :classname 
    class Solution {
        public boolean isHappy(int n) {
        
        }
    }
  #+end_src 
* 204 计数质数
  #+begin_src java :classname 
    class Solution {
        public int countPrimes(int n) {

        }
    }
  #+end_src 
* 206 反转链表 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink19>>][offer24]]                                            :递归:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode reverseList(ListNode head) {
            if (head == null || head.next == null) return head;
            ListNode reverseHead = reverseList(head.next);
            head.next.next = head;
            head.next = null;
            return reverseHead;
        }
    }
  #+end_src 
* 207 课程表 [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink20>>][图遍历]] [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink21>>][拓扑排序]]             :BFS:DFS:递归:拓扑排序:排序:数组:图:
** BFS
   #+begin_src java :classname 
     class Solution {
         public boolean canFinish(int numCourses, int[][] prerequisites) {
             // if (prerequisites == null || prerequisites.length == 0 || prerequisites[0].length == 0) return true;
             int[] indegrees = new int[numCourses];
             List<List<Integer>> adj = new ArrayList<>();
             for (int i = 0; i < numCourses; i++) adj.add(new ArrayList<>());
             for (int[] prereq : prerequisites) {
                 indegrees[prereq[0]] += 1;
                 adj.get(prereq[1]).add(prereq[0]);
             }
             Queue<Integer> que = new LinkedList<>();
             for (int i = 0; i < numCourses; i++) {
                 if (indegrees[i] == 0) que.offer(i);
             }
             while (!que.isEmpty()) {
                 int pre = que.poll();
                 numCourses -= 1;
                 for (int cur : adj.get(pre)) {
                     indegrees[cur] -= 1;
                     if (indegrees[cur] == 0) que.offer(cur);
                 }
             }
             return numCourses == 0;
         }
     }
   #+end_src 
** DFS
   #+begin_src java :classname 
     class Solution {
         public boolean canFinish(int numCourses, int[][] prerequisites) {
             int[] flags = new int[numCourses];
             List<List<Integer>> adj = new ArrayList<>();
             for (int i = 0; i < numCourses; i++) adj.add(new ArrayList<>());
             for (int[] prereq : prerequisites) adj.get(prereq[1]).add(prereq[0]);
             for (int i = 0; i < numCourses; i++) {
                 if (!dfs(adj, flags, i)) return false;
             }
             return true;
         }

         private boolean dfs(List<List<Integer>> adj, int[] flags, int i) {
             if (flags[i] == 1) return false;
             if (flags[i] == -1) return true;
             flags[i] = 1;
             for (int j : adj.get(i)) {
                 if (!dfs(adj, flags, j)) return false;
             }
             flags[i] = -1;
             return true;
         }
     }
   #+end_src 
* 208 实现Trie                                           :数据结构:字典树:树:
** 节点实现
   #+begin_src java :classname 
     class Trie {

         private class Node {
             Map<Character, Node> map;
             boolean key;
             Node(boolean isKey) {
                 map = new HashMap<>();
                 key = isKey;
             }
         }

         private Node root;

         /** Initialize your data structure here. */
         public Trie() {
             root = new Node(false);
         }
    
         /** Inserts a word into the trie. */
         public void insert(String word) {
             Node p = root;
             for (int i = 0; i < word.length(); i++) {
                 char ch = word.charAt(i);
                 if (!p.map.containsKey(ch)) {
                     p.map.put(ch, new Node(false));
                 }
                 p = p.map.get(ch);
             }
             p.key = true;
         }
    
         /** Returns if the word is in the trie. */
         public boolean search(String word) {
             Node p = root;
             for (int i = 0; i < word.length(); i++) {
                 char ch = word.charAt(i);
                 if (!p.map.containsKey(ch)) return false;
                 p = p.map.get(ch);
             }
             return p.key == true;
         }
    
         /** Returns if there is any word in the trie that starts with the given prefix. */
         public boolean startsWith(String prefix) {
             Node p = root;
             for (int i = 0; i < prefix.length(); i++) {
                 char ch = prefix.charAt(i);
                 if (!p.map.containsKey(ch)) return false;
                 p = p.map.get(ch);
             }
             return true;
         }
     }
   #+end_src 
** 数组实现
   #+begin_src java :classname 
     public class Trie {
         private boolean isKey = false;
         private Trie[] tries = new Trie[26];

         public Trie() {}

         public void insert(String word){//插入单词
             Trie root = this;
             char[] chs = word.toCharArray();
             for (int i = 0; i < chs.length; i++) {
                 if (root.tries[chs[i]-'a'] == null) root.tries[chs[i]-'a'] = new Trie();
                 root = root.tries[chs[i]-'a'];
             }
             root.isKey = true;
         }

         public boolean search(String word){//查找单词
             Trie root = this;
             char[] chs = word.toCharArray();
             for (int i = 0; i < chs.length; i++) {
                 if (root.tries[chs[i]-'a'] == null) return false;
                 root = root.tries[chs[i]-'a'];
             }
             return root.isKey == true;
         }

         public boolean startsWith(String prefix){//查找前缀
             Trie root = this;
             char[] chs = prefix.toCharArray();
             for (int i = 0; i < chs.length; i++) {
                 if (root.tries[chs[i]-'a'] == null) return false;
                 root = root.tries[chs[i]-'a'];
             }
             return true;
         }
     }
   #+end_src 
* 210 课程表 II
  #+begin_src java :classname 
    class Solution {
        public int[] findOrder(int numCourses, int[][] prerequisites) {

        }
    }
  #+end_src 
* 212 单词搜索 II                                                :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public List<String> findWords(char[][] board, String[] words) {

        }
    }
  #+end_src 
* 214 最短回文串                                                 :UNRESOLVED:
* 215 数组中的第K个最大元素                           :堆排序:快排:排序:数组:
** 堆排序
   #+begin_src java :classname 
     class Solution {
         public int findKthLargest(int[] nums, int k) {
             PriorityQueue<Integer> pq = new PriorityQueue<>();
             for (int i = 0; i < nums.length; i++) {
                 if (pq.size() < k) pq.offer(nums[i]);
                 else {
                     if (pq.peek() < nums[i]) {
                         pq.poll();
                         pq.offer(nums[i]);
                     }
                 }
             }
             return pq.peek();
         }
     }
   #+end_src 
** 快排 [[ilink1][三路快排]]
   #+begin_src java :classname 
     class Solution {
         public int findKthLargest(int[] nums, int k) {
             int len = nums.length, target = len-k;
             int l = 0, r = len-1;
             int index = partition2Way(nums, l, r);
             while (index != target) {
                 if (index > target) r = index - 1;
                 else l = index + 1;
                 index = partition2Way(nums, l, r);
             }

             // int[] index = partition3Way(nums, l, r);
             // while (index[0] != target) {
             //     if (index[0] > target) r = index[1]-1;
             //     else l = index[0]+1;
             //     index = partition3Way(nums, l, r);
             // }
             // while (index[1] != target) {
             //     if (index[1] > target) r = index[1]-1;
             //     else l = index[1]+1;
             //     index = partition3Way(nums, l, r);
             // }

             return nums[target];
         }

         private int partition(int[] array, int l, int r) {
             int pivot = (int) (Math.random()*(r-l+1)) + l;
             swap(array, pivot, r);
             int less = l - 1;
             while (l < r) {
                 if (array[l] < array[r]) swap(array, l, ++less);
                 l++;
             }
             swap(array, ++less, r);
             return less;
         }

         private int partition2Way(int[] array, int l, int r) {
             int pivot = (int) (Math.random()*(r-l+1)) + l;
             swap(array, pivot, r);
             int i = l, j = r - 1;
             while (true) {
                 while(i < r && array[i] < array[r]) i++;
                 while(j >= l && array[j] > array[r]) j--;
                 if (i > j) break;
                 swap(array, i++, j--);
             }
             swap(array, i, r);
             return i;
         }

         private int[] partition3Way(int[] array, int l, int r) {
             int pivot = (int) (Math.random()*(r-l+1)) + l;
             swap(array, pivot, r);
             int less = l-1, more = r;
             while (l < more) {
                 if (array[l] < array[r]) swap(array, ++less, l++);
                 else if (array[l] > array[r]) swap(array, l, --more);
                 else l++;
             }
             swap(array, r, more);
             return new int[] {less+1, more};
         }

         private void swap(int[] array, int i, int j) {
             int temp = array[i];
             array[i] = array[j];
             array[j] = temp;
         }

     }
   #+end_src 
** 三种快排思想
*** 普通快排 
    #+begin_src java :classname 
      public static void QuickSort(int[] array, int l, int r) {
          if (l >= r) return;
          int i = partition(array, l, r);
          QuickSort(array, l, i-1);
          QuickSort(array, i+1, r);
      }

      private int partition(int[] array, int l, int r) {
          int pivot = (int) (Math.random()*(r-l+1)) + l;
          swap(array, pivot, r);
          int less = l - 1;
          while (l < r) {
              if (array[l] < array[r]) swap(array, l, ++less);
              l++;
          }
          swap(array, r, ++less);
          return less;
      }
    #+end_src 
*** 双路快排
    #+begin_src java :classname 
      private int partition2Way(int[] array, int l, int r) {
          int pivot = (int) (Math.random()*(r-l+1)) + l;
          swap(array, r, pivot);
          int i = l, j = r - 1;
          while (true) {
              while (i < r && array[i] < array[r]) i++;
              while (j >= l && array[i] > array[r]) j--;
              if (j < i) break;
              swap(array, i++, j--);
          }
          swap(array, i, r);
          return i;
      }
    #+end_src 
*** 三路快排
    #+begin_src java :classname 
      public static void QuickSort(int[] array, int l, int r) {
          if (l >= r) return;
          int[] index = partition3Way(array, l, r);
          QuickSort(array, l, index[0]-1);
          QuickSort(array, index[1]+1, r);
      }

      private int partition3Way(int[] array, int l, int r) {
          int pivot = (int) (Math.random()*(r-l+1)) + l;
          swap(array, pivot, r);
          int less = l-1, more = r;
          while (l < more) {
              if (array[l] < array[r]) swap(array, l++, ++less);
              else if (array[l] > array[r]) swap(array, l, --more);
              else l++;
          }
          swap(array, more, r);
          return new int[] {less+1, more};
      }
    #+end_src 
* 216 组合总和3                                          :回溯:递归:排列组合:
  #+begin_src java :classname 
    class Solution {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();
        public List<List<Integer>> combinationSum3(int k, int n) {
            helper(k, n, 1);
            return res;
        }

        private void helper(int k, int n, int start) {
            if (k == 0 && n == 0) {
                if (!path.isEmpty()) res.add(new ArrayList(path));
                return;
            }
            if (k <= 0 || n <= 0) return;
            for (int i = start; i < 10; i++) {
                path.push(i);
                helper(k-1, n-i, i+1);
                path.pop();
            }
        }
    }
  #+end_src 
* 217 存在重复元素
  #+begin_src java :classname 
    class Solution {
        public boolean containsDuplicate(int[] nums) {

        }
    }
  #+end_src 
* 218 天际线问题                                                 :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> getSkyline(int[][] buildings) {

        }
    }
  #+end_src 
* 221 最大正方形                                           :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int maximalSquare(char[][] matrix) {
            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
            int rows = matrix.length, cols = matrix[0].length;
            int[][] dp = new int[rows+1][cols+1];
            int max = Integer.MIN_VALUE;
            for (int i = 1; i <= rows; i++) {
                for (int j = 1; j <= cols; j++) {
                    if (matrix[i-1][j-1] == '0') continue;
                    int prev = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j]));
                    dp[i][j] = prev + 1;
                    if (max < dp[i][j]) max = dp[i][j];
                }
            }
            return max*max;
        }
    }
  #+end_src 
* 226 翻转二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink22>>][offer27]]  :BFS:DFS:对称遍历:前序遍历:层序遍历:递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public TreeNode invertTree(TreeNode root) {
            if (root == null) return root;
            TreeNode temp = invertTree(root.left);
            root.left = invertTree(root.right);
            root.right = temp;
            return root;
        }
    }
  #+end_src 
* 227 基本计算器 II
  #+begin_src java :classname 
    class Solution {
        public int calculate(String s) {

        }
    }
  #+end_src 
* 230 二叉搜索树中第K小的元素
  #+begin_src java :classname 
    class Solution {
        public int kthSmallest(TreeNode root, int k) {
        
        }
    }
  #+end_src 
* 234 回文链表                                         :快慢指针:双指针:链表:
** 借助 ~Stack~ 
   #+begin_src java :classname 
     class Solution {
         public boolean isPalindrome(ListNode head) {
             Stack<Integer> s = new Stack<>();
             ListNode p1 = head, p2 = head;
             while (p2 != null && p2.next != null) {
                 s.push(p1.val);
                 p1 = p1.next;
                 p2 = p2.next.next;
             }
             if (p2 != null) p1 = p1.next;
             while (p1 != null) {
                 if (p1.val != s.pop()) return false;
                 p1 = p1.next;
             }
             return true;
         }
     }
   #+end_src 
** 反转链表 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink19>>][offer24]]
   #+begin_src java :classname 
     class Solution {
         public boolean isPalindrome(ListNode head) {
             ListNode p1 = head, p2 = head;
             while (p2 != null && p2.next != null) {
                 p1 = p1.next;
                 p2 = p2.next.next;
             }
             p2 = p2 == null ? p1 : p1.next;
             p1 = head;
             ListNode rHead = reverseList(p2);
             p2 = rHead;
             while (p2 != null) {
                 if (p1.val != p2.val) return false;
                 p1 = p1.next;
                 p2 = p2.next;
             }
             reverseList(rHead);
             return true;
         }

         private ListNode reverseList(ListNode n) {
             ListNode pre = null, next = null;
             while (n != null) {
                 next = n.next;
                 n.next = pre;
                 pre = n;
                 n = next;
             }
             return pre;
         }
     }
   #+end_src 
** 递归                                                          :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {

         private ListNode frontPointer;

         private boolean recursivelyCheck(ListNode currentNode) {
             if (currentNode != null) {
                 if (!recursivelyCheck(currentNode.next)) return false;
                 if (currentNode.val != frontPointer.val) return false;
                 frontPointer = frontPointer.next;
             }
             return true;
         }

         public boolean isPalindrome(ListNode head) {
             frontPointer = head;
             return recursivelyCheck(head);
         }
     }
   #+end_src 
* 236 二叉树的最近公共祖先                          :DFS:回溯:递归:二叉树:树:
** 转化为链表分叉口
   #+begin_src java :classname 
     class Solution {
         public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
             if (root == p || root == q) return root;
             List<TreeNode> path1 = new ArrayList<>();
             List<TreeNode> path2 = new ArrayList<>();
             findPath(root, p, path1);
             findPath(root, q, path2);
             TreeNode res  = null;
             int len = Math.min(path1.size(), path2.size());
             for (int i = 0; i < len; i++) {
                 if (path1.get(i) != path2.get(i)) break;
                 res = path1.get(i);
             }
             return res;
         }

         private boolean findPath(TreeNode root, TreeNode target, List<TreeNode> path) {
             path.add(root);
             if (root == target) return true;
             boolean hasPath = false;
             if (root.left != null) hasPath = findPath(root.left, target, path);
             if (hasPath) return true;
             if (root.right != null) hasPath = findPath(root.right, target, path);
             if (!hasPath) path.remove(path.size()-1);
             return hasPath;
         }
     }
   #+end_src 
** 直接递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
             if (root == null || root == p || root == q) return root;
             TreeNode left = lowestCommonAncestor(root.left, p, q);
             TreeNode right = lowestCommonAncestor(root.right, p, q);
             if (left == null) return right;
             if (right == null) return left;
             return root;
         }
     }
   #+end_src 
* 237 删除链表中的节点                                                 :链表:
  #+begin_src java :classname 
    class Solution {
        public void deleteNode(ListNode node) {
            node.val = node.next.val;
            node.next = node.next.next;
        }
    }
  #+end_src 
* 238 除自身以外数组的乘积 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink23>>][offer66]]                            :对称遍历:数组:
  #+begin_src java :classname 
    class Solution {
        public int[] productExceptSelf(int[] nums) {
            if (nums == null || nums.length == 0) return new int[] {};
            int len = nums.length;
            int[] res = new int[len];
            res[0] = 1;
            for (int i = 1; i < len; i++) {
                res[i] = nums[i-1] * res[i-1];
            }
            int temp = 1;
            for (int i = len-2; i >= 0; i--) {
                temp *= nums[i+1];
                res[i] *= temp;
            }
            return res;
        }
    }
  #+end_src 
* 239 滑动窗口最大值 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink24>>][offer59]]           :双端队列:单调队列:队列:滑动窗口:数组:
  #+begin_src java :classname 
    class Solution {
        public int[] maxSlidingWindow(int[] nums, int k) {
            if (nums == null || nums.length == 0 || k == 0 || k > nums.length) return new int[] {};
            int len = nums.length;
            int[] res = new int[len-k+1];
            Deque<Integer> dq = new LinkedList<>();
            for (int i = 0; i < k; i++) {
                while (!dq.isEmpty() && dq.getLast() < nums[i]) dq.removeLast();
                dq.add(nums[i]);
            }
            res[0] = dq.getFirst();
            for (int i = 1; i < res.length; i++) {
                if (nums[i-1] == res[i-1]) dq.removeFirst();
                while (!dq.isEmpty() && dq.getLast() < nums[i+k-1]) dq.removeLast();
                dq.add(nums[i+k-1]);
                res[i] = dq.getFirst();
            }
            return res;
        }
    }
  #+end_src 
* 240 搜索二维矩阵2 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink25>>][offer4]]                               :查找:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public boolean searchMatrix(int[][] matrix, int target) {
            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
            int r = matrix.length, c = matrix[0].length;
            int r0 = 0, c0 = c-1;
            while (r0 < r && c0 >= 0) {
                int cmp = matrix[r0][c0];
                if (cmp == target) return true;
                if (cmp > target) c0 -= 1;
                else r0 += 1;
            }
            return false;
        }
    }
  #+end_src 
* 242 有效的字母异位词
  #+begin_src java :classname 
    class Solution {
        public boolean isAnagram(String s, String t) {

        }
    }
  #+end_src 
* 251 展开二维向量                                               :UNRESOLVED:
* 253 会议室2                                                    :UNRESOLVED:
* 268 缺失数字
  #+begin_src java :classname 
    class Solution {
        public int missingNumber(int[] nums) {

        }
    }
  #+end_src 
* 269 火星词典                                                   :UNRESOLVED:
* 277 搜寻名人                                                   :UNRESOLVED:
* 279 完全平方数 [[ilink2][lc322]] [[ilink3][lc337]]                      :贪婪:DP:BFS:DFS:回溯:递归:
** DFS回溯
   - 暴力超时
     #+begin_src java :classname 
       class Solution {
           public int numSquares(int n) {
               return helper(n);
           }

           private int helper(int n) {
               if (n == 0) return 0;
               int count = Integer.MAX_VALUE;
               for (int i = 1; i*i <= n; i++) {
                   count = Math.min(count, helper(n-i*i)+1);
               }
               return count;
           }
       }
     #+end_src
   - 记忆化
     #+begin_src java :classname 
       class Solution {
           public int numSquares(int n) {
               int[] memo = new int[n+1];
               return helper(n, memo);
           }

           private int helper(int n, int[] memo) {
               if (memo[n] != 0) return memo[n];
               if (n == 0) return 0;
               int count = Integer.MAX_VALUE;
               for (int i = 1; i*i <= n; i++) {
                   count = Math.min(count, helper(n-i*i, memo)+1);
               }
               memo[n] = count;
               return count;
           }
       }
     #+end_src 
** BFS
   - 暴力
     #+begin_src java :classname 
       class Solution {
           public int numSquares(int n) {
               Queue<Integer> que = new LinkedList<>();
               int level = 0;
               que.offer(n);
               while (!que.isEmpty()) {
                   int size = que.size();
                   level += 1;
                   for (int i = 0; i < size; i++) {
                       int cur = que.poll();
                       for (int j = 1; j*j <= cur; j++) {
                           int remain = cur - j*j;
                           if (remain == 0) return level;
                           if (remain > 0) que.offer(remain);
                       }
                   }
               }
               return -1;
           }
       }
     #+end_src
   - 去重
     #+begin_src java :classname 
       class Solution {
           public int numSquares(int n) {
               Queue<Integer> que = new LinkedList<>();
               Set<Integer> visited = new HashSet<>();
               int level = 0;
               que.offer(n);
               while (!que.isEmpty()) {
                   int size = que.size();
                   level += 1;
                   for (int i = 0; i < size; i++) {
                       int cur = que.poll();
                       visited.add(cur);
                       for (int j = 1; j*j <= cur; j++) {
                           int remain = cur - j*j;
                           if (remain == 0) return level;
                           if (!visited.contains(remain)) {
                               visited.add(remain);
                               que.offer(remain);
                           }
                       }
                   }
               }
               return level;
           }
       }
     #+end_src
** DP
   #+begin_src java :classname 
     class Solution {
         public int numSquares(int n) {
             int[] dp = new int[n+1];
             for (int i = 1; i <= n; i++) {
                 dp[i] = i;
                 for (int j = 1; j*j <= i; j++) {
                     dp[i] = Math.min(dp[i], dp[i-j*j]+1);
                 }
             }
             return dp[n];
         }
     }
   #+end_src 
** 贪婪枚举
   #+begin_src java :classname 
     class Solution {
         public int numSquares(int n) {
             Set<Integer> square_nums = new HashSet<>();
             for (int i = 1; i*i <= n; i++) square_nums.add(i*i);
             int count = 1;
             for (; count <= n; count++) {
                 if (helper(n, count, square_nums)) break;
             }
             return count;
         }

         private boolean helper(int n, int count, Set<Integer> square_nums) {
             if (n <= 0) return false;
             if (count == 1) return square_nums.contains(n);
             for (int i = 1; i*i <= n; i++) {
                 if (helper(n-i*i, count-1, square_nums)) return true;
             }
             return false;
         }
     }
   #+end_src
** 数学定理                                                      :UNRESOLVED:
* 283 移动0                                                :快排:双指针:数组:
** 暴力
   #+begin_src java :classname 
     class Solution {
         public void moveZeroes(int[] nums) {
             if (nums == null || nums.length == 0) return;
             int len = nums.length, left = 0, right = len-1;
             while (true) {
                 while (left < right && nums[left] != 0) left += 1;
                 while (left < right && nums[right] == 0) right -= 1;
                 if (right <= left) break;
                 for (int i = 0; i < right-left; i++) swap(nums, left+i, left+i+1);
             }
         }

         private void swap(int[] nums, int i, int j) {
             int temp = nums[i];
             nums[i] = nums[j];
             nums[j] = temp;
         }
     }
   #+end_src 
** 直接赋值
   #+begin_src java :classname 
     class Solution {
         public void moveZeroes(int[] nums) {
             if (nums == null || nums.length == 0) return;
             int len = nums.length, index = 0;
             for (int num : nums) {
                 if (num != 0) nums[index++] = num;
             }
             for (int i = index; i < len; i++) nums[i] = 0;
         }
     }
   #+end_src 
** 双指针(快排)
   #+begin_src java :classname 
     class Solution {
         public void moveZeroes(int[] nums) {
             if (nums == null || nums.length == 0) return;
             int len = nums.length, left = 0;
             for (int i = 0; i < len; i++) {
                 if (nums[i] != 0) {
                     if (left != i) swap(nums, i, left);
                     left += 1;
                 }
             }
         }

         private void swap(int[] nums, int i, int j) {
             int temp = nums[i];
             nums[i] = nums[j];
             nums[j] = temp;
         }
     }
   #+end_src 
* 285 二叉搜索树中的顺序后继                                     :UNRESOLVED:
* 287 寻找重复数                         :快慢指针:双指针:二分查找:查找:数组:
** 二分法 [[file:~/csnds/Dropbox/orglife/offer.org::<<ilink1>>][offer3]]
   #+begin_src java :classname 
     class Solution {
         public int findDuplicate(int[] nums) {
             int len = nums.lengh;
             int start = 1, end = len-1;
             while (start < end) {
                 int count = 0, mid = (start+end) >> 1;
                 for (int num : nums) {
                     if (num >= start && num <= mid) count += 1;
                     // if (num <= mid) count += 1;
                 }
                 if (count > mid-start+1) end = mid;
                 // if (count > mid) end = mid;
                 else start = mid + 1;
             }
             return start;
         }
     }
   #+end_src 
** 快慢指针                                                      :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int findDuplicate(int[] nums) {
             int slow = nums[0], fast = nums[slow];
             while (slow != fast) {
                 slow = nums[slow];
                 fast = nums[nums[fast]];
             }
             slow = 0;
             while (slow != fast) {
                 slow = nums[slow];
                 fast = nums[fast];
             }
             return slow;
         }
     }
   #+end_src 
* 289 生命游戏
  #+begin_src java :classname 
    class Solution {
        public void gameOfLife(int[][] board) {

        }
    }
  #+end_src 
* 295 数据流中的中位数                                           :UNRESOLVED:
  #+begin_src java :classname 
    class MedianFinder {

        /** initialize your data structure here. */
        public MedianFinder() {

        }
    
        public void addNum(int num) {

        }
    
        public double findMedian() {

        }
    }
  #+end_src 
* 297 二叉树的序列化与反序列化 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink26>>][offer37]] :字符串:层序遍历:前序遍历:递归:二叉树:树:
  #+begin_src java :classname 
    public class Codec {

        // Encodes a tree to a single string.
        public String serialize(TreeNode root) {
            StringBuilder sb = new StringBuilder();
            if (root != null) {
                sb.append(root.val+",");
                sb.append(serialize(root.left));
                sb.append(serialize(root.right));
            } else sb.append("null,");
            // sb.deleteCharAt(sb.length()-1); 不能加这句
            return sb.toString();
        }

        // Decodes your encoded data to tree.
        public TreeNode deserialize(String data) {
            String[] strs = data.split(",");
            return deserializeHelper(strs, new int[] {-1});
        }

        private TreeNode deserializeHelper(String[] strs, int[] index) {
            index[0] += 1;
            TreeNode root = null;
            String s = strs[index[0]];
            if (!s.equals("null")) {
                root = new TreeNode(Integer.parseInt(s)); //更快
                // root = new TreeNode(Integer.valueOf(s));
                root.left = deserializeHelper(strs, index);
                root.right = deserializeHelper(strs, index);
            }
            return root;
        }
    }
  #+end_src 
* 300 最长上升子序列                           :贪婪:二分查找:DP:子序列:数组:
** DP
   #+begin_src java :classname 
     class Solution {
         public int lengthOfLIS(int[] nums) {
             if (nums == null || nums.length == 0) return 0;
             int[] len = new int[nums.length];
             int finalMax = 1;
             len[0] = 1;
             for (int i = 1; i < nums.length; i++) {
                 int prevMax = 0;
                 for (int j = 0; j < i; j++) {
                     if (nums[j] < nums[i] && prevMax < len[j]) prevMax = len[j];
                 }
                 len[i] = prevMax + 1;
                 if (finalMax < len[i]) finalMax = len[i];
             }
             return finalMax;
         }
     }
   #+end_src 
** 二分查找                                                      :UNRESOLVED:
* 301 删除无用的括号                                             :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public List<String> removeInvalidParentheses(String s) {

        }
    }
  #+end_src 
* 308 二维区域和检索-可变                                        :UNRESOLVED:
* 309 最佳买卖股票时机含冷冻期 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink27>>][offer63]]                              :DP:数组:
** DP
   - 未优化空间
     #+begin_src java :classname 
       class Solution {
           public int maxProfit(int[] prices) {
               int len = prices.length;
               if (len <= 0) return 0;
               int[][] dp = new int[len][3];
               dp[0][0] = 0;
               dp[0][1] = -prices[0];
               dp[0][2] = 0;

               for (int i = 1; i < len; i++) {
                   dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]);
                   dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
                   dp[i][2] = dp[i-1][1] + prices[i];
               }

               return Math.max(dp[len-1][0], dp[len-1][2]);
           }
       }
     #+end_src 
   - 优化空间(滚动数组)
     #+begin_src java :classname 
       class Solution {
           public int maxProfit(int[] prices) {
               int len = prices.length;
               if (len <= 0) return 0;
               int[] dp = new int[3];
               dp[0] = 0;
               dp[1] = -prices[0];
               dp[2] = 0;
               int pre0 = dp[0], pre1 = dp[1];

               for (int i = 1; i < len; i++) {
                   dp[0] = Math.max(pre0, dp[2]);
                   dp[1] = Math.max(pre1, pre0-prices[i]);
                   dp[2] = pre1 + prices[i];
                   pre0 = dp[0];
                   pre1 = dp[1];
               }

               return Math.max(dp[0], dp[2]);
           }
       }
     #+end_src 
* 312 戳气球                                                     :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int maxCoins(int[] nums) {

        }
    }
  #+end_src 
* 315 计算右侧小于当前元素的个数                                 :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public List<Integer> countSmaller(int[] nums) {

        }
    }
  #+end_src 
* 322 零钱兑换 <<ilink2>>                         :贪婪:DP:BFS:DFS:递归:数组:
** BFS
   #+begin_src java :classname 
     class Solution {
         public int coinChange(int[] coins, int amount) {
             if (amount == 0) return 0;
             Queue<Integer> que = new LinkedList<>();
             boolean[] tovisit = new boolean[amount+1];
             Arrays.sort(coins);
             tovisit[amount] = true;
             que.offer(amount);
             int level = 0;
             while (!que.isEmpty()) {
                 level += 1;
                 int size = que.size();
                 for (int i = 0; i < size; i++) {
                     int cur = que.poll();
                     for (int coin : coins) {
                         int next = cur - coin;
                         if (next == 0) return level;
                         if (next < 0) break;
                         if (tovisit[next]) continue;
                         tovisit[next] = true;
                         que.offer(next);
                     }
                 }
             }
             return -1;
         }
     }
   #+end_src 
** DFS
*** 普通
    #+begin_src java :classname 
      class Solution {
          public int coinChange(int[] coins, int amount) {
              if (amount == 0) return 0;
              Arrays.sort(coins);
              int[] memo = new int[amount+1];
              Arrays.fill(memo, -2);
              return helper(coins, amount, memo);
          }

          private int helper(int[] coins, int amount, int[] memo) {
              if (amount == 0) return 0;
              if (memo[amount] != -2) return memo[amount];
              int minCount = Integer.MAX_VALUE;
              for (int coin : coins) {
                  int next = amount - coin;
                  if (next < 0) break;
                  int nextMin = helper(coins, next, memo);
                  if (nextMin == -1) continue;
                  minCount = Math.min(minCount, nextMin+1);
              }
              memo[amount] = minCount == Integer.MAX_VALUE ? -1 : minCount;
              return memo[amount];
          }
      }
    #+end_src 
*** 贪婪
    #+begin_src java :classname 
      class Solution {
          int res = Integer.MAX_VALUE;
          public int coinChange(int[] coins, int amount) {
              Arrays.sort(coins);
              dfs(coins, coins.length-1, amount, 0);
              return res == Integer.MAX_VALUE ? -1 : res;
          }
          private void dfs(int[] coins, int index, int amount, int usedCoins) {
              if (index < 0) return;
              for (int i = amount/coins[index]; i >= 0; i--) {
                  int remain = amount - i*coins[index];
                  int curUsedCoins = i + usedCoins;
                  if (remain == 0) {
                      res = Math.min(res, curUsedCoins);
                      break;
                  }
                  if (curUsedCoins+1 > res) break;
                  dfs(coins, index-1, remain, curUsedCoins);
              }
          }
      }
    #+end_src 
** DP                                                            :UNRESOLVED:
*** 普通DP
    #+begin_src java :classname 
      class Solution {
          public int coinChange(int[] coins, int amount) {
              if (amount == 0) return 0;
              int[] dp = new int[amount+1];
              Arrays.sort(coins);
              Arrays.fill(dp, amount+1);
              dp[0] = 0;
              for (int i = 1; i <= amount; i++) {
                  for (int coin : coins) {
                      if (i - coin < 0) break;
                      dp[i] = Math.min(dp[i], dp[i-coin]+1);
                  }
              }
              return dp[amount] == amount+1 ? -1 : dp[amount];
          }
      }
    #+end_src
*** 背包问题                                                     :UNRESOLVED:
    #+begin_src java :classname 
      import java.util.Arrays;

      public class Solution {

          public int coinChange(int[] coins, int amount) {
              int[] dp = new int[amount + 1];
              Arrays.fill(dp, amount + 1);
              dp[0] = 0;

              for (int coin : coins) {
                  for (int i = coin; i <= amount; i++) {
                      dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                  }
              }

              if (dp[amount] == amount + 1) {
                  dp[amount] = -1;
              }
              return dp[amount];
          }
      }
    #+end_src 
* 324 摆动顺序 II
  #+begin_src java :classname 
    class Solution {
        public void wiggleSort(int[] nums) {

        }
    }
  #+end_src 
* 326 3的幂                                                            :递归:
  #+begin_src java :classname 
    class Solution {
        public boolean isPowerOfThree(int n) {
            if (n <= 0) return false;
            if (n == 1 || n == 3) return true;
            if (n % 3 != 0) return false;
            return isPowerOfThree(n/3);
        }
    }
  #+end_src 
* 328 奇偶链表
  #+begin_src java :classname 
    class Solution {
        public ListNode oddEvenList(ListNode head) {
        
        }
    }
  #+end_src 
* 329 矩阵中的最长递增路径                                       :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int longestIncreasingPath(int[][] matrix) {

        }
    }
  #+end_src 
* 334 递增的三元子序列
  #+begin_src java :classname 
    class Solution {
        public boolean increasingTriplet(int[] nums) {

        }
    }
  #+end_src 
* 337 打家劫舍3 <<ilink3>>                            :DP:DFS:递归:二叉树:树:
** 暴力递归
   #+begin_src java :classname 
     class Solution {
         public int rob(TreeNode root) {
             if (root == null) return 0;
             int money = root.val;
             if (root.left != null) money += rob(root.left.left) + rob(root.left.right);
             if (root.right != null) money += rob(root.right.left) + rob(root.right.right);
             return Math.max(money, rob(root.left)+rob(root.right));
         }
     }
   #+end_src 
** 记忆化
   #+begin_src java :classname 
     class Solution {
         public int rob(TreeNode root) {
             Map<TreeNode, Integer> memo = new HashMap<>();
             return helper(root, memo);
         }

         private int helper(TreeNode root, Map<TreeNode, Integer> memo) {
             if (root == null) return 0;
             if (memo.containsKey(root)) return memo.get(root);
             int money = root.val;
             if (root.left != null) money += helper(root.left.left, memo) + helper(root.left.right, memo);
             if (root.right != null) money += helper(root.right.left, memo) + helper(root.right.right, memo);
             money = Math.max(money, helper(root.left, memo)+helper(root.right, memo));
             memo.put(root, money);
             return money;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {

         public int rob(TreeNode root) {
             int[] res = helper(root);
             return Math.max(res[0], res[1]);
         }

         private int[] helper(TreeNode root) {
             if (root == null) return new int[2];
             int[] res = new int[2];
             int[] left = helper(root.left);
             int[] right = helper(root.right);
             res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
             res[1] = root.val + left[0] + right[0];
             return res;
         }

     }
   #+end_src 
* 338 比特位计数                                                  :DP:位运算:
** 暴力
   #+begin_src java :classname 
     class Solution {
         public int[] countBits(int num) {
             int[] res = new int[num+1];
             for (int i = 1; i <= num; i++) {
                 int j = 1, k = 0;
                 while (((i-1)&j) != 0) {
                     j = j << 1;
                     k += 1;
                 }
                 res[i] = res[i-1] + 1 - k;
             }
             return res;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         public int[] countBits(int num) {
             int[] res = new int[num+1];
             for (int i = 1; i <= num; i++) {
                 res[i] = res[i>>1] + (i&1);
                 // res[i] = res[i&(i-1)] + 1;
             }
             return res;
         }
     }
   #+end_src 
* 340 之多包含K个不同字符的最长子串                              :UNRESOLVED:
* 341 扁平化嵌套列表迭代器
  #+begin_src java :classname 
    public class NestedIterator implements Iterator<Integer> {

        public NestedIterator(List<NestedInteger> nestedList) {
        
        }

        @Override
        public Integer next() {
        
        }

        @Override
        public boolean hasNext() {
        
        }
    }
  #+end_src 
* 344 反转字符串                                                :双指针:数组:
  #+begin_src java :classname 
    class Solution {
        public void reverseString(char[] s) {
            int left = 0, right = s.length-1;
            while (left < right) {
                char tmp = s[left];
                s[left] = s[right];
                s[right] = tmp;
                left++;
                right--;
            }
        }
    }
  #+end_src 
* 347 前K个高频元素                               :桶排序:小跟堆:堆排序:排序:
** 堆排序
   #+begin_src java :classname 
     class Solution {
         public int[] topKFrequent(int[] nums, int k) {
             Map<Integer, Integer> map = new HashMap<>();
             for (int num : nums) {
                 map.put(num, map.getOrDefault(num, 0) + 1);
             }

             // Comparator<Integer> topKComparator = (Integer n1, Integer n2) -> {
             //     return map.get(n1) - map.get(n2);
             // };

             // PriorityQueue<Integer> pq = new PriorityQueue(topKComparator);

             // PriorityQueue<Integer> pq = new PriorityQueue((n1, n2) -> map.get(n1) - map.get(n2));
             PriorityQueue<Integer> pq = new PriorityQueue(new Comparator<Integer>() {
                     @Override
                     public int compare(Integer n1, Integer n2) {
                         return map.get(n1) - map.get(n2);
                     }
                 });

             for (int i : map.keySet()) {
                 pq.offer(i);
                 if (pq.size() > k) pq.poll();
             }

             int[] res = new int[k];
             for (int i = 0; i < k; i++) res[i] = pq.poll();
             return res;
         }
     }
   #+end_src 
** 桶排序                                                        :UNRESOLVED:
   #+begin_src java :classname 
     //基于桶排序求解「前 K 个高频元素」
     class Solution {
         public List<Integer> topKFrequent(int[] nums, int k) {
             List<Integer> res = new ArrayList();
             // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
             HashMap<Integer,Integer> map = new HashMap();
             for(int num : nums){
                 if (map.containsKey(num)) {
                    map.put(num, map.get(num) + 1);
                  } else {
                     map.put(num, 1);
                  }
             }
        
             //桶排序
             //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
             List<Integer>[] list = new List[nums.length+1];
             for(int key : map.keySet()){
                 // 获取出现的次数作为下标
                 int i = map.get(key);
                 if(list[i] == null){
                    list[i] = new ArrayList();
                 } 
                 list[i].add(key);
             }
        
             // 倒序遍历数组获取出现顺序从大到小的排列
             for(int i = list.length - 1;i >= 0 && res.size() < k;i--){
                 if(list[i] == null) continue;
                 res.addAll(list[i]);
             }
             return res;
         }
     }
   #+end_src 
* 348 判定井字棋胜负                                             :UNRESOLVED:
* 350 两个数组的交集 II
  #+begin_src java :classname 
    class Solution {
        public int[] intersect(int[] nums1, int[] nums2) {

        }
    }
  #+end_src 
* 371 两整数之和                                                     :位运算:
  #+begin_src java :classname 
    class Solution {
        public int getSum(int a, int b) {
            while (b != 0) {
                int tmp = a ^ b;
                b = (a&b) << 1;
                a = tmp;
            }
            return a;
        }
    }
  #+end_src 
* 378 有序矩阵中第K小的元素
  #+begin_src java :classname 
    class Solution {
        public int kthSmallest(int[][] matrix, int k) {

        }
    }
  #+end_src 
* 380 常数时间插入、删除和获取随机元素
  #+begin_src java :classname 
    class RandomizedSet {

        /** Initialize your data structure here. */
        public RandomizedSet() {

        }
    
        /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
        public boolean insert(int val) {

        }
    
        /** Removes a value from the set. Returns true if the set contained the specified element. */
        public boolean remove(int val) {

        }
    
        /** Get a random element from the set. */
        public int getRandom() {

        }
    }
  #+end_src 
* 384 打乱数组
  #+begin_src java :classname 
    class Solution {

        public Solution(int[] nums) {

        }
    
        /** Resets the array to its original configuration and return it. */
        public int[] reset() {

        }
    
        /** Returns a random shuffling of the array. */
        public int[] shuffle() {

        }
    }
  #+end_src 
* 387 字符串中第一个唯一字符
  #+begin_src java :classname 
    class Solution {
        public int firstUniqChar(String s) {
            int[] 
        }
    }
  #+end_src 
* 394 字符串解码                                         :递归:辅助栈:字符串:
** 辅助栈
   #+begin_src java :classname 
     class Solution {
         public String decodeString(String s) {
             StringBuilder res = new StringBuilder();
             int multi = 0;
             Stack<Integer> stack_multi = new Stack<>();
             Stack<String> stack_res = new Stack<>();
             for (char c : s.toCharArray()) {
                 if (c == '[') {
                     stack_multi.push(multi);
                     multi = 0;
                     stack_res.push(res.toString());
                     res = new StringBuilder();
                 } else if (c == ']') {
                     int cur_multi = stack_multi.pop();
                     StringBuilder tmp = new StringBuilder();
                     for (int i = 0; i < cur_multi; i++) {
                         tmp.append(res);
                     }
                     res = new StringBuilder(stack_res.pop()+tmp);
                 } else if (c >= '0' && c <= '9') multi = multi*10 + c - '0';
                 else res.append(c);
             }
             return res.toString();
         }
     }
   #+end_src 
** 递归
   - 辅助成员变量
     #+begin_src java :classname 
       class Solution {
           private int index = 0;

           public String decodeString(String s) {
               return helper(s);
           }

           private String helper(String s) {
               StringBuilder res = new StringBuilder();
               int multi = 0;
               while (index < s.length()) {
                   char cur = s.charAt(index);
                   if (cur >= '0' && cur <= '9') multi = multi*10 + cur - '0';
                   else if (cur == '[') {
                       index += 1;
                       String tmp = helper(s);
                       while (multi > 0) {
                           res.append(tmp);
                           multi--;
                       }
                   } else if (cur == ']') {
                       return res.toString();
                   } else res.append(String.valueOf(cur));
                   index++;
               }
               return res.toString();
           }
       }
     #+end_src
   - 无成员变量
     #+begin_src java :classname 
       class Solution {
           public String decodeString(String s) {
               return helper(s, 0)[0];
           }

           private String[] helper(String s, int i) {
               StringBuilder res = new StringBuilder();
               int multi = 0;
               while (i < s.length()) {
                   char cur = s.charAt(i);
                   if (cur >= '0' && cur <= '9') multi = multi*10 + cur - '0';
                   else if (cur == '[') {
                       String[] tmp = helper(s, i+1);
                       i = Integer.parseInt(tmp[0]);
                       while (multi > 0) {
                           res.append(tmp[1]);
                           multi--;
                       }
                   } else if (cur == ']') {
                       return new String[] {String.valueOf(i), res.toString()};
                   } else res.append(String.valueOf(cur));
                   i++;
               }
               return new String[] {res.toString()};
           }
       }
     #+end_src 
* 395 至少有K个重复字符的最长子串
  #+begin_src java :classname 
    class Solution {
        public int longestSubstring(String s, int k) {

        }
    }
  #+end_src 
* 399 除法求值                                       :图:BFS:DFS:递归:并查集:
** 并查集 
   #+begin_src java :classname 
     class Solution {
         private Map<String, String> parents = new HashMap<>();
         private Map<String, Double> values = new HashMap<>();
         public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
             double[] res = new double[queries.size()];
             Arrays.fill(res, -1);
             for (int i = 0; i < values.length; i++) {
                 List<String> equation = equations.get(i);
                 String parent = equation.get(0);
                 String child = equation.get(1);
                 double val = values[i];
                 union(parent, child, val);
             }

             for (int i = 0; i < res.length; i++) {
                 List<String> query = queries.get(i);
                 String parent = query.get(0);
                 String child = query.get(1);
                 if (parents.containsKey(parent) &&
                     parents.containsKey(child) &&
                     root(parent).equals(root(child))) {
                     res[i] = pm(child) / pm(parent);
                 }
             }
             return res;
         }

         private void union(String parent, String child, double value) {
             add(parent);
             add(child);
             String rp = root(parent);
             String rc = root(child);
             if (!rp.equals(rc)) {
                 parents.put(rc, rp);
                 values.put(rc, value*pm(parent)/pm(child));
             }
         }

         private String root(String child) {
             // while (!parents.get(child).equals(child)) child = parents.get(child);
             // return child;
             return parents.get(child).equals(child) ? child : root(parents.get(child));
         }

         private void add(String child) {
             if (!parents.containsKey(child)) {
                 parents.put(child, child);
                 values.put(child,1.0);
             }
         }

         private double pm(String child) {
             // double val = 1;
             // String rc = root(child);
             // while (!rc.equals(child)) {
             //     val *= values.get(child);
             //     child = parents.get(child);
             // }
             // return val;

             return root(child).equals(child) ? 1 : values.get(child) * pm(parents.get(child));
         }
     }
   #+end_src 
** DFS                                                           :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {

         HashMap<String, List<Edge>> mEdges = new HashMap<>();
         double[] mRes;

         public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
             // 1. 构建加权有向图
             for (int i = 0; i < equations.size(); i++) {
                 List<String> edge = equations.get(i);
                 String v1 = edge.get(0);
                 String v2 = edge.get(1);
                 double val = values[i];
                 // 添加到 v1->v2 的边
                 List<Edge> v1Edges = mEdges.get(v1);
                 if (v1Edges == null) {
                     v1Edges = new ArrayList<>();
                     mEdges.put(v1, v1Edges);
                 }
                 v1Edges.add(new Edge(v1, v2, val));
                 // 添加到 v2->v1 的边
                 List<Edge> v2Edges = mEdges.get(v2);
                 if (v2Edges == null) {
                     v2Edges = new ArrayList<>();
                     mEdges.put(v2, v2Edges);
                 }
                 v2Edges.add(new Edge(v2, v1, 1.0 / val));
             }

             // 2. dfs 搜索数据
             mRes = new double[queries.size()];
             List<String> visited = new ArrayList<>();
             for (int i = 0; i < queries.size(); i++) {
                 List<String> query = queries.get(i);
                 String start = query.get(0);
                 String dest = query.get(1);
                 visited.clear();
                 mRes[i] = dfs(start, dest, visited);
             }
             return mRes;
         }

         private double dfs(String start, String dest, List<String> visited) {
             // 验证是否存顶点
             if (!mEdges.containsKey(start) || !mEdges.containsKey(dest)) {
                 return -1.0;
             }
             visited.add(start);
             if (start.equals(dest)) {
                 return 1.0;
             }
             // 获取 start 顶点的边
             List<Edge> startEdges = mEdges.get(start);
             if (startEdges == null || startEdges.isEmpty()) {
                 return -1.0;
             }
             // 深度优先遍历集合
             for (Edge edge : startEdges) {
                 if (visited.contains(edge.to)) {
                     continue;
                 }
                 double res = dfs(edge.to, dest, visited);
                 if (res != -1.0) {
                     return res * edge.val;
                 }
             }
             return -1.0;
         }

         class Edge {
             String from;
             String to;
             double val;

             public Edge(String from, String to, double val) {
                 this.from = from;
                 this.to = to;
                 this.val = val;
             }
         }

     }
   #+end_src 
** BFS                                                           :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         //双向路径
         private Map<String, Map<String, Double>> cache = new HashMap<String, Map<String, Double>>();

         class Strdou {//放入队列的元素，
             public String x;    //除数
             public Double val;  //当前值
             public Strdou(String xx, Double cc) {
                 x = xx;
                 val = cc;
             }
         }

         private double BFS(List<String> query)
         {
             if (!cache.containsKey(query.get(0))||!cache.containsKey(query.get(1))) { //不可达
                 return -1.0;
             }
             if (query.get(0).equals(query.get(1))) {    //相等返回1
                 return 1.0;
             }
             Queue<Strdou> que = new LinkedList<Strdou>();
             Set<String> paths = new HashSet<String>();  //记录已经走过的点
             que.offer(new Strdou(query.get(0), 1.0));
             paths.add(query.get(0));

             while (!que.isEmpty()) {
                 Strdou s = que.poll();
                 Map<String, Double> c = cache.get(s.x);
                 //从key点开始遍历周围的点
                 for (String key : c.keySet()) {
                     if (paths.contains(key)) {
                         continue;
                     }
                     paths.add(key);//标记走过
                     que.offer(new Strdou(key, s.val * c.get(key)));
                     if (key.equals(query.get(1))) {
                         return s.val * c.get(key);
                     }
                 }
             }
             return -1.0;


         }

         public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
             if (queries.size() == 0) {  //别算了
                 return null;
             }
             for (int i = 0; i < equations.size(); i++) {
                 String first = equations.get(i).get(0);
                 String second = equations.get(i).get(1);
                 //保存正向的路径    a / b
                 if (cache.containsKey(first)) {
                     cache.get(first).put(second, values[i]);
                 }
                 else {
                     Map<String, Double> c = new HashMap<String, Double>();
                     c.put(second, values[i]);
                     cache.put(first, c);
                 }
                 //保存逆向的路径    b / a
                 if (cache.containsKey(second)) {
                     cache.get(second).put(first, 1.0 / values[i]);
                 }
                 else {
                     Map<String, Double> c = new HashMap<String, Double>();
                     c.put(first, 1.0 / values[i]);
                     cache.put(second, c);
                 }
             }

             double[] res = new double[queries.size()];

             for (int i = 0; i < res.length; i++) {
                 res[i] = BFS(queries.get(i));
             }
             return res;
         }
     }
   #+end_src 
** Floyd-Warsheall                                               :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
             final double INF=Integer.MAX_VALUE;
             int len=values.length,max=0;
             HashMap<String, Integer> hash = new HashMap<String, Integer>();
             for (int i=0;i<len;i++){
                 String c1=equations.get(i).get(0),c2=equations.get(i).get(1);
                 if(!hash.containsKey(c1))
                     hash.put(c1, max++);
                 if(!hash.containsKey(c2))
                     hash.put(c2, max++);
             }
             double[][] map =new double[max][max];
             for (int i=0;i<len;i++) {
                 int c1=hash.get(equations.get(i).get(0)),c2=hash.get(equations.get(i).get(1));
                 map[c1][c2]=values[i];
                 map[c2][c1]=1/values[i];
             } 
             for (int k = 0; k < max; k++) {
                 for (int i = 0; i < max; i++) {
                     for (int j = 0; j < max; j++) {
                         if(i!=j&&map[i][j]==0&&map[k][j]!=0&&map[i][k]!=0)
                             map[i][j]=map[k][j]*map[i][k];
                     }
                 }
             }
           
             double[] arr=new double[queries.size()];
             int index=0;
             for (List<String> ds : queries) {
                 if(!hash.containsKey(ds.get(0))||!hash.containsKey(ds.get(1)))
                     {
                         arr[index++]=-1;continue;
                     }
                 int c1=hash.get(ds.get(0));
                 int c2=hash.get(ds.get(1));
                 if(c1==c2)
                     arr[index++]=1;
                 else if(map[c1][c2]==0)
                     arr[index++]=-1;
                 else
                     arr[index++]=map[c1][c2];
             }
           
             return arr;
         }
     }
   #+end_src 
* 406 根据身高重建队列                              :贪婪:排序:二维数组:数组:
** 贪婪
   #+begin_src java :classname 
     class Solution {
         public int[][] reconstructQueue(int[][] people) {
             // Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
             Arrays.sort(people, new Comparator<int[]>() {
                     @Override
                     public int compare(int[] o1, int[] o2) {
                         return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];
                     }
                 });
             List<int[]> res = new LinkedList<>();
             for (int[] i : people) {
                 res.add(i[1], i);
             }
             return res.toArray(new int[people.length][2]);
         }
     }
   #+end_src 
* 407 接雨水 II                                                  :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int trapRainWater(int[][] heightMap) {

        }
    }
  #+end_src 
* 412 Fizz Buzz
  #+begin_src java :classname 
    class Solution {
        public List<String> fizzBuzz(int n) {
            List<String> res = new LinkedList<>();
            for (int i = 1; i <= n; i++) {
                switch (helper(i)) {
                case 0:
                    res.add("FizzBuzz");
                    break;
                case 1:
                    res.add("Fizz");
                    break;
                case 2:
                    res.add("Buzz");
                    break;
                case 3:
                    res.add(String.valueOf(i));
                    break;
                }
            }
            return res;
        }

        private int helper(int n) {
            if (n % 3 == 0 && n % 5 == 0) return 0;
            else if (n % 3 == 0) return 1;
            else if (n % 5 == 0) return 2;
            else return 3;
        }
    }
  #+end_src 
* 416 分割等和子集
** DP
   - 二维
     #+begin_src java :classname 
       class Solution {
           public boolean canPartition(int[] nums) {
               int len = nums.length;
               if (len == 0) return false;
               int sum = 0;
               for (int num : nums) sum += num;
               if ((sum&1) == 1) return false;
               int target = sum >> 1;
               boolean[][] res = new boolean[len][target+1];
               res[0][0] = true;
               if (nums[0] == target) res[0][nums[0]] = true;
               for (int i = 1; i < len; i++) {
                   for (int j = 1; j <= target; j++) {
                       res[i][j] = res[i-1][j];
                       if (nums[i] <= j) res[i][j] = res[i][j] || res[i-1][j-nums[i]];
                       if (res[i][target]) return true;
                   }
               }
               return res[len-1][target];
           }
       }
     #+end_src
   - 一维(空间优化，倒序遍历)
     #+begin_src java :classname 
       class Solution {
           public boolean canPartition(int[] nums) {
               int len = nums.length;
               if (len == 0) return false;
               int sum = 0;
               for (int num : nums) sum += num;
               if ((sum&1) == 1) return false;
               int target = sum >> 1;
               boolean[] res = new boolean[target+1];
               res[0] = true;
               if (nums[0] == target) res[nums[0]] = true;
               for (int i = 1; i < len; i++) {
                   for (int j = target; j >= nums[i]; j--) {
                       if (res[target]) return true;
                       res[j] = res[j] || res[j-nums[i]];
                   }
               }
               return res[target];
           }
       }
     #+end_src 
** 递归                                                          :UNRESOLVED:
   - 两路递归
     #+begin_src java :classname 
       class Solution {
           private int target = 0;
           public boolean canPartition(int[] nums) {
               int len = nums.length;
               if (len == 0) return false;
               int sum = 0;
               for (int num : nums) sum += num;
               if ((sum&1) == 1) return false;
               target = sum >> 1;
               return helper(nums, len-1, 0, 0);
           }

           private boolean helper(int[] nums, int index, int left, int right) {
               if (left == target || right == target) return true;
               if (left > target || right > target) return false;
               boolean res = helper(nums, index-1, left+nums[index], right);
               if (res) return true;
               res = helper(nums, index-1, left, right+nums[index]);
               return res;
           }
       }
     #+end_src
   - 回溯
     #+begin_src java :classname 
       class Solution {
           public boolean canPartition(int[] nums) {
               int len = nums.length;
               if (len == 0) return false;
               int sum = 0;
               for (int num : nums) sum += num;
               if ((sum&1) == 1) return false;
               target = sum >> 1;
               return helper(nums, len-1, 0, 0);
           }

           private boolean helper(int[] nums, )
       }
     #+end_src
* 437 路径总和3 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink28>>][offer26]]                          :回溯:递归:前缀和:二叉树:树:
** 双重递归
*** 暴力
    #+begin_src java :classname 
      class Solution {
          public int pathSum(TreeNode root, int sum) {
              if (root == null) return 0;
              return helper(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
          }

          private int helper(TreeNode root, int sum) {
              if (root == null) return 0;
              int count = 0;
              sum -= root.val;
              if (sum == 0) count += 1;
              count += helper(root.left, sum);
              count += helper(root.right, sum);
              return count;
          }
      }
    #+end_src 
*** 前缀和 <<ilink4>>
    #+begin_src java :classname 
      class Solution {
          public int pathSum(TreeNode root, int sum) {
              if (root == null) return 0;
              Map<Integer, Integer> prefix = new HashMap<>();
              prefix.put(0, 1);
              return helper(root, sum, prefix, 0);
          }

          private int helper(TreeNode root, int sum, Map<Integer, Integer> prefix, int currSum) {
              if (root == null) return 0;
              currSum += root.val;
              int count = 0;
              count += prefix.getOrDefault(currSum-sum, 0);
              int pre = prefix.getOrDefault(currSum, 0);
              prefix.put(currSum, pre+1);
              count += helper(root.left, sum, prefix, currSum);
              count += helper(root.right, sum, prefix, currSum);
              prefix.put(currSum, pre);
              return count;
          }
      }
    #+end_src 
* 438 找到字符串中所有字母异位词                     :滑动窗口:双指针:字符串:
** 滑动窗口
   #+begin_src java :classname 
     class Solution {
         public List<Integer> findAnagrams(String s, String p) {
             List<Integer> res = new ArrayList<>();
             if (s == null || p == null || s.length() < p.length()) return res;
             char[] chs = s.toCharArray(), chp = p.toCharArray();
             int left = 0, right = 0;
             int[] needs = new int[26];
             int[] window = new int[26];
             for (char ch : chp) {
                 needs[ch-'a']++;
             }
             while (right < chs.length) {
                 int curR = chs[right] - 'a';
                 window[curR]++;
                 right++;
                 while (window[curR] > needs[curR]) {
                     window[chs[left]-'a']--;
                     left++;
                 }
                 if (right-left == chp.length) res.add(left);
             }
             return res;
         }
     }
   #+end_src 
* 448 找到所有数组中消失的数字                                    :查找:数组:
  #+begin_src java :classname 
    class Solution {
        public List<Integer> findDisappearedNumbers(int[] nums) {
            List<Integer> res = new ArrayList<>();
            for (int i = 0; i < nums.length; i++) {
                int cur = Math.abs(nums[i]) - 1;
                if (nums[cur] < 0) continue;
                nums[cur] = -nums[cur];
            }
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] > 0) res.add(i+1);
            }
            return res;
        }
    }
  #+end_src 
* 454 四数相加 II
  #+begin_src java :classname 
    class Solution {
        public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {

        }
    }
  #+end_src 
* 461 汉明距离                                                       :位运算:
  #+begin_src java :classname 
    class Solution {
        public int hammingDistance(int x, int y) {
            int dis = 0;
            while (x != 0 || y != 0) {
                dis += (x&1) ^ (y&1);
                x >>= 1;
                y >>= 1;
            }
            return dis;
        }
    }
  #+end_src 

* 494 目标和
** DP
*** 转化为背包思路
    - 二维
      #+begin_src java :classname 
        class Solution {
            public int findTargetSumWays(int[] nums, int S) {
                int sum = 0, len = nums.length;
                for (int num : nums) sum += num;
                if (sum < S || ((sum+S)&1) == 1) return 0;
                int p = (sum+S) >> 1;
                int[][] dp = new int[len+1][p+1];
                dp[0][0] = 1;
                for (int i = 1; i <= len; i++) {
                    for (int j = 0; j <= p; j++) {
                        dp[i][j] = dp[i-1][j];
                        if (j >= nums[i-1]) dp[i][j] += dp[i-1][j-nums[i-1]];
                    }
                }
                return dp[len][p];
            }
        }
      #+end_src
    - 一维
      #+begin_src java :classname 
        class Solution {
            public int findTargetSumWays(int[] nums, int S) {
                int sum = 0, len = nums.length;
                for (int num : nums) sum += num;
                if (sum < S || ((sum+S)&1) == 1) return 0;
                int p = (sum+S) >> 1;
                int[] dp = new int[p+1];
                dp[0] = 1;
                for (int num : nums) {
                    for (int i = p; i >= num; i--) {
                        dp[i] += dp[i-num];
                    }
                }
                return dp[p];
            }
        }
      #+end_src
*** DFS思路                                                      :UNRESOLVED:
    #+begin_src java :classname 
      class Solution {
          public static int findTargetSumWays(int[] nums, int s) {
              int sum = 0;
              for (int i = 0; i < nums.length; i++) {
                  sum += nums[i];
              }
              // 绝对值范围超过了sum的绝对值范围则无法得到
              if (Math.abs(s) > Math.abs(sum)) return 0;

              int len = nums.length;
              // - 0 +
              int t = sum * 2 + 1;
              int[][] dp = new int[len][t];
              // 初始化
              if (nums[0] == 0) {
                  dp[0][sum] = 2;
              } else {
                  dp[0][sum + nums[0]] = 1;
                  dp[0][sum - nums[0]] = 1;
              }

              for (int i = 1; i < len; i++) {
                  for (int j = 0; j < t; j++) {
                      // 边界
                      int l = (j - nums[i]) >= 0 ? j - nums[i] : 0;
                      int r = (j + nums[i]) < t ? j + nums[i] : 0;
                      dp[i][j] = dp[i - 1][l] + dp[i - 1][r];
                  }
              }
              return dp[len - 1][sum + s];
          }
      }
    #+end_src 
** DFS
   #+begin_src java :classname 
     class Solution {
         public int findTargetSumWays(int[] nums, int S) {
             return helper(nums, 0, S);
         }

         private int helper(int[] nums, int start, int S) {
             if (start == nums.length) {
                 return S == 0 ? 1 : 0;
             }
             return helper(nums, start+1, S+nums[start]) + helper(nums, start+1, S-nums[start]);
         }
     }
   #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 怎么记忆化or优化剪枝?
* 516 最长回文子序列                                       :DP:子序列:字符串:
  #+begin_src java :classname 
    class Solution {
        public int longestPalindromeSubseq(String s) {
            if (s == null || s.length() == 0) return 0;
            int len = s.length();
            int[][] res = new int[len][len];
            for (int i = 0; i < len; i++) {
                res[i][i] = 1;
            }
            for (int i = len-2; i >= 0; i--) {
                for (int j = i+1; j < len; j++) {
                    if (s.charAt(i) == s.charAt(j)) res[i][j] = res[i+1][j-1] + 2;
                    else res[i][j] = Math.max(res[i][j-1], res[i+1][j]);
                }
            }
            return res[0][len-1];
        }
    }
  #+end_src 
* 538 把二叉搜索树转换为累加树              :递归:中序遍历:二叉搜索树:二叉树:
** 中序遍历
*** 递归
    #+begin_src java :classname 
      class Solution {
          private int sum = 0;
          public TreeNode convertBST(TreeNode root) {
              helper(root);
              return root;
          }

          private void helper(TreeNode root) {
              if (root == null) return;
              helper(root.right);
              root.val += sum;
              sum = root.val;
              helper(root.left);
          }
      }
    #+end_src 
*** 迭代
    #+begin_src java :classname 
      class Solution {
          private int sum = 0;
          public TreeNode convertBST(TreeNode root) {
              if (root == null) return root;
              Stack<TreeNode> st = new Stack();
              TreeNode cur = root;
              int sum = 0;
              while (!st.empty() || cur != null) {
                  if (cur != null) {
                      st.push(cur);
                      cur = cur.right;
                  } else {
                      cur = st.pop();
                      cur.val += sum;
                      sum = cur.val;
                      cur = cur.left;
                  }
              }
              return root;
          }
      }
    #+end_src 
* 543 二叉树的直径  [[file:~/csnds/Dropbox/orglife/offer.org::<<elink13>>][offer55]]                                     :递归:二叉树:
** 递归
*** 前序更新(自顶而下 双重重复递归)
    #+begin_src java :classname 
      class Solution {
          public int diameterOfBinaryTree(TreeNode root) {
              if (root == null) return 0;
              return max(maxDepth(root.left) + maxDepth(root.right), diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right));
          }

          private int maxDepth(TreeNode root) {
              if (root == null) return 0;
              int left = maxDepth(root.left), right = maxDepth(root.right);
              return left > right ? left+1 : right+1;
          }

          private int max(int x, int y, int z) {
              int max = x > y ? x : y;
              return max > z ? max : z;
          }
      }
    #+end_src 
*** 后序更新(自底而上)]
    #+begin_src java :classname 
      class Solution {
          private int diameter = 0;
          public int diameterOfBinaryTree(TreeNode root) {
              depth(root);
              return diameter;
          }

          private int depth(TreeNode root) {
              if (root == null) return 0;
              int left = depth(root.left), right = depth(root.right);
              diameter = diameter > left+right ? diameter : left+right;
              return left > right ? left+1 : right+1;
          }
      }
    #+end_src 
* 560 和为K的子数组                                             :前缀和:数组:
** 暴力
   #+begin_src java :classname 
     public class Solution {
         public int subarraySum(int[] nums, int k) {
             int count = 0;
             for (int start = 0; start < nums.length; start++) {
                 int sum = 0;
                 for (int end = start; end < nums.length; end++) {
                     sum += nums[end];
                     if (sum == k) {
                         count++;
                     }
                 }
             }
             return count;
         }
     }
   #+end_src 
** 前缀和+哈希优化 [[ilink4][437 路径总和3]]
   #+begin_src java :classname 
     public class Solution {
         public int subarraySum(int[] nums, int k) {
             int res = 0, preSum = 0;
             Map<Integer, Integer> map = new HashMap();
             map.put(0, 1);
             for (int num : nums) {
                 preSum += num;
                 if (map.containsKey(preSum-k)) {
                     res += map.get(preSum-k);
                 }
                 map.put(preSum, map.getOrDefault(preSum, 0)+1);
             }
             return res;
         }
     }
   #+end_src 
* 581 最短无序连续子数组                                        :双指针:数组:
  #+begin_src java :classname 
    class Solution {
        public int findUnsortedSubarray(int[] nums) {
            int len = nums.length;
            int left = len-1, right = 0;
            int max = nums[right], min = nums[left];
            for (int i = 0; i < len; i++) {
                if (max <= nums[i]) max = nums[i];
                else right = i;
                if (min >= nums[len-1-i]) min = nums[len-1-i];
                else left = len-1-i;
            }
            return right > left ? right-left+1 : 0;
        }
    }
  #+end_src 
* 617 合并二叉树                                             :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
            if (t1 == null) return t2;
            if (t2 == null) return t1;
            t1.val += t2.val;
            t1.left = mergeTrees(t1.left, t2.left);
            t1.right = mergeTrees(t1.right, t2.right);
            return t1;
        }
    }
  #+end_src 
* 621 任务调度器                                                  :排序:数组:
** 设计
   - 根据是否剩余判断
     #+begin_src java :classname 
       class Solution {
           public int leastInterval(char[] tasks, int n) {
               int[] map = new int[26];
               for (char ch : tasks) map[ch-'A']++;
               Arrays.sort(map);
               int max_slots = map[25]-1, res_slots = max_slots*n;
               for (int i = 24; i >= 0 && map[i] > 0; i--) res_slots -= Math.min(map[i], max_slots);
               return res_slots > 0 ? res_slots+tasks.length : tasks.length;
           }
       }
     #+end_src
   - 直接根据最小长度与任务总数判断
     #+begin_src java :classname 
       class Solution {
           public int leastInterval(char[] tasks, int n) {
               int[] map = new int[26];
               for (char ch : tasks) map[ch-'A']++;
               Arrays.sort(map);
               int max = map[25], least = (max-1)*(n+1) + 1;
               int i = 24;
               while (i >= 0 && map[i] == max) {
                   least++;
                   i--;
               }
               return Math.max(least, tasks.length);
           }
       }
     #+end_src 
** 排序                                                          :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int leastInterval(char[] tasks, int n) {
             int[] map = new int[26];
             for (char ch : tasks) map[ch-'A']++;
             Arrays.sort(map);
             int time = 0;
             while (map[25] > 0) {
                 int i = 0;
                 while (i <= n) {
                     if (map[25] == 0) break;
                     if (i < 26 && map[25-i] > 0) map[25-i]--;
                     time++;
                     i++;
                 }
                 Arrays.sort(map);
             }
             return time;
         }
     }
   #+end_src
* 637 二叉树的层平均值                                           :UNRESOLVED:
*** DFS
*** BFS
* 647 回文子串                           :DP:扩展窗口:双指针:中心扩展:字符串:
** 中心扩展 [[ilink5][5 最长回文子串]]
   #+begin_src java :classname 
     class Solution {
         private int count = 0;
         public int countSubstrings(String s) {
             char[] chs = s.toCharArray();
             for (int i = 0; i < chs.length; i++) {
                 expand(chs, i, i);
                 expand(chs, i, i+1);
             }
             return count;
         }

         public void expand(char[] chs, int left, int right) {
             while (left >= 0 && right < chs.length) {
                 if (chs[left] != chs[right]) break;
                 left--;
                 right++;
                 count++;
             }
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         private int count = 0;
         public int countSubstrings(String s) {
             int len = s.length();
             boolean[][] dp = new boolean[len][len];
             int res = 0;
             for (int j = 0; j < len; j++) {
                 for (int i = 0; i <=j; i++) {
                     if (s.charAt(i) == s.charAt(j)) {
                         if (j-i <= 1 || dp[i+1][j-1]) {
                             res++;
                             dp[i][j] = true;
                         }
                     }
                 }
             }
             return res;
         }
     }
   #+end_src 
** 马拉车                                                        :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int countSubstrings(String S) {
             char[] A = new char[2 * S.length() + 3];
             A[0] = '@';
             A[1] = '#';
             A[A.length - 1] = '$';
             int t = 2;
             for (char c: S.toCharArray()) {
                 A[t++] = c;
                 A[t++] = '#';
             }

             int[] Z = new int[A.length];
             int center = 0, right = 0;
             for (int i = 1; i < Z.length - 1; ++i) {
                 if (i < right)
                     Z[i] = Math.min(right - i, Z[2 * center - i]);
                 while (A[i + Z[i] + 1] == A[i - Z[i] - 1])
                     Z[i]++;
                 if (i + Z[i] > right) {
                     center = i;
                     right = i + Z[i];
                 }
             }
             int ans = 0;
             for (int v: Z) ans += (v + 1) / 2;
             return ans;
         }
     }
   #+end_src 
* 739 每日温度                                               :单调栈:栈:数组:
** 暴力优化
   - 理解错误(离最高温的天数)
     #+begin_src java :classname 
       class Solution {
           public int[] dailyTemperatures(int[] T) {
               int[] res = new int[T.length];
               int maxT = Integer.MIN_VALUE, index = res.length-1;
               for (int i = res.length-1; i >= 0; i--) {
                   if (T[i] >= maxT) {
                       maxT = T[i];
                       res[i] = 0;
                       index = i;
                   } else {
                       res[i] = index-i;
                   }
               }
               return res;
           }
       }
     #+end_src
   - 从后向前遍历
     #+begin_src java :classname 
       class Solution {
           public int[] dailyTemperatures(int[] T) {
               int len = T.length;
               int[] res = new int[len];
               for (int i = len-2; i >= 0; i--) {
                   for (int j = i+1; j < len; j += res[j]) {
                       if (T[j] > T[i]) {
                           res[i] = j - i;
                           break;
                       }
                       if (res[j] == 0) {
                           res[i] = 0;
                           break;
                       }
                   }
               }
               return res;
           }
       }
     #+end_src
** 单调栈
   #+begin_src java :classname 
     class Solution {
         public int[] dailyTemperatures(int[] T) {
             int[] res = new int[T.length];
             Deque<Integer> st = new LinkedList<>();
             for (int i = 0; i < res.length; i++) {
                 while (!st.isEmpty() && T[st.peek()] < T[i]) {
                     res[st.peek()] = i - st.pop();
                 }
                 st.push(i);
             }
             return res;
         }
     }
   #+end_src 
* 673 最长递增子序列的个数                            :线段树:DP:子序列:数组:
** DP
   #+begin_src java :classname 
     class Solution {
         public int findNumberOfLIS(int[] nums) {
             if (nums == null || nums.length == 0) return 0;
             int maxLen = 1;
             int[] len = new int[nums.length];
             len[0] = 1;
             int[] count = new int[nums.length];
             Arrays.fill(count, 1);
             for (int i = 1; i < nums.length; i++) {
                 int prevMaxLen = 0;
                 for (int j = 0; j < i; j++) {
                     if (nums[j] < nums[i]) {
                         if (prevMaxLen < len[j]) {
                             prevMaxLen = len[j];
                             count[i] = count[j];
                         } else if (prevMaxLen == len[j]) {
                             count[i] += count[j];
                         }
                     }
                 }
                 len[i] = prevMaxLen + 1;
                 if (maxLen < len[i]) maxLen = len[i];
             }
             int res = 0;
             for (int i = 0; i < nums.length; i++) {
                 if (maxLen == len[i]) res += count[i];
             }
             return res;
         }
     }
   #+end_src 
** 线段树                                                        :UNRESOLVED:
* 674 最长连续递增序列                                          :子序列:数组:
  #+begin_src java :classname 
    class Solution {
        public int findLengthOfLCIS(int[] nums) {
            if (nums == null) return 0;
            int max = 0, i = 0;
            while (i < nums.length) {
                int cur = 1;
                while (i+1 < nums.length && nums[i] < nums[i+1]) {
                    cur += 1;
                    i += 1;
                }
                if (max < cur) max = cur;
                i += 1;
            }
            return max;
        }
    }
  #+end_src 
* 765 情侣牵手                                                    :贪婪:数组:
  #+begin_src java :classname 
    class Solution {
        public int minSwapsCouples(int[] row) {
            int len = row.length, res = 0;
            int[] map = new int[len];
            for (int i = 0; i < len; i++) map[row[i]] = i;
            for (int i = 0; i < len; i += 2) {
                int x = row[i] ^ 1;
                if (x == row[i+1]) continue;
                res += 1;
                int j = map[x];
                row[j] = row[i+1];
                row[i+1] = x;
                map[x] = i+1;
                map[row[j]] = j;
            }
            return res;
        }
    }
  #+end_src 
* 803 打砖块                                                        :TOBEORG:
  #+begin_src java :classname 
    public class Solution {

        public int[] hitBricks(int[][] grid, int[][] hits) {
            // TODO
            if (grid == null || grid.length == 0 || grid[0].length == 0) return null;
            if (hits == null || hits.length == 0 || hits[0].length != 2) return null;
            int row = grid.length, col = grid[0].length, hitsNum = hits.length;
            for (int[] dart: hits) {
                if (dart[0] < 0 || dart[0] >= row ||
                        dart[1] < 0 || dart[1] >= col) return null;
            }

            int[] ur = {1, 0, -1, 0};
            int[] uc = {0, 1, 0, -1};
            int root = row * col;
            UnionFind union = new UnionFind(root + 1);
            int[][] copy = new int[row][col];

            for (int i = 0; i < row; i++) {
                copy[i] = grid[i].clone();
            }

            for (int[] dart: hits) {
                copy[dart[0]][dart[1]] = 0;
            }

            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (copy[i][j] == 1) {
                        if (i == 0) {
                            union.union(xyToint(col, i, j), root);
                            continue;
                        }
                        if (i - 1 >= 0 && copy[i-1][j] == 1) {
                            union.union(xyToint(col, i, j), xyToint(col, i-1, j));
                        }
                        if (j - 1 >= 0 && copy[i][j-1] == 1) {
                            union.union(xyToint(col, i, j), xyToint(col, i, j-1));
                        }
                    }
                }
            }


            int[] bubbles = new int[hitsNum];

            for (int i = hitsNum - 1; i >= 0; i--) {
                int afterPop = union.sizeOf(root);
                int r = hits[i][0];
                int c = hits[i][1];
                if (grid[r][c] == 0) continue;
                if (r == 0) union.union(xyToint(col, r, c), root);
                for (int j = 0; j < 4; j++) {
                    int nr = r + ur[j];
                    int nc = c + uc[j];
                    if (nr >= 0 && nr < row &&
                            nc >=0 && nc < col && copy[nr][nc] == 1) {
                        union.union(xyToint(col, r, c), xyToint(col, nr, nc));
                    }
                }
                int pops = union.sizeOf(root) - afterPop - 1;
                bubbles[i] = pops > 0 ? pops : 0;
                copy[r][c] = 1;
            }
            return bubbles;
        }


        private int xyToint(int col, int r, int c) {
            return r * col + c;
        }

    }


    class UnionFind {

        private int[] vertice;

        // TODO - Add instance variables?

        /* Creates a UnionFind data structure holding n vertices. Initially, all
           vertices are in disjoint sets. */
        public UnionFind(int n) {
            // TODO
            vertice = new int[n];
            for (int i = 0; i < n; i++) {
                vertice[i] = -1;
            }
        }

        /* Throws an exception if v1 is not a valid index. */
        private void validate(int vertex) {
            // TODO
            if (vertex < 0 || vertex >= this.vertice.length) {
                throw new IllegalArgumentException(vertex
                        + "is not a valid index.");
            }
        }

        /* Returns the size of the set v1 belongs to. */
        public int sizeOf(int v1) {
            // TODO
            return - vertice[find(v1)];
        }

        /* Returns the parent of v1. If v1 is the root of a tree, returns the
           negative size of the tree for which v1 is the root. */
        public int parent(int v1) {
            // TODO
            return vertice[v1] < 0 ? v1 : vertice[v1];
        }

        /* Returns true if nodes v1 and v2 are connected. */
        public boolean connected(int v1, int v2) {
            // TODO
            int r1 = find(v1);
            int r2 = find(v2);
    //        int p1 = parent(v1);
    //        int p2 = parent(v2);
    //
    //        while (p1 != r1) {
    //            vertice[v1] = r1;
    //            v1 = p1;
    //            p1 = parent(v1);
    //        }
    //        while (p2 != r2) {
    //            vertice[v2] = r2;
    //            v2 = p2;
    //            p2 = parent(v2);
    //        }

            return r1 == r2;
        }

        /* Connects two elements v1 and v2 together. v1 and v2 can be any valid
           elements, and a union-by-size heuristic is used. If the sizes of the sets
           are equal, tie break by connecting v1's root to v2's root. Unioning a 
           vertex with itself or vertices that are already connected should not 
           change the sets but may alter the internal structure of the data. */
        public void union(int v1, int v2) {
            // TODO
            validate(v1);
            validate(v2);
            if (!connected(v1, v2)) {
                if (sizeOf(v1) <= sizeOf(v2)) {
                    vertice[find(v2)] += vertice[find(v1)];
                    vertice[find(v1)] = find(v2);
                } else {
                    vertice[find(v1)] += vertice[find(v2)];
                    vertice[find(v2)] = find(v1);
                }
            }
        }

        /* Returns the root of the set V belongs to. Path-compression is employed
           allowing for fast search-time. */
        public int find(int vertex) {
            // TODO
            return vertice[vertex] < 0 ? vertex : find(parent(vertex));
        }

        public int[] getSet() {
            return vertice;
        }
    }
  #+end_src 
* 1143 最长公共子序列                                      :DP:子序列:字符串:
  - 二维
    #+begin_src java :classname 
      class Solution {
          public int longestCommonSubsequence(String text1, String text2) {
              if (text1 == null || text2 == null) return 0;
              int len1 = text1.length()+1, len2 = text2.length()+1;
              int[][] res = new int[len1][len2];
              for (int i = 1; i < len1; i++) {
                  char ch1 = text1.charAt(i-1);
                  for (int j = 1; j < len2; j++) {
                      char ch2 = text2.charAt(j-1);
                      res[i][j] = ch1 == ch2 ? res[i-1][j-1]+1 : Math.max(res[i][j-1], res[i-1][j]);
                  }
              }
              return res[len1-1][len2-1];
          }
      }
    #+end_src
  - 一维(空间优化)
    - 按列
      #+begin_src java :classname 
        class Solution {
            public int longestCommonSubsequence(String text1, String text2) {
                if (text1 == null || text2 == null) return 0;
                int len1 = text1.length()+1, len2 = text2.length()+1;
                int[] res = new int[len1];
                for (int j = 1; j < len2; j++) {
                    char chj = text2.charAt(j-1);
                    int prev = 0;
                    for (int i = 1; i < len1; i++) {
                        char chi = text1.charAt(i-1);
                        int temp = res[i];
                        res[i] = chj == chi ? prev+1 : Math.max(res[i], res[i-1]);
                        prev = temp;
                    }
                }
                return res[len1-1];
            }
        }
      #+end_src
    - 按行
      #+begin_src java :classname 
        class Solution {
            public int longestCommonSubsequence(String text1, String text2) {
                if (text1 == null || text2 == null) return 0;
                int len1 = text1.length()+1, len2 = text2.length()+1;
                int[] res = new int[len2];
                for (int i = 1; i < len1; i++) {
                    char chi = text1.charAt(i-1);
                    int prev = 0;
                    for (int j = 1; j < len2; j++) {
                        char chj = text2.charAt(j-1);
                        int temp = res[j];
                        res[j] = chj == chi ? prev+1 : Math.max(res[j], res[j-1]);
                        prev = temp;
                    }
                }
                return res[len1-1];
            }
        }
      #+end_src
  - 最长公共子串
    #+begin_src java :classname 
      class Solution {
          public String longestCommonSubstring(String text1, String text2) {
              if (text1 == null || text2 == null) return 0;
              int end = 0, max = 0, len1 = text1.length(), len2 = text2.length();
              int[][] res = new int[len1+1][len2+1];
              for (int i = 1; i <= len1; i++) {
                  char ch1 = text1.charAt(i-1);
                  for (int j = 1; j <= len2; j++) {
                      char ch2 = text2.charAt(j-1);
                      res[i][j] = ch1 == ch2 ? res[i-1][j-1]+1 : 0;
                      if (res[i][j] > max) {
                          max = res[i][j];
                          end = i;
                      }
                  }
              }
              return text1.substring(end-max, end);
          }
      }
    #+end_src
** 583 1035
  

* 面试题
** 阿里
*** 无顺子的排列 
    #+begin_src java :classname 
      public int[] order(int n) {
          int[] res = new int[n+1];
          orderHelper(1, n, 0, res);
          return res;
      }

      private void orderHelper(int l, int r, int mark, int[] res) {
          if (l == r) {
              if (mark == 1) res[l] = 1;
              else res[l] = 2;
              return;
          }
          int mid = (l+r) >> 1;
          orderHelper(l, mid, 1, res);
          orderHelper(mid+1, r, 0, res);
          for (int i = l; i <= r; i++) res[i] = res[i] * 2 - mark;
          return;
      }
    #+end_src 
*** n城市m旅人
    #+begin_src java :classname 
      public String[] calcProbs(int n, int m) {
          int[] distances = new int[n];
          int[][] trips = new int[m][2];
          String[] res = new String[m];
          for (int i = 0; i < m; i++) {
              res[i] = calcProb(n, distances, trips[m]);
          }
      }

      private String calcProb(int n, int[] distances, int[] trip) {
          int start = trip[0], end = trip[1];
          int shorter = calcShorter(distances, start, end);
          int gcd = calcGcd(shorter, n);
          StringBuilder sb = new StringBuilder();
          sb.append(shorter/gcd);
          sb.append("/");
          sb.append(n/gcd);
          return sb.toString();
      }

      private int calcShorter(int[] distances, int start, int end) {
          int total = 0, path = 0;
          for (int i = 0; i < distances.length; i++) {
              total += distances[i];
          }
          if (start > end) {
              int temp = start;
              start = end;
              end = start;
          }
          for (int i = start; i < end; i++) {
              path += distances[i];
          }
          return total > 2*path ? end-start : distances.length-end+start;
      }

      private int calcGcd(int x, int y) {
          if (y % x == 0) return x;
          return calcGcd(x, y%x);
      }
    #+end_src 
** 美团
*** 1 单科成绩优秀奖的人数
    #+begin_src java :classname 

      import java.util.*;

      public class Main {
          public static void main(String[] args){
              Scanner cin = new Scanner(System.in);
              int N = cin.nextInt();
              int M = cin.nextInt();
              int[][] score = new int[N][M];
              int[] maxScore = new int[M];
              List<Set<Integer>> sets = new ArrayList<>();
              for (int i = 0; i < M; i++) sets.add(new HashSet<Integer>());
              Set<Integer> res = new HashSet<>();
              for(int i=0;i<N;i++){
                  for(int j=0;j<M;j++){
                      score[i][j] = cin.nextInt();
                      if (score[i][j] < maxScore[j]) continue;
                      if (score[i][j] > maxScore[j]) {
                          maxScore[j] = score[i][j];
                          sets.get(j).removeAll(sets.get(j));
                      }
                      sets.get(j).add(j);
                  }
              }
              for (int i = 0; i < M; i++) {
                  res.addAll(sets.get(i));
              }
              System.out.println(res.size());
          }
      }
    #+end_src 
*** 2 最短循环周期的长度
    #+begin_src java :classname 
      public int shortest(int a, int b, int m, int x) {
          int res = 0;
          long la = (long) a, lb = (long) b, lm = (long) m, lx = (long) x;
          long temp = lx;
          while (true) {
              res += 1;
              lx = (lx*la+lb) % lm;
              if (lx == temp) break;
          }
          return res;
      }
    #+end_src 
*** 3 第k小的数对
    #+begin_src java :classname 
      public static int[] kthMinPair2(int[] arr, int k) {
          int N = arr.length;
          if (k > N * N) {
              return null;
          }
          Arrays.sort(arr);
          int firstIndex = (k-1) / N;
          int firstNum = arr[firstIndex];
          int leftIndex = firstIndex;
          while (leftIndex >= 0 && arr[leftIndex] == firstNum) leftIndex -= 1;
          leftIndex += 1;
          int rightIndex = firstIndex;
          while (rightIndex < N && arr[rightIndex] == firstNum) rightIndex += 1;
          rightIndex -= 1;
          int afterk = k - leftIndex * N;
          int secondIndex = (afterk-1) / (rightIndex-leftIndex+1);
          int secondNum = arr[secondIndex];
          return new int[] {firstNum, secondNum};
       }
    #+end_src 
    #+begin_src java :classname 
      private class Pair implements Comparable {
          int x;
          int y;

          Pair(int p1, int p2) {
              x = p1;
              y = p2;
          }

          @Override
          int compareTo(Pair other) {
              if (p1.x == p2.x) return p2.y - p1.y;
              return p2.x - p1.y;
          }

          static class pairComparator implements Comparator<Pair> {
              int compare(Pair p1, Pair p2) {
                  return p2.compareTo(p1);
              }
          }
      }

      public int[] kthPair(int[] array, int k) {
          int len = array.length;
          PriorityQueue<Pair> pq = new PriorityQueue<>();
          for (int i = 0; i < len; i++) {
              for (int j = 0; j < len; j++) {
                  Pair p = new Pair(array[i], array[j]);
                  if (pq.size() < k) pq.offer(p);
                  else {
                      Pair curMax = pq.peek();
                      if (curMax.compareTo(p) < 0) {
                      // if (Pair.pairComparator.compare(p, curMax) < 0) {
                          pq.poll();
                          pq.offer(p);
                      }
                  }
              }
          }
          Pair kth = pq.peek();
          return new int[] {kth.x, kth.y};
      }
    #+end_src 
*** 4
*** 5 
** 快手
** 招行
*** 修塔游戏(网易秋招 塔) 
** 微软
*** 括号内字符串替换
    #+begin_src java :classname 
      private int index = 0;
      public List<String> replace(String s) {
          List<String> res = new ArrayList<>();
          replaceHelper(s, res);
          return res;
      }
   
      private void replaceHelper(String s, List<String> res) {
          if (index == s.length()) {
              res.add(s);
              return;
          }
          if (s.chatAt(index) != '{') {
              index += 1;
              replaceHelper(s, res);
          } else {
              int next = index+1;
              int left = 1, right = 0;
              while (next < s.length()) {
                  if (s.chatAt(next) == '{') left += 1;
                  if (s.chatAt(next) == '}') right += 1;
                  if (left == right) break;
                  next += 1;
              }
              if (next == s.length()) {
                  res.add(s);
                  return;
              } else {
                  if (!isValid(s.substring(index, next+1))) {
                      index = next+1;
                      replaceHelper(s, res);
                  }
                  else {
                      for (String str : getValue(s.substring(index, next+1), left, right)) {
                          StringBuilder sb = new StringBuilder;
                          sb.append(s.substring(0, index));
                          sb.append(str);
                          sb.append(s.substring(next+1, s.length()));
                          index += str.length();
                          replaceHelper(sb.toString(), res);
                      }
                  }
              }
          }
      }
   
      private List<String> getValue(String s, int left, int right) {
          List<String> list = new ArrayList<>();
          if (left == right && left == 1) {
              for (String str : GetValue(s.substring(1, s.length()-1))) {
                  list.add(str);
              }
          } else {
              int index1 = 1, index2 = s.length() - 2;
              while (s.substring(index1) != '{') index1 += 1;
              while (s.substring(index2) != '}') index2 += 1;
              StringBuilder sb = new StringBuilder;
              sb.append(s.substring(0, index1));
              for (String str1 : getValue(s.substring(index1, index2+1), left-1, right-1)) {
                  sb.append(str1);
                  sb.append(s.substring(index2+1, s.length()));
                  list.add(sb.toString());
              }
          }
          return list;
      }
    #+end_src 
* Mysql
** 511 游戏玩法分析1
 #+begin_src sql
   SELECT player_id, min(event_date) 'first_login' FROM Activity GROUP BY player_id ORDER BY player_id ASC;
 #+end_src
** 512 游戏玩法分析2
   #+begin_src sql
     SELECT a.player_id, a.device_id FROM Activity a WHERE (a.player_id, a.event_date) IN (SELECT player_id, min(event_date) AS first_login FROM Activity GROUP BY player_id);
   #+end_src
** 577 员工奖金
   #+begin_src sql
     SELECT a.name, b.bonus FROM Employee a LEFT JOIN Bonus b ON a.empId = b.empId WHERE b.bonus IS NULL OR b.bonus < 1000;
   #+end_src
** 584 寻找用户推荐人
   #+begin_src sql
     SELECT name FROM customer WHERE referee_id != 2 OR referee_id IS NULL;
   #+end_src
** 586 订单最多的用户
   #+begin_src sql
     SELECT
         customer_number
     FROM
         orders
     GROUP BY customer_number
     ORDER BY COUNT(*) DESC
     LIMIT 1
     ;
   #+end_src

** 597 好友申请1 总体通过率
   #+begin_src sql
     SELECT
     ROUND(
         IFNULL(
         (SELECT COUNT(DISTINCT requester_id, accepter_id) FROM request_accepted as A)
         /
         (SELECT COUNT(DISTINCT sender_id, send_to_id) FROM friend_request as B),
         0)
     , 2) as accept_rate;
   #+end_src

** 603 连续空余座位
   #+begin_src sql
     SELECT DISTINCT a.seat_id
       FROM cinema a JOIN cinema b
       ON ABS(a.seat_id - b.seat_id) = 1
       AND a.free = TRUE AND b.free = TRUE
       ORDER BY a.seat_id;
   #+end_src
** 607 销售员
   #+begin_src sql
     SELECT
         name
     FROM
         salesperson
     WHERE
         sales_id NOT IN (SELECT
               a.sales_id
           FROM
               orders a
                   LEFT JOIN
               company b ON b.com_id = a.com_id
           WHERE
               b.name = 'RED');
   #+end_src

** 610 判断三角形
   #+begin_src sql
     SELECT x, y, z, CASE
                         WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
                         ELSE 'No'
                     END AS 'triangle' FROM triangle;
   #+end_src

** 613 直线上的最近距离
   #+begin_src sql
     SELECT
         MIN(ABS(p1.x - p2.x)) as shortest
     FROM
         point p1
             JOIN
         point p2 on p1.x != p2.x;
   #+end_src
** 619 只出现一次的最大数字
   - 错误
     #+begin_src sql
       SELECT a.num FROM (SELECT num, COUNT(*) AS times FROM my_numbers GROUP BY num) AS a WHERE a.times = 1 ORDER BY a.num DESC LIMIT 1;
     #+end_src
   - 正确
     #+begin_src sql
       SELECT MAX(num) AS num FROM (SELECT num FROM my_numbers GROUP BY num HAVING COUNT(num) = 1) AS t;
     #+end_src
** 1050 合作过至少三次的演员和导演
   #+begin_src sql
     SELECT actor_id, director_id FROM ActorDirector GROUP BY actor_id, director_id HAVING COUNT(*) > 2;
   #+end_src
** 1068 产品销售分析 1
   - 不使用链接
     #+begin_src sql
       SELECT a.product_name, b.year, b.price FROM Product a, Sales b WHERE a.product_id = b.product_id;
     #+end_src
   - 使用链接
     #+begin_src sql
       SELECT a.product_name, b.year, b.price FROM Product a RIGHT JOIN Sales b ON a.product_id = b.product_id;
     #+end_src
** 1069 产品销售分析 2
   #+begin_src sql
     SELECT product_id, SUM(quantity) as total_quantity FROM Sales GROUP BY product_id;
   #+end_src
** 1075 项目员工 1
   #+begin_src sql
     SELECT a.project_id, ROUND(AVG(b.experience_years), 2) AS average_years FROM Project a LEFT JOIN Employee b ON a.employee_id = b.employee_id GROUP BY a.project_id ORDER BY a.project_id ASC;
   #+end_src
** 1076 项目员工 2
   #+begin_src sql
     SELECT project_id FROM project GROUP BY project_id HAVING COUNT(*) = (SELECT COUNT(*) times FROM project GROUP BY project_id ORDER BY times DESC LIMIT 1);
   #+end_src
** 1082 销售分析 1
   #+begin_src sql
     SELECT seller_id FROM Sales GROUP BY seller_id HAVING SUM(price) = (SELECT SUM(price) total_sale FROM Sales GROUP BY seller_id ORDER BY total_sale DESC LIMIT 1);
   #+end_src
** 1083 销售分析 2
   #+begin_src sql
     SELECT DISTINCT buyer_id
     FROM Product a RIGHT JOIN Sales b
     ON a.product_id = b.product_id
     WHERE product_name = 'S8'
     AND (buyer_id NOT IN (
     SELECT buyer_id FROM Product a RIGHT JOIN Sales b
     ON a.product_id = b.product_id
     WHERE a.product_name = 'iPhone'));
   #+end_src
** 1084 销售分析 4
   #+begin_src sql
     -- SELECT DISTINCT b.product_id, a.product_name
     -- FROM Product a RIGHT JOIN Sales b
     -- ON a.product_id = b.product_id
     -- GROUP BY b.product_id
     -- HAVING SUM(b.sale_date NOT BETWEEN
     -- "2019-01-01" AND "2019-03-31") = 0;

     SELECT S.product_id, P.product_name
     FROM Product P, Sales S
     WHERE P.product_id = S.product_id
     GROUP BY S.product_id
     HAVING SUM(S.sale_date NOT BETWEEN
     "2019-01-01" AND "2019-03-31") = 0;
   #+end_src
** 1113 报告的记录
   #+begin_src sql
     SELECT extra report_reason, COUNT(DISTINCT post_id, extra) report_count
     FROM Actions
     WHERE DATEDIFF('2019-07-05', action_date) = 1
     AND action = 'report'
     GROUP BY report_reason
     ORDER BY report_count ASC;
   #+end_src
** 1141 查询近30天活跃用户数
   #+begin_src sql
     SELECT activity_date day, COUNT(DISTINCT user_id) active_users
     FROM Activity
     WHERE DATEDIFF('2019-07-27', activity_date) < 30
     -- AND (activity_type = 'scroll_down' OR activity_type = 'send_message')
     GROUP BY day
     ORDER BY day ASC;
   #+end_src
** 1142 过去30天的用户活动 2
   #+begin_src sql
     SELECT IFNULL(ROUND(COUNT(DISTINCT session_id)/COUNT(DISTINCT user_id), 2), 0) average_sessions_per_user
     FROM Activity
     WHERE DATEDIFF('2019-07-27', activity_date) < 30;
   #+end_src
** 1143 文章浏览 1
   #+begin_src sql
     SELECT DISTINCT author_id id
     FROM Views
     WHERE author_id = viewer_id
     ORDER BY author_id ASC;
   #+end_src


  
