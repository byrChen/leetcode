#+TAGS: TOBEORG(t) UNRESOLVED(u) QUESTIONS(q)
* 1 两数之和                                                           :数组:
** 暴力解法
   #+begin_src java :classname 
     class Solution {
         public int[] twoSum(int[] nums, int target) {
             for (int i=0; i < nums.length; i++) {
                 int other = target - nums[i];
                 for (int j = i + 1; j < nums.length; j++) {
                     if (other == nums[j]) {
                         return new int[] {i, j};
                     }
                 }
             }
             throw new IllegalArgumentException("No two sum solution");
         }
     }
   #+end_src 
   - ~new int[] {i, j}~
   - 复杂度
     - $O(n^2)$
     - $O(1)$
** 哈希映射
   - Two-pass
     #+begin_src java :classname 
       class Solution {
           public int[] twoSum(int[] nums, int target) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int i = 0; i < nums.length; i++) {
                   map.put(nums[i], i);
               }
               for (int j = 0; j < nums.length; j++) {
                   int rest = target - nums[j];
                   if (map.containsKey(rest) && map.get(rest) != j) {
                       return new int[] {j, map.get(rest)};
                   }
               }
               throw new IllegalArgumentException("No two sum solution");
           }
       }
     #+end_src
     - ~Map<Integer, Integer> map = new HashMap<>()~
     - ~map.put(nums[i], i)~, ~map.containsKey(rest)~ and ~map.get(rest) != j~
     - 复杂度
       - $O(n)$: 哈希表的查找时间复杂度为 $O(1)$
       - $O(n)$: 哈希表大小为 $n$
   - One-pass
     #+begin_src java :classname 
       class Solution {
           public int[] twoSum(int[] nums, int target) {
               Map<Integer, Integer> map = new HashMap<>();
               for (int i = 0; i < nums.length; i++) {
                   int rest = target - nums[i];
                   if (map.containsKey(rest)) {
                       return new int[] {map.get(rest), i};
                   }
                   map.put(nums[i], i);
               }
               throw new IllegalArgumentException("No two sum solution");
           }
       }
     #+end_src
     - 复杂度: 和 Two-pass 一样
* 2 两数相加                                                           :链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            ListNode head = new ListNode(0), p = head;
            int carry = 0;
            while (l1 != null || l2 != null) {
                int sum = carry;
                if (l1 != null) sum += l1.val;
                if (l2 != null) sum += l2.val;
                p.next = new ListNode(sum % 10);
                carry = sum / 10;
                p = p.next;
                if (l1 != null) l1 = l1.next;
                if (l2 != null) l2 = l2.next;
            }
            if (carry != 0) p.next = new ListNode(carry);
            return head.next;
        }
    }
  #+end_src 
* 3 无重复字符的最长子串 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink8>>][offer48]]                           :DP:双指针:字符串:
  #+begin_src java :classname 
    class Solution {
        public int lengthOfLongestSubstring(String s) {
            if (s == null || s.length() <= 0) return 0;
            int max = 0, start = 0, len = s.length();
            Map<Character, Integer> map = new HashMap<>();
            for (int i = 0; i < len; i++) {
                char ch = s.charAt(i);
                if (map.containsKey(ch) && map.get(ch) >= start) {
                    int next = map.get(ch);
                    if (i - start > max) max = i - start;
                    start = next + 1;
                }
                map.put(ch, i);
            }
            if (len - start > max) max = len - start;
            return max;
        }
    }
  #+end_src 
* 4 寻找两个有序数组的中位数                                     :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        }
    }
  #+end_src 
* 5 最长回文子串                                  :DP:扩展窗口:双指针:字符串:
** 中心扩展算法
   #+begin_src java :classname 
     class Solution {
         public String longestPalindrome(String s) {
             if (s == null || s.length() <= 1) return "";
             int start = 0, end = 0;
             for (int i = 0; i < s.length(); i++) {
                 int oddL = expandAroundCenter(s, i, i);
                 int evenL = expandAroundCenter(s, i, i+1);
                 int len = Math.max(oddL, evenL);
                 if (len > end-start+1) {
                     start = i - (len-1) / 2;
                     end = i + len / 2;
                 }
             }
             return s.substring(start, end+1);
         }

         private int expandAroundCenter(String s, int l, int r) {
             while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
                 l -= 1;
                 r += 1;
             }
             return r - l - 1;
         }
     }
   #+end_src 
** 最长公共子串(DP)                                              :UNRESOLVED:
* 10 正则表达式匹配 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink9>>][offer19]]                         :DP:DFS:回溯:递归:字符串:
** 递归
   #+begin_src java :classname 
     class Solution {
         public boolean isMatch(String s, String p) {
             if (s == null || p == null) return false;
             return matchHelper(s.toCharArray(), 0, p.toCharArray(), 0);
         }

         private boolean matchHelper(char[] s, int i, char[] p, int j) {
             if (i == s.length && j == p.length) return true;
             else if (j == p.length) return false;

             if (j+1 < p.length && p[j+1] == '*') {
                 if (i < s.length && (s[i] == p[j] || p[j] == '.')) return matchHelper(s, i+1, p, j) || matchHelper(s, i, p, j+2);
                 return matchHelper(s, i, p, j+2);
             }

             if (i < s.length && (s[i] == p[j] || p[j] == '.')) return matchHelper(s, i+1, p, j+1);
             return false;
         }
     }
   #+end_src 
** 回溯
** DP
* 11 盛最多水的容器                                             :双指针:数组:
** 双指针
   #+begin_src java :classname 
     class Solution {
         public int maxArea(int[] height) {
             int max = 0, left = 0, right = height.length-1;
             while (left < right) {
                 int cur = (right-left) * Math.min(height[left], height[right]);
                 if (cur > max) max = cur;
                 if (height[left] < height[right]) left+= 1;
                 else right -= 1;
             }
             return max;
         }
     }
   #+end_src 
* 15 三数之和                                                :双指针:DP:数组:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> threeSum(int[] nums) {
            List<List<Integer>> lists= new ArrayList<>();
            if (nums == null || nums.length < 3) return lists;
            Arrays.sort(nums);
            for (int i = 0; i < nums.length; i++) {
                if (nums[i] > 0) break;
                if (i > 0 && nums[i] == nums[i-1]) continue;
                int left = i + 1, right = nums.length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[left] + nums[right];
                    if (sum > 0)      right -= 1;
                    else if (sum < 0) left += 1;
                    else {
                        // List<Integer> list = new ArrayList<>();
                        // list.add(nums[i]);
                        // list.add(nums[left]);
                        // list.add(nums[right]);
                        // lists.add(list);
                        lists.add(Arrays.asList(nums[i], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left+1])   left += 1;
                        while (left < right && nums[right] == nums[right-1]) right -= 1;
                        left += 1;
                        right -= 1;
                    }
                }
            }
            return lists;
        }
    }
  #+end_src 
* 17 电话号码的字母组合                       :DFS:回溯:递归:排列组合:字符串:
  #+begin_src java :classname 
    class Solution {
        Map<Character, String> phone = new HashMap<Character, String>() {{
                put('2', "abc");
                put('3', "def");
                put('4', "ghi");
                put('5', "jkl");
                put('6', "mno");
                put('7', "pqrs");
                put('8', "tuv");
                put('9', "wxyz");
            }};
        List<String> combinations = new ArrayList<>();
        public List<String> letterCombinations(String digits) {
            if (digits == null || digits.length() <= 0) return combinations;
            combinationsHelper("", digits, 0);
            return combinations;
        }
        private void combinationsHelper(String combination, String digits, int pos) {
            if (pos == digits.length()) combinations.add(combination);
            else {
                String s = phone.get(digits.charAt(pos));
                for (int i = 0; i < s.length(); i++) {
                    combinationsHelper(combination+s.substring(i, i+1), digits, pos+1);
                }
            }
        }
    }
  #+end_src 
* 19 删除链表的倒数第N个节点                                    :双指针:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode removeNthFromEnd(ListNode head, int n) {
            ListNode pivot = new ListNode(0);
            pivot.next = head;
            ListNode prev = pivot, p = head, tail = head;
            for (int i = 0; i < n; i++) tail = tail.next;
            while (tail != null) {
                prev = prev.next;
                p = p.next;
                tail = tail.next;
            }
            prev.next = p.next;
            return pivot.next;
        }
    }
  #+end_src 
* 20 有效的括号                                                   :栈:字符串:
  #+begin_src java :classname 
    class Solution {
        public boolean isValid(String s) {
            Stack<Character> stack = new Stack<>();
            for (int i = 0; i < s.length(); i++) {
                char ch = s.charAt(i);
                if (ch == '(' || ch == '[' || ch == '{') {
                    stack.push(ch);
                } else {
                    if (stack.empty()) return false;
                    switch (ch) {
                    case ')':
                        if (stack.peek() != '(') return false;
                        stack.pop();
                        break;
                    case ']':
                        if (stack.peek() != '[') return false;
                        stack.pop();
                        break;
                    case '}':
                        if (stack.peek() != '{') return false;
                        stack.pop();
                        break;
                    }
                }
            }
            return stack.empty();
        }
    }
  #+end_src 
* 21 合并有序链表                                                 :递归:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if (l1 == null) return l2;
            if (l2 == null) return l1;
            ListNode head = l1.val > l2.val ? l2 : l1;
            head.next = head == l1 ? mergeTwoLists(l1.next, l2) : mergeTwoLists(l1, l2.next);
            return head;
        }
    }
  #+end_src 
* 22 括号生成                              :DP:DFS:回溯:递归:排列组合:字符串:
** 回溯
   #+begin_src java :classname 
     class Solution {
         public List<String> generateParenthesis(int n) {
             List<String> list = new ArrayList<>();
             if (n != 0) dfs("", n, n, list);
             return list;
         }

         private void dfs(String s, int left, int right, List<String> list) {

             if (left == 0 && right == 0) {
                 list.add(s);
                 return;
             }

             if (left > right) return;
             if (left > 0) dfs(s+"(", left-1, right, list);
             if (right > 0) dfs(s+")", left, right-1, list);
         }
     }
   #+end_src 
** DP(闭合数)                                                    :UNRESOLVED:
* 23 合并K个排序链表                                             :UNRESOLVED:
* 31 下一个排列                                          :排序:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        public void nextPermutation(int[] nums) {
            int i = nums.length - 2;
            while (i >= 0 && nums[i] >= nums[i+1]) i -= 1;
            if (i >= 0) {
                for (int j = nums.length-1; j >= i+1; j--) {
                    if (nums[j] > nums[i]) {
                        swap(nums, i, j);
                        break;
                    }
                }
            }
            reverse(nums, i+1);
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }

        private void reverse(int[] nums, int start) {
            int end = nums.length - 1;
            while (start < end) {
                swap(nums, start, end);
                start += 1;
                end -= 1;
            }
        }
    }
  #+end_src 
* 32 最长有效括号                                                :UNRESOLVED:
* 33 搜索旋转排序数组 [[file:~/csnds/Dropbox/orglife/offer.org::<<ilink15>>][offer11]]                            :二分查找:查找:数组:
  #+begin_src java :classname 
    class Solution {
        public int search(int[] nums, int target) {
            if (nums == null || nums.length <= 0) return -1;
            int start = 0, end = nums.length - 1;
            if (nums[start] > nums[end]) {
                while (start < end) {
                    int mid = (start+end) >> 1;
                    if (nums[mid] > nums[end]) start = mid + 1;
                    else {
                        if (mid == 0 || nums[mid] < nums[mid-1]) {
                            end = nums.length - 1;
                            start = mid;
                            break;
                        }
                        end = mid;
                    }
                }
            }
            if (target > nums[end]) {
                end = start - 1;
                start = 0;
            }
            while (start < end) {
                int mid = (start+end) >> 1;
                if (nums[mid] == target) return mid;
                if (nums[mid] < target) start = mid + 1;
                else end = mid;
            }
            return nums[start] == target ? start : -1;
        }
    }
  #+end_src 
* 34 在排序数组中查找元素的第一个和最后一个位置 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink10>>][offer53]]  :二分查找:查找:数组:
  #+begin_src java :classname 
    class Solution {
        public int[] searchRange(int[] nums, int target) {
            if (nums == null || nums.length <= 0) return new int[] {-1, -1};
            int start = 0, end = nums.length - 1, mid = (start+end) >> 1;
            while (start < end) {
                if (nums[mid] == target) break;
                if (nums[mid] > target) end = mid;
                else start = mid + 1;
                mid = (start+end) >> 1;
            }
            if (nums[mid] != target) return new int[] {-1, -1};
            int[] res = new int[2];
            start = 0; end = mid;
            int left = (start+end) >> 1;
            while (start < end) {
                if (nums[left] < target) start = left + 1;
                else {
                    if (left == start || nums[left-1] != target) break;
                    end = left;
                }
                left = (start+end) >> 1;
            }
            res[0] = left;
            start = mid; end = nums.length - 1;
            int right = (start+end) >> 1;
            while (start < end) {
                if (nums[right] > target) end = right;
                else {
                    if (right == end || nums[right+1] != target) break;
                    start = right + 1;
                }
                right = (start+end) >> 1;
            }
            res[1] = right;
            return res;
        }
    }
  #+end_src 
* 39 组合总数                                   :DFS:回溯:递归:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        private List<List<Integer>> res = new ArrayList<>();
        private List<Integer> path = new ArrayList<>();
        public List<List<Integer>> combinationSum(int[] candidates, int target) {
            if (candidates == null || candidates.length <= 0) return res;
            Arrays.sort(candidates);
            combinationHelper(candidates, 0, target);
            return res;
        }

        private void combinationHelper(int[] candidates, int start, int target) {
            if (target == 0) {
                res.add(new ArraysList<Integer>(path));
                return;
            }
            for (int i = start; i < candidates.length; i++) {
                if (candidates[i] > target) break;
                path.add(candidates[i]);
                combinationHelper(candidates, i, target-candidates[i]);
                path.remove(path.size()-1);
            }
        }
    }
  #+end_src 
* 42 接雨水                                                      :UNRESOLVED:
* 46 全排列                                     :DFS:回溯:递归:排列组合:数组:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new ArrayList<>();
            if (nums == null || nums.length <= 0) return res;
            permuteHelper(nums, nums.length, 0, res);
            return res;
        }

        private void permuteHelper(int[] nums, int len, int pos, List<List<Integer>> res) {
            if (pos == len-1) {
                List<Integer> arr = new ArrayList<>();
                for (int i : nums) arr.add(i);
                res.add(arr);
                return;
            }
            for (int i = pos; i < len; i++) {
                swap(nums, pos, i);
                permuteHelper(nums, len, pos+1, res);
                swap(nums, pos, i);
            }
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
  #+end_src 
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new ArrayList<>();
            if (nums == null || nums.length <= 0) return res;
            List<Integer> arr = new ArrayList<>();
            for (int i : nums) arr.add(i);
            permuteHelper(arr, nums.length, 0, res);
            return res;
        }

        private void permuteHelper(List<Integer> arr, int len, int pos, List<List<Integer>> res) {
            if (pos == len-1) {
                res.add(new ArrayList<Integer>(arr));
                return;
            }
            for (int i = pos; i < len; i++) {
                Collections.swap(arr, pos, i);
                permuteHelper(arr, len, pos+1, res);
                Collections.swap(arr, pos, i);
            }
        }
    }
  #+end_src 
* 48 旋转图像                                            :矩阵:二维数组:数组:
** 旋转4个矩形(直接规律)
   #+begin_src java :classname 
     class Solution {
         public void rotate(int[][] matrix) {
             if (matrix == null || matrix.length <= 0 || matrix[0].length <= 0) return;
             int len = matrix.length, cir = len / 2;
             for (int i = 0; i < cir; i++) {
                 int endi = len - i - 1;
                 for (int j = i; j < endi; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[endi+i-j][i];
                     matrix[endi+i-j][i] = matrix[endi][endi+i-j];
                     matrix[endi][endi+i-j] = matrix[j][endi];
                     matrix[j][endi] = temp;
                 }
             }
         }
      }
   #+end_src 
** 转置+翻转(间接规律)
   #+begin_src java :classname 
     class Solution {
         public void rotate(int[][] matrix) {
             if (matrix == null || matrix.length <= 0 || matrix[0].length <= 0) return;
             int len = matrix.length;
             for (int i = 0; i < len; i++) {
                 for (int j = 0; j < i; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[j][i];
                     matrix[j][i] = temp;
                 }
             }
             for (int i = 0; i < len; i++) {
                 for (int j = 0; j < len/2; j++) {
                     int temp = matrix[i][j];
                     matrix[i][j] = matrix[i][len-1-j];
                     matrix[i][len-1-j] = temp;
                 }
             }
         }
     }
   #+end_src 
   - 顺时针 -> 转置+按行翻转
   - 逆时针 -> 转置+按列翻转
* 49 字母异位词分组                              :排序:映射:数组:字符:字符串:
** 暴力
   #+begin_src java :classname 
     class Solution {
         public List<List<String>> groupAnagrams(String[] strs) {
             List<List<String>> res = new ArrayList<>();
             if (strs == null || strs.length <= 0) return res;
             boolean[] added = new boolean[strs.length];
             for (int i = 0; i < strs.length; i++) {
                 List<String> list = new ArrayList<>();
                 if (added[i]) continue;
                 list.add(strs[i]);
                 added[i] = true;
                 for (int j = i+1; j < strs.length; j++) {
                     if (added[j]) continue;
                     if (strs[i].length() == strs[j].length()) {
                         if (strs[i].equals(strs[j]) || isAnagram(strs[i], strs[j])) {
                             list.add(strs[j]);
                             added[j] = true;
                         }
                     }
                 }
                 if (!list.isEmpty()) res.add(list);
             }
             return res;
         }

         private boolean isAnagram(String s1, String s2) {
             int[] set = new int[26];
             for (int i = 0; i < s1.length(); i++) set[s1.charAt(i)-'a'] += 1;
             for (int i = 0; i < s2.length(); i++) set[s2.charAt(i)-'a'] -= 1;
             for (int i = 0; i < 26; i++) if(set[i] != 0) return false;
             return true;
         }
     }
   #+end_src 
** 排序+映射
   #+begin_src java :classname 
     class Solution {
         public List<List<String>> groupAnagrams(String[] strs) {
             List<List<String>> res = new ArrayList<>();
             if (strs == null || strs.length <= 0) return res;
             Map<String, List<String>> map = new HashMap<>();
             for (String s : strs) {
                 char[] chs = s.toCharArray();
                 Arrays.sort(chs);
                 // String key = String.valueOf(chs);
                 String key = new String(chs); // 更快
                 if (!map.containsKey(key)) map.put(key, new ArrayList<String>());
                 map.get(key).add(s);
             }
             // return new ArrayList<>(map.values());
             res.addAll(map.values());
             return res;
         }
     }
   #+end_src 
* 53 最大子序和                                                     :DP:数组:
  #+begin_src java :classname 
    class Solution {
        public int maxSubArray(int[] nums) {
            int maxSum = Integer.MIN_VALUE, curSum = 0;
            if (nums == null || nums.length <= 0) return max;
            for (int i = 0; i < nums; i++) {
                curSum += nums[i];
                if (maxSum < curSum) maxSum = curSum;
                if (curSum < 0) curSum = 0;
            }
            return maxSum;
        }
    }
  #+end_src 
* 55 跳跃游戏                                        :DP:贪心:回溯:递归:数组:
** 递归(回溯)
   #+begin_src java :classname 
     class Solution {
         public boolean canJump(int[] nums) {
             if (nums == null || nums.length <= 0) return false;
             return canJumpHelper(nums, 0, nums.length-1);
         }

         private boolean canJumpHelper(int[] nums, int pos, int end) {
             if (pos == end) return true;
             for (int i = 1; i <= nums[pos]; i++) {
                 if (pos+i > end) return false;
                 if (canJumpHelper(nums, pos+i, end)) return true;
             }
             return false;
         }
     }
   #+end_src 
** DP                                                            :UNRESOLVED:
** 贪心
   #+begin_src java :classname 
     class Solution {
         public boolean canJump(int[] nums) {
             if (nums == null || nums.length <= 0) return false;
             int lastPos = nums.length - 1;
             for (int i = nums.length-1; i >= 0; i--) {
                 if (i + nums[i] >= lastPos) lastPos = i;
             }
             return lastPos == 0;
         }
     }
   #+end_src 
* 56 合并区间                                            :排序:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int[][] merge(int[][] intervals) {
            if (intervals == null || intervals.length <= 0 || intervals[0].length <= 0) return new int[][] {}; // new int[0][];

            // Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

            // Comparator<int[]> intervalComparator = (int[] interval1, int[] interval2) -> {
            //     return interval1[0] - interval2[0];
            // };
            // Arrays.sort(intervals, intervalComparator);

            Arrays.sort(intervals, new Comparator<int[]>() {
                    @Override
                    public int compare(int[] interval1, int[] interval2) {
                        return Integer.compare(interval1[0], interval2[0]);
                        // return interval1[0] - interval2[0];
                    }
                });
            List<int[]> res = new ArrayList<>();
            for (int i = 0; i < intervals.length; i++) {
                int start = intervals[i][0];
                int end = intervals[i][1];
                int j = i + 1;
                for (; j < intervals.length; j++) {
                    if (intervals[j][0] > end) break;
                    if (intervals[j][1] > end) end = intervals[j][1];
                }
                res.add(new int[]{start, end});
                i = j - 1;
            }

            return res.toArray(new int[res.size()][]);

            // int[][] combineIntervals = new int[res.size()][];
            // for (int i = 0; i < res.size(); i++) {
            //     combineIntervals[i] = res.get(i);
            // }
            // return combineIntervals;
        }
    }
  #+end_src 
* 62 不同路径                                              :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int uniquePaths(int m, int n) {
            int[][] paths = new int[m][n];
            for (int i = 0; i < m; i++) paths[i][0] = 1;
            for (int i = 1; i < n; i++) paths[0][i] = 1;
            for (int i = 1; i < m; i++) {
                for (int j = 1; j < n; j++) paths[i][j] = paths[i-1][j] + paths[i][j-1];
            }
            return paths[m-1][n-1];
        }
    }
  #+end_src 
* 64 最小路径和                                            :DP:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public int minPathSum(int[][] grid) {
            if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
            int rows = grid.length, cols = grid[0].length;
            for (int row = 1; row < rows; row++) grid[row][0] += grid[row-1][0];
            for (int col = 1; col < cols; col++) grid[0][col] += grid[0][col-1];
            for (int row = 1; row < rows; row++) {
                for (int col = 1; col < cols; col++) grid[row][col] += Math.min(grid[row-1][col], grid[row][col-1]);
            }
            return grid[rows-1][cols-1];
        }
    }
  #+end_src 
* 70 爬楼梯                                                              :DP:
** DP
   #+begin_src java :classname 
     class Solution {
         public int climbStairs(int n) {
             int a1 = 1, a2 = 1;
             while (n > 1) {
                 int a3 = a1 + a2;
                 a1 = a2;
                 a2 = a3;
                 n -= 1;
             }
             return a2;
         }
     }
   #+end_src 
** Binets法                                                      :UNRESOLVED:
** 斐波那契公式                                                  :UNRESOLVED:
* 72 编辑距离                                                    :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int minDistance(String word1, String word2) {

        }
    }
  #+end_src 
* 75 颜色分类                                         :三指针:快排:排序:数组:
** 三路快排 [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink19>>][Hoare Partition]]
   #+begin_src java :classname 
     class Solution {
         public void sortColors(int[] nums) {
             int next0 = 0, next2 = nums.length - 1;
             while (next0 < nums.length && nums[next0] == 0) next0 += 1;
             while (next2 >= 0 && nums[next2] == 2) next2 -= 1;
             int cur = next0;
             while (cur <= next2) {
                 switch (nums[cur]) {
                 case 0:
                     swap(nums, cur, next0);
                     while (next0 < nums.length && nums[next0] == 0) next0 += 1;
                     cur = next0;
                     break;
                 case 2:
                     swap(nums, cur, next2);
                     while (next2 >= 0 && nums[next2] == 2) next2 -= 1;
                     break;
                 case 1:
                     cur += 1;
                     break;
                 }
             }
         }

         private void swap(int[] nums, int i, int j) {
             int temp = nums[i];
             nums[i] = nums[j];
             nums[j] = temp;
         }
     }
   #+end_src 
* 76 最小覆盖子串                                                :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public String minWindow(String s, String t) {

        }
    }
  #+end_src 
* 78 子集                                                    :回溯:递归:数组:
** 迭代
   #+begin_src java :classname 
     class Solution {
         public List<List<Integer>> subsets(int[] nums) {
             List<List<Integer>> res = new ArrayList<>();
             if (nums == null || nums.length <= 0) return res;
             res.add(new ArrayList<Integer>());
             for (int i = 0; i < nums.length; i++) {
                 int news = res.size();
                 for (int j = 0; j < news; j++) {
                     List<Integer> newSubSet = new ArrayList<>(res.get(j));
                     newSubSet.add(nums[i]);
                     res.add(newSubSet);
                 }
             }
             return res;
         }
     }
   #+end_src 
** 回溯
   #+begin_src java :classname 
     class Solution {
         public List<List<Integer>> subsets(int[] nums) {
             List<List<Integer>> res = new ArrayList<>();
             if (nums == null || nums.length <= 0) return res;
             backtrack(res, nums, 0, nums.length, new ArrayList<Integer>());
             return res;
         }

         private void backtrack(List<List<Integer>> res, int[] nums, int start, int len, ArrayList<Integer> newSubSet) {
             res.add(new ArrayList<>(newSubSet));
             for (int i = start; i < len; i++) {
                 newSubSet.add(nums[i]);
                 backtrack(res, nums, i+1, len, newSubSet);
                 newSubSet.remove(newSubSet.size()-1);
             }
         }
     }
   #+end_src 
** 字典排序(二进制排序)                                          :UNRESOLVED:
* 79 单词搜索 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink20>>][offer12]]                             :DFS:回溯:递归:二维数组:数组:
  #+begin_src java :classname 
    class Solution {
        public boolean exist(char[][] board, String word) {
            if (board == null || board.length <= 0 || board[0].length <= 0) return false;
            int rows = board.length, cols = board[0].length;
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    boolean[][] visited = new boolean[rows][cols];
                    if (existHelper(board, word, i, rows, j, cols, 0, visited)) return true;
                }
            }
            return false;
        }

        private boolean existHelper(char[][] board, String word, int row, int rows, int col, int cols, int pos, boolean[][] visited) {
            if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
            if (visited[row][col] || board[row][col] != word.charAt(pos)) return false;
            if (pos == word.length()-1) return true;
            visited[row][col] = true;
            pos += 1;
            if (existHelper(board, word, row-1, rows, col, cols, pos, visited) ||
                existHelper(board, word, row+1, rows, col, cols, pos, visited) ||
                existHelper(board, word, row, rows, col-1, cols, pos, visited) ||
                existHelper(board, word, row, rows, col+1, cols, pos, visited)) return true;
            visited[row][col] = false;
            return false;
        }
    }
  #+end_src 
* 84 柱状图中最大的矩形                                          :UNRESOLVED:
  #+begin_src java :classname 
  #+end_src 
* 85 最大矩形                                                    :UNRESOLVED:
* 94 二叉树的中序遍历                           :DFS:递归:中序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> order = new ArrayList<>();
            inorderHelper(root, order);
            return order;
        }

        private void inorderHelper(TreeNode root, List<Integer> order) {
            if (root == null) return;
            inorderHelper(root.left, order);
            order.add(root.val);
            inorderHelper(root.right, order);
        }
    }
  #+end_src 
* 96 不同的二叉搜索树                          :DP:递归:二叉搜索树:二叉树:树:
** 递归
   #+begin_src java :classname 
     class Solution {
         public int numTrees(int n) {
             if (n <= 1) return n;
             return numHelper(1, n);
         }

         private int numHelper(int start, int end) {
             if (start >= end) return 1;
             int num = 0;
             for (int i = start; i <= end; i++) {
                 int left = numHelper(start, i - 1);
                 int right = numHelper(i+1, end);
                 num += left * right;
             }
             return num;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         public int numTrees(int n) {
             int[] res = new int[n+1];
             res[0] = 1;
             for (int i = 1; i <= n; i++) {
                 for (int j = 1; j <= i; j++) {
                     res[i] += res[j-1]*res[i-j];
                 }
             }
             return res[n];
         }
     }
   #+end_src 
** 数学演绎法                                                    :UNRESOLVED:
* 97 验证二叉搜索树                               :递归:二叉搜索树:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public boolean isValidBST(TreeNode root) {
            if (root == null) return true;
            boolean isBST = true;
            if (root.left != null) isBST = isBST && maxVal(root.left) < root.val && isValidBST(root.left);
            if (root.right != null) isBST = isBST && minVal(root.right) > root.val && isValidBST(root.right);
            return isBST;
        }

        private int maxVal(TreeNode root) {
            while (root.right != null) root = root.right;
            return root.val;
        }

        private int minVal(TreeNode root) {
            while (root.left != null) root = root.left;
            return root.val;
        }
    }
  #+end_src 
* 101 对称二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink11>>][offer28]]                                     :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public boolean isSymmetric(TreeNode root) {
            if (root == null) return true;
            return isSymmetricHelper(root.left, root.right);
        }

        private boolean isSymmetricHelper(TreeNode n1, TreeNode n2) {
            if (n1 == null && n2 == null) return true;
            if (n1 == null || n2 == null) return false;
            return n1.val == n2.val && isSymmetricHelper(n1.left, n2.right) && isSymmetricHelper(n1.right, n2.left);
        }
    }
  #+end_src 
* 102 二叉树的层序遍历                               :BFS:层序遍历:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();
            if (root == null) return res;
            Queue<TreeNode> que = new LinkedList<>();
            que.offer(root);
            while (!que.isEmpty()) {
                int len = que.size();
                List<Integer> list = new ArrayList<>();
                for (int i = 0; i < len; i++) {
                    TreeNode poll = que.poll();
                    list.add(poll.val);
                    if (poll.left != null) que.offer(poll.left);
                    if (poll.right != null) que.offer(poll.right);
                }
                res.add(list);
            }
            return res;
        }
    }
  #+end_src 
* 104 二叉树的最大深度 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink13>>][offer55]]                               :递归:二叉树:树:
  #+begin_src java :classname 
    class Solution {
        public int maxDepth(TreeNode root) {
            if (root == null) return 0;
            return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
        }
    }
  #+end_src 
* 105 从前序和中序遍历序列构造二叉树 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink14>>][offer7]] :数组:递归:中序遍历:前序遍历:二叉树:树:
** 直接递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode buildTree(int[] preorder, int[] inorder) {
             if (preorder == null || inorder == null || preorder.length != inorder.length || preorder.length <= 0) return null;
             int len = preorder.length, rootVal = preorder[0], pos = -1;
             TreeNode root = new TreeNode(rootVal);
             for (int i = 0; i < len; i++) {
                 if (inorder[i] == rootVal) {
                     pos = i;
                     break;
                 }
             }
             if (pos == -1) return null;
             root.left = buildTree(Arrays.copyOfRange(preorder, 1, pos+1), Arrays.copyOfRange(inorder, 0, pos));
             root.right = buildTree(Arrays.copyOfRange(preorder, pos+1, len), Arrays.copyOfRange(inorder, pos+1, len));
             return root;
         }
     }


   #+end_src 
** 辅助递归
   #+begin_src java :classname 
     class Solution {
         public TreeNode buildTree(int[] preorder, int[] inorder) {
             if (preorder == null || inorder == null || preorder.length != inorder.length || preorder.length <= 0) return null;

             // int rootVal = preorder[0], index = -1, len = preorder.length;
             // TreeNode root = new TreeNode(preorder[0]);
             // for (int i = 0; i < len; i++) {
             //     if (inorder[i] == rootVal) index = i;
             // }
             // if (index == -1) return null;
             // root.left = buildTree(Arrays.copyOfRange(preorder, 1, index+1), Arrays.copyOfRange(inorder, 0, index));
             // root.right = buildTree(Arrays.copyOfRange(preorder, index+1, len), Arrays.copyOfRange(inorder, index+1, len));
             // return root;

             return buildHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
         }
         private TreeNode buildHelper(int[] preorder, int s1, int e1, int[] inorder, int s2, int e2) {
             if (s1 == e1 && s2 == e2) return null;
             int rootVal = preorder[s1], index = -1;
             TreeNode root = new TreeNode(rootVal);
             for (int i = s2; i < e2; i++) {
                 if (inorder[i] == rootVal) index = i;
             }
             if (index == -1) return null;
             root.left = buildHelper(preorder, s1+1, s1+1+index-s2, inorder, s2, index);
             root.right = buildHelper(preorder, s1+1+index-s2, e1, inorder, index+1, e2);
             return root;
         }
     }
   #+end_src 
* 114 二叉树展开为链表 :DFS:递归:对称后序遍历:中序遍历:后序遍历:链表:二叉树:树:
** 迭代
   #+begin_src java :classname 
     class Solution {
         public void flatten(TreeNode root) {
             while (root != null) {
                 if (root.left != null) {
                     TreeNode tail = root.left;
                     while (tail.right != null) tail = tail.right;
                     tail.right = root.right;
                     root.right = root.left;
                     root.left = null;
                 }
                 root = root.right;
             }
         }
     }
   #+end_src 
** 递归
   - 对称后序
     #+begin_src java :classname 
       class Solution {
           private TreeNode head = null;
           public void flatten(TreeNode root) {
               if (root == null) return;
               flatten(root.right);
               flatten(root.left);
               root.right = head;
               root.left = null;
               head = root;
           }
       }
     #+end_src
   - 中序
     #+begin_src java :classname 
       class Solution {
           public void flatten(TreeNode root) {
               if (root == null) return;
               flatten(root.left);
               TreeNode tmp = root.right;
               root.right = root.left;
               root.left = null;
               while (root.right != null) root = root.right;
               root.right = tmp;
               flatten(tmp);
           }
       }
     #+end_src
   - 后序
     #+begin_src java :classname 
       class Solution {
           public void flatten(TreeNode root) {
               if (root == null) return;
               flatten(root.left);
               flatten(root.right);
               TreeNode tmp = root.right;
               root.right = root.left;
               root.left = null;
               while (root.right != null) root = root.right;
               root.right = tmp;
           }
       }
     #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 前序遍历递归实现？类比对称后序记录左子树尾节点的递归实现？
** 关于树的DFS(前中后)遍历的迭代实现
   - 前序
     #+begin_src java :classname 
       Stack<TreeNode> stack = new Stack<>();
       stack.push(root);
       while (!stack.empty()) {
           TreeNode n = stack.pop();
           if (n.right != null) stack.push(n.right);
           if (n.left != null) stack.push(n.left);
       }
     #+end_src 
   - 中序
     #+begin_src java :classname 
       Stack<TreeNode> stack = new Stack<>();
       TreeNode cur = root;
       while (!stack.empty() || cur != null) {
           if (cur != null) {
               stack.push(cur);
               cur = cur.left;
           } else {
               cur = stack.pop();
               cur = cur.right;
           }
       }
     #+end_src 
   - 后序
     #+begin_src java :classname 
       Stack<TreeNode> stack1 = new Stack<>();
       Stack<TreeNode> stack2 = new Stack<>();
       stack1.push(root);
       while (!stack1.empty()) {
           TreeNode n = stack1.pop();
           stack2.push(n);
           if (n.left != null) stack1.push(n.left);
           if (n.right != null) stack1.push(n.right);
       }

       while (!stack2.empty()) stack2.pop();
     #+end_src 
* 120 三角形最小路径和                                              :DP:数组:
** 自底向上
*** 二维数组
    #+begin_src java :classname 
      class Solution {
          public int minimumTotal(List<List<Integer>> triangle) {
              if (triangle == null || triangle.size() <= 0) return 0;
              int len = triangle.size();
              int[][] res = new int[len+1][len+1];
              for (int i = len-1; i >= 0; i--) {
                  List<Integer> cur = triangle.get(i);
                  for (int j = 0; j < cur.size(); j++) {
                      res[i][j] = Math.min(res[i+1][j], res[i+1][j+1]) + cur.get(j);
                  }
              }
              return res[0][0];
          }
      }
    #+end_src 
*** 一维数组(空间优化)
    #+begin_src java :classname 
      class Solution {
          public int minimumTotal(List<List<Integer>> triangle) {
              if (triangle == null || triangle.size() <= 0) return 0;
              int len = triangle.size();
              int[] res = new int[len+1];
              for (int i = len-1; i >= 0; i--) {
                  List<Integer> cur = triangle.get(i);
                  for (int j = 0; j < cur.size(); j++) {
                      res[j] = Math.min(res[j], res[j+1]) + cur.get(j);
                  }
              }
              return res[0];
          }
      }
    #+end_src 
* 121 买卖股票的最佳时机                                               :数组:
  #+begin_src java :classname 
    class Solution {
        public int maxProfit(int[] prices) {
            int max = 0, buy = 0, len = prices.length;
            for (int i = 0; i < len; i++) {
                int cur = prices[i] - prices[buy];
                if (max < cur) max = cur;
                if (cur < 0) buy = i;
            }
            return max;
        }
    }
  #+end_src 
* 124 二叉树中的最大路径和                                       :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int maxPathSum(TreeNode root) {

        }
    }
  #+end_src 
* 128 最长连续序列                                               :UNRESOLVED:
  #+begin_src java :classname 
    class Solution {
        public int longestConsecutive(int[] nums) {

        }
    }
  #+end_src 
* 136 只出现一次的数字                                          :位运算:数组:
  #+begin_src java :classname 
    class Solution {
        public int singleNumber(int[] nums) {
            int xor = 0;
            for (int i = 0; i < nums.length; i++) xor ^= nums[i];
            return xor;
        }
    }
  #+end_src 
* 139 单词拆分                                          :DP:回溯:递归:字符串:
** 回溯(记忆剪枝)
   #+begin_src java :classname 
     class Solution {
         public boolean wordBreak(String s, List<String> wordDict) {
             return Helper(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);
         }

         private boolean Helper(String s, Set<String> set, int start, Boolean[] memo) {
             if (start == s.length()) return true;

             if (memo[start] != null) return memo[start];

             for (int i = start+1; i <= s.length(); i++) {
                 if (set.contains(s.substring(start, i)) && Helper(s, set, i, memo)) return memo[start] = true;
             }
             return memo[start] = false;
         }
     }
   #+end_src 
** DP
   #+begin_src java :classname 
     class Solution {
         public boolean wordBreak(String s, List<String> wordDict) {
             Set<String> set = new HashSet<>(wordDict);
             boolean[] word = new boolean[s.length()+1];
             word[0] = true;
             for (int i = 1; i <= s.length(); i++) {
                 for (int j = 0; j < i; j++) {
                     if (word[j] && set.contains(s.substring(j, i))) {
                         word[i] = true;
                         break;
                     }
                 }
             }
             return word[s.length()];
         }
     }
   #+end_src 
** BFS                                                           :UNRESOLVED:
* 141 环形链表                                         :快慢指针:双指针:链表:
  #+begin_src java :classname 
    public class Solution {
        public boolean hasCycle(ListNode head) {
            ListNode p1 = head, p2 = head;
            while (p1 != null && p2 != null) {
                p1 = p1.next;
                if (p2.next == null) break;
                p2 = p2.next.next;
                if (p1 == p2) return true;
            }
            return false;
        }
    }
  #+end_src 
* 142 环形链表 2 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink15>>][offer23]]                               :快慢指针:双指针:链表:
  #+begin_src java :classname 
    public class Solution {
        public ListNode detectCycle(ListNode head) {
            ListNode n1 = head, n2 = head;
            while (true) {
                if (n1 == null || n2 == null || n2.next == null) return null;
                n1 = n1.next;
                n2 = n2.next.next;
                if (n1 == n2) break;
            }
            int len = 0;
            while (true) {
                n1 = n1.next;
                len += 1;
                if (n1 == n2) {
                    n1 = n2 = head;
                    break;
                }
            }
            for (int i = 0; i < len; i++) n2 = n2.next;
            while (n1 != n2) {
                n1 = n1.next;
                n2 = n2.next;
            }
            return n1;
        }
    }
  #+end_src 
* 146 LRU缓存机制                                                       :LRU:
** LinkedHashMap
   #+begin_src java :classname 
     class LRUCache extends LinkedHashMap<Integer, Integer>{
         private int capacity;
    
         public LRUCache(int capacity) {
             super(capacity, 0.75F, true);
             this.capacity = capacity;
         }

         public int get(int key) {
             return super.getOrDefault(key, -1);
         }

         public void put(int key, int value) {
             super.put(key, value);
         }

         @Override
         protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
             return size() > capacity; 
         }
     }
   #+end_src 
** Hashtable+链表                                                :UNRESOLVED:
   #+begin_src java :classname 
     import java.util.Hashtable;
     public class LRUCache {

       class DLinkedNode {
         int key;
         int value;
         DLinkedNode prev;
         DLinkedNode next;
       }

       private void addNode(DLinkedNode node) {
         /**
          ,* Always add the new node right after head.
          ,*/
         node.prev = head;
         node.next = head.next;

         head.next.prev = node;
         head.next = node;
       }

       private void removeNode(DLinkedNode node){
         /**
          ,* Remove an existing node from the linked list.
          ,*/
         DLinkedNode prev = node.prev;
         DLinkedNode next = node.next;

         prev.next = next;
         next.prev = prev;
       }

       private void moveToHead(DLinkedNode node){
         /**
          ,* Move certain node in between to the head.
          ,*/
         removeNode(node);
         addNode(node);
       }

       private DLinkedNode popTail() {
         /**
          ,* Pop the current tail.
          ,*/
         DLinkedNode res = tail.prev;
         removeNode(res);
         return res;
       }

       private Hashtable<Integer, DLinkedNode> cache =
               new Hashtable<Integer, DLinkedNode>();
       private int size;
       private int capacity;
       private DLinkedNode head, tail;

       public LRUCache(int capacity) {
         this.size = 0;
         this.capacity = capacity;

         head = new DLinkedNode();
         // head.prev = null;

         tail = new DLinkedNode();
         // tail.next = null;

         head.next = tail;
         tail.prev = head;
       }

       public int get(int key) {
         DLinkedNode node = cache.get(key);
         if (node == null) return -1;

         // move the accessed node to the head;
         moveToHead(node);

         return node.value;
       }

       public void put(int key, int value) {
         DLinkedNode node = cache.get(key);

         if(node == null) {
           DLinkedNode newNode = new DLinkedNode();
           newNode.key = key;
           newNode.value = value;

           cache.put(key, newNode);
           addNode(newNode);

           ++size;

           if(size > capacity) {
             // pop the tail
             DLinkedNode tail = popTail();
             cache.remove(tail.key);
             --size;
           }
         } else {
           // update the value.
           node.value = value;
           moveToHead(node);
         }
       }
     }

     /**
      ,* LRUCache 对象会以如下语句构造和调用:
      ,* LRUCache obj = new LRUCache(capacity);
      ,* int param_1 = obj.get(key);
      ,* obj.put(key,value);
      ,*/
   #+end_src 
* 148 排序链表                             :递归:快速排序:归并排序:排序:链表:
** 归并排序
*** 递归(自顶而下)
    #+begin_src java :classname 
      class Solution {
          public ListNode sortList(ListNode head) {
              if (head == null) return null;
              return mergeSortList(head);
          }

          private ListNode mergeSortList(ListNode head) {
              if (head.next == null) return head;
              ListNode p1 = head, p2 = head, prev = p1;
              while (p2 != null && p2.next != null) {
                  prev = p1;
                  p1 = p1.next;
                  p2 = p2.next.next;
              }
              prev.next = null;
              return mergeSorted(mergeSortList(head), mergeSortList(p1));
          }

          private ListNode mergeSorted(ListNode p1, ListNode p2) {
              ListNode p = new ListNode(0), cur = p;
              while (p1 != null && p2 != null) {
                  if (p1.val < p2.val) {
                      cur.next = p1;
                      p1 = p1.next;
                  } else {
                      cur.next = p2;
                      p2 = p2.next;
                  }
                  cur = cur.next;
              }
              cur.next = p1 == null ? p2 : p1;
              return p.next;
          }
      }
    #+end_src 
*** 迭代(自底向上)                                               :UNRESOLVED:
    - 借用 ~Queue~ 
      #+begin_src java :classname 
        class Solution {
            public ListNode sortList(ListNode head) {

                //初始化
                ListNode cur;
                Deque<ListNode> queue = new LinkedList<>();
                for( ; head != null; head = cur){
                    cur = head.next; head.next = null; queue.offer(head);
                }

                //排序并循环添加
                head = queue.poll();
                while(!queue.isEmpty()){
                    queue.offer(head); head = merge(queue.poll(),queue.poll());
                }
                return head;
            }

            //归并操作
            ListNode merge(ListNode a, ListNode b){
                ListNode c = new ListNode(0);
                ListNode head = c;
                while(a != null && b != null){
                    if (a.val < b.val){
                        c.next = a; c = a; a = a.next; 
                    }else{
                        c.next = b; c = b; b = b.next;
                    }
                }
                c.next = (a == null) ? b : a;
                return head.next;
            }
        }
      #+end_src
    - 不借用 ~Queue~
      #+begin_src java :classname 
        class Solution {
            public ListNode sortList(ListNode head) {
                if (head == null || head.next == null) {
                    return head;
                }
                // 获取链表长度
                int len = listNodeLength(head);

                // 哨兵节点，也有叫傀儡节点（处理链表问题的一般技巧）
                ListNode sentry = new ListNode(-1);
                sentry.next = head;

                // 循环 log n 次
                for (int i = 1; i < len; i <<= 1) {
                    ListNode prev = sentry;
                    ListNode curr = sentry.next;
                    // 循环 n 次
                    while (curr != null) {
                        ListNode left = curr;
                        ListNode right = split(left, i);
                        curr = split(right, i);
                        prev.next = mergeTwoLists(left, right);

                        while (prev.next != null) {
                            prev = prev.next;
                        }
                    }
                }

                return sentry.next;
            }

            // 根据步长分隔链表
            private ListNode split(ListNode head, int step) {
                if (head == null) return null;

                for (int i = 1; head.next != null && i < step; i++) {
                    head = head.next;
                }

                ListNode right = head.next;
                head.next = null;
                return right;
            }

            // 获取链表的长度
            private int listNodeLength(ListNode head) {
                int length = 0;
                ListNode curr = head;

                while (curr != null) {
                    length++;
                    curr = curr.next;
                }

                return length;
            }

            // 合并两个有序链表
            private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
                ListNode sentry = new ListNode(-1);
                ListNode curr = sentry;

                while (l1 != null && l2 != null) {
                    if (l1.val < l2.val) {
                        curr.next = l1;
                        l1 = l1.next;
                    } else {
                        curr.next = l2;
                        l2 = l2.next;
                    }

                    curr = curr.next;
                }

                curr.next = l1 != null ? l1 : l2;
                return sentry.next;
            }
        }
      #+end_src 
** 快排                                                          :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
     public ListNode sortList(ListNode head) {
             if(head==null||head.next==null) return head;
             // 没有条件，创造条件。自己添加头节点，最后返回时去掉即可。
             ListNode newHead=new ListNode(-1);
             newHead.next=head;
             return quickSort(newHead,null);
         }
         // 带头结点的链表快速排序
         private ListNode quickSort(ListNode head,ListNode end){
             if (head==end||head.next==end||head.next.next==end) return head;
             // 将小于划分点的值存储在临时链表中
             ListNode tmpHead=new ListNode(-1);
             // partition为划分点，p为链表指针，tp为临时链表指针
             ListNode partition=head.next,p=partition,tp=tmpHead;
             // 将小于划分点的结点放到临时链表中
             while (p.next!=end){
                 if (p.next.val<partition.val){
                     tp.next=p.next;
                     tp=tp.next;
                     p.next=p.next.next;
                 }else {
                     p=p.next;
                 }
             }
             // 合并临时链表和原链表，将原链表接到临时链表后面即可
             tp.next=head.next;
             // 将临时链表插回原链表，注意是插回！（不做这一步在对右半部分处理时就断链了）
             head.next=tmpHead.next;
             quickSort(head,partition);
             quickSort(partition,end);
             // 题目要求不带头节点，返回结果时去除
             return head.next;
         }
     }
   #+end_src 
* 152 乘积最大子数组                                                   :数组:
  #+begin_src java :classname 
    class Solution {
        public int maxProduct(int[] nums) {
            int max = Integer.MIN_VALUE, max1 = 1, max2 = 1, len = nums.length;
            for (int i = 0; i < len; i++) {
                max1 *= nums[i];
                max2 *= nums[len-i-1];
                int curMax = Math.max(max1, max2);
                if (max < curMax) max = curMax;
                if (nums[i] == 0) max1 = 1;
                if (nums[len-i-1] == 0) max2 = 1;
            }
            return max;
        }
    }
  #+end_src 
* 155 最小栈                                                             :栈:
  #+begin_src java :classname 
    class MinStack {

        private Stack<Integer> data;
        private Stack<Integer> min;

        /** initialize your data structure here. */
        public MinStack() {
            data = new Stack<>();
            min = new Stack<>();
        }

        public void push(int x) {
            data.push(x);
            if (min.empty() || min.peek() >= x) min.push(x);
        }

        public void pop() {
            if (!data.empty()) {
                int x = data.pop();
                if (x == min.peek()) min.pop();
            }
        }

        public int top() {
            return data.peek();
        }

        public int getMin() {
            return min.peek();
        }
    }
  #+end_src 
* 160 相交链表 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink17>>][offer52]]                                                 :链表:
  #+begin_src java :classname 
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            int l1 = 0, l2 = 0;
            ListNode p1 = headA, p2 = headB;
            while (p1 != null) {
                p1 = p1.next;
                l1 += 1;
            }
            while (p2 != null) {
                p2 = p2.next;
                l2 += 1;
            }
            p1 = headA;
            p2 = headB;
            int l = l1 - l2;
            if (l < 0) {
                p1 = headB;
                p2 = headA;
                l = -l;
            }
            for (int i = 0; i < l; i++) p1 = p1.next;
            while (p1 != p2) {
                p1 = p1.next;
                p2 = p2.next;
            }
            return p1;
        }
    }
  #+end_src 
* 169 多数元素 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink21>>][offer39]]                                                :数组:
  #+begin_src java :classname 
    class Solution {
        public int majorityElement(int[] nums) {
            int target = nums[0], n = 1;
            for (int i = 1; i < nums.length; i++) {
                if (n == 0) {
                    target = nums[i];
                    n = 1;
                    continue;
                }
                if (nums[i] == target) n += 1;
                else n -= 1;
            }
            return target;
        }
    }
  #+end_src 
* 198 打家劫舍                                                      :DP:数组:
  #+begin_src java :classname 
    class Solution {
        public int rob(int[] nums) {
            if (nums == null || nums.length <= 0) return 0;
            int prevMax = 0, currMax = 0;
            for (int x : nums) {
                int temp = currMax;
                currMax = Math.max(prevMax+x, currMax);
                prevMax = temp;
            }
            return currMax;
        }
    }
  #+end_src 
* 200 岛屿数量                            :BFS:DFS:递归:并查集:二维数组:数组:
** DFS
   #+begin_src java :classname 
     class Solution {
         public int numIslands(char[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
             int rn = grid.length, cn = grid[0].length, num = 0;
             for (int i = 0; i < rn; i++) {
                 for (int j = 0; j < cn; j++) {
                     if (grid[i][j] == '1') {
                         num += 1;
                         dfs(grid, rn, cn, i, j);
                     }
                 }
             }
             return num;
         }

         private void dfs(char[][] grid, int rn, int cn, int r, int c) {
             if (r < 0 || r >= rn || c < 0 || c >= cn) return;
             if (grid[r][c] == '0') return;
             grid[r][c] = '0';
             dfs(grid, rn, cn, r-1, c);
             dfs(grid, rn, cn, r+1, c);
             dfs(grid, rn, cn, r, c-1);
             dfs(grid, rn, cn, r, c+1);
         }
     }
   #+end_src 
** 并查集
   #+begin_src java :classname 
     class Solution {
         class UnionFind {

             int[] vertices;
             int count;

             public UnionFind(char[][] grid) {
                 int rn = grid.length, cn = grid[0].length;
                 vertices = new int[rn*cn];
                 count = 0;
                 for (int i = 0; i < rn; i++) {
                     for (int j = 0; j < cn; j++) {
                         if (grid[i][j] == '1') {
                             count += 1;
                             vertices[i*cn+j] = -1;
                         }
                     }
                 }
             }

             public int sizeOf(int x) {
                 return -vertices[find(x)];
             }

             public int parent(int x) {
                 return vertices[x] < 0 ? x : vertices[x];
             }

             public boolean connected(int x, int y) {
                 int rx = find(x), ry = find(y), px = parent(x), py = parent(y);

                 while (px != rx) {
                     vertices[x] = rx;
                     x = px;
                     px = parent(x);
                 }

                 while (py != ry) {
                     vertices[y] = ry;
                     y = py;
                     py = parent(y);
                 }

                 return rx == ry;
             }

             public void union(int x, int y) {
                 if (!connected(x, y)) {
                     if (sizeOf(x) < sizeOf(y)) {
                         vertices[find(y)] += vertices[find(x)];
                         vertices[find(x)] = find(y);
                     } else {
                         vertices[find(x)] += vertices[find(y)];
                         vertices[find(y)] = find(x);
                     }
                     count -= 1;
                 }
             }

             public int find(int x) {
                 int px = parent(x);
                 return vertices[px] < 0 ? px : find(px);
             }

             public int[] getSet() {
                 return vertices;
             }

             public int getCount() {
                 return count;
             }
         }

         public int numIslands(char[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
             int rn = grid.length, cn = grid[0].length;
             UnionFind uf = new UnionFind(grid);
             for (int i = 0; i < rn; i++){
                 for (int j = 0; j < cn; j++) {
                     if (grid[i][j] == '1') {
                         grid[i][j] = '0';
                         if (i-1 >= 0 && grid[i-1][j] == '1') uf.union((i-1)*cn+j, i*cn+j);
                         if (i+1 < rn && grid[i+1][j] == '1') uf.union((i+1)*cn+j, i*cn+j);
                         if (j-1 >= 0 && grid[i][j-1] == '1') uf.union(i*cn+j-1, i*cn+j);
                         if (j+1 < cn && grid[i][j+1] == '1') uf.union(i*cn+j+1, i*cn+j);
                     }
                 }
             }
             return uf.getCount();
         }
     }
   #+end_src 
** BFS                                                           :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int numIslands(char[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
         }
     }
   #+end_src 
* 206 反转链表 [[file:~/csnds/Dropbox/orglife/offer.org::<<elink19>>][offer24]]                                            :递归:链表:
  #+begin_src java :classname 
    class Solution {
        public ListNode reverseList(ListNode head) {
            if (head == null || head.next == null) return head;
            ListNode reverseHead = reverseList(head.next);
            head.next.next = head;
            head.next = null;
            return reverseHead;
        }
    }
  #+end_src 
* 207 课程表
  #+begin_src java :classname 
    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {

        }
    }
  #+end_src 

* 516 最长回文子序列
  #+begin_src java :classname 
    class Solution {
        public int longestPalindromeSubseq(String s) {

        }
    }
  #+end_src 
* 583 两个字符串的删除操作                                       :UNRESOLVED:
* 637 二叉树的层平均值                                           :UNRESOLVED:
*** DFS
*** BFS
* 803 打砖块                                                        :TOBEORG:
  #+begin_src java :classname 
    public class Solution {

        public int[] hitBricks(int[][] grid, int[][] hits) {
            // TODO
            if (grid == null || grid.length == 0 || grid[0].length == 0) return null;
            if (hits == null || hits.length == 0 || hits[0].length != 2) return null;
            int row = grid.length, col = grid[0].length, hitsNum = hits.length;
            for (int[] dart: hits) {
                if (dart[0] < 0 || dart[0] >= row ||
                        dart[1] < 0 || dart[1] >= col) return null;
            }

            int[] ur = {1, 0, -1, 0};
            int[] uc = {0, 1, 0, -1};
            int root = row * col;
            UnionFind union = new UnionFind(root + 1);
            int[][] copy = new int[row][col];

            for (int i = 0; i < row; i++) {
                copy[i] = grid[i].clone();
            }

            for (int[] dart: hits) {
                copy[dart[0]][dart[1]] = 0;
            }

            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (copy[i][j] == 1) {
                        if (i == 0) {
                            union.union(xyToint(col, i, j), root);
                            continue;
                        }
                        if (i - 1 >= 0 && copy[i-1][j] == 1) {
                            union.union(xyToint(col, i, j), xyToint(col, i-1, j));
                        }
                        if (j - 1 >= 0 && copy[i][j-1] == 1) {
                            union.union(xyToint(col, i, j), xyToint(col, i, j-1));
                        }
                    }
                }
            }


            int[] bubbles = new int[hitsNum];

            for (int i = hitsNum - 1; i >= 0; i--) {
                int afterPop = union.sizeOf(root);
                int r = hits[i][0];
                int c = hits[i][1];
                if (grid[r][c] == 0) continue;
                if (r == 0) union.union(xyToint(col, r, c), root);
                for (int j = 0; j < 4; j++) {
                    int nr = r + ur[j];
                    int nc = c + uc[j];
                    if (nr >= 0 && nr < row &&
                            nc >=0 && nc < col && copy[nr][nc] == 1) {
                        union.union(xyToint(col, r, c), xyToint(col, nr, nc));
                    }
                }
                int pops = union.sizeOf(root) - afterPop - 1;
                bubbles[i] = pops > 0 ? pops : 0;
                copy[r][c] = 1;
            }
            return bubbles;
        }


        private int xyToint(int col, int r, int c) {
            return r * col + c;
        }

    }


    class UnionFind {

        private int[] vertice;

        // TODO - Add instance variables?

        /* Creates a UnionFind data structure holding n vertices. Initially, all
           vertices are in disjoint sets. */
        public UnionFind(int n) {
            // TODO
            vertice = new int[n];
            for (int i = 0; i < n; i++) {
                vertice[i] = -1;
            }
        }

        /* Throws an exception if v1 is not a valid index. */
        private void validate(int vertex) {
            // TODO
            if (vertex < 0 || vertex >= this.vertice.length) {
                throw new IllegalArgumentException(vertex
                        + "is not a valid index.");
            }
        }

        /* Returns the size of the set v1 belongs to. */
        public int sizeOf(int v1) {
            // TODO
            return - vertice[find(v1)];
        }

        /* Returns the parent of v1. If v1 is the root of a tree, returns the
           negative size of the tree for which v1 is the root. */
        public int parent(int v1) {
            // TODO
            return vertice[v1] < 0 ? v1 : vertice[v1];
        }

        /* Returns true if nodes v1 and v2 are connected. */
        public boolean connected(int v1, int v2) {
            // TODO
            int r1 = find(v1);
            int r2 = find(v2);
    //        int p1 = parent(v1);
    //        int p2 = parent(v2);
    //
    //        while (p1 != r1) {
    //            vertice[v1] = r1;
    //            v1 = p1;
    //            p1 = parent(v1);
    //        }
    //        while (p2 != r2) {
    //            vertice[v2] = r2;
    //            v2 = p2;
    //            p2 = parent(v2);
    //        }

            return r1 == r2;
        }

        /* Connects two elements v1 and v2 together. v1 and v2 can be any valid
           elements, and a union-by-size heuristic is used. If the sizes of the sets
           are equal, tie break by connecting v1's root to v2's root. Unioning a 
           vertex with itself or vertices that are already connected should not 
           change the sets but may alter the internal structure of the data. */
        public void union(int v1, int v2) {
            // TODO
            validate(v1);
            validate(v2);
            if (!connected(v1, v2)) {
                if (sizeOf(v1) <= sizeOf(v2)) {
                    vertice[find(v2)] += vertice[find(v1)];
                    vertice[find(v1)] = find(v2);
                } else {
                    vertice[find(v1)] += vertice[find(v2)];
                    vertice[find(v2)] = find(v1);
                }
            }
        }

        /* Returns the root of the set V belongs to. Path-compression is employed
           allowing for fast search-time. */
        public int find(int vertex) {
            // TODO
            return vertice[vertex] < 0 ? vertex : find(parent(vertex));
        }

        public int[] getSet() {
            return vertice;
        }
    }
  #+end_src 
* 1035 不相交的线                                                :UNRESOLVED:
* 1143 最长公共子序列                                    :编辑距离:DP:字符串:
  - 二维
    #+begin_src java :classname 
      class Solution {
          public int longestCommonSubsequence(String text1, String text2) {
              if (text1 == null || text2 == null) return 0;
              int len1 = text1.length()+1, len2 = text2.length()+1;
              int[][] res = new int[len1][len2];
              for (int i = 1; i < len1; i++) {
                  char ch1 = text1.charAt(i-1);
                  for (int j = 1; j < len2; j++) {
                      char ch2 = text2.charAt(j-1);
                      res[i][j] = ch1 == ch2 ? res[i-1][j-1]+1 : Math.max(res[i][j-1], res[i-1][j]);
                  }
              }
              return res[len1-1][len2-1];
          }
      }
    #+end_src
  - 一维(空间优化)
    #+begin_src java :classname 
      class Solution {
          public int longestCommonSubsequence(String text1, String text2) {
              if (text1 == null || text2 == null) return 0;
              int len1 = text1.length()+1, len2 = text2.length()+1;
          }
      }
    #+end_src
  - 最长公共子串
    #+begin_src java :classname 
      class Solution {
          public String longestCommonSubstring(String text1, String text2) {
              if (text1 == null || text2 == null) return 0;
              int end = 0, max = 0, len1 = text1.length(), len2 = text2.length();
              int[][] res = new int[len1+1][len2+1];
              for (int i = 1; i <= len1; i++) {
                  char ch1 = text1.charAt(i-1);
                  for (int j = 1; j <= len2; j++) {
                      char ch2 = text2.charAt(j-1);
                      res[i][j] = ch1 == ch2 ? res[i-1][j-1]+1 : 0;
                      if (res[i][j] > max) {
                          max = res[i][j];
                          end = i;
                      }
                  }
              }
              return text1.substring(end-max, end);
          }
      }
    #+end_src
* 面试题
** 阿里
*** 无顺子的排列 
    #+begin_src java :classname 
      public int[] order(int n) {
          int[] res = new int[n+1];
          orderHelper(1, n, 0, res);
          return res;
      }

      private void orderHelper(int l, int r, int mark, int[] res) {
          if (l == r) {
              if (mark == 1) res[l] = 1;
              else res[l] = 2;
              return;
          }
          int mid = (l+r) >> 1;
          orderHelper(l, mid, 1, res);
          orderHelper(mid+1, r, 0, res);
          for (int i = l; i <= r; i++) res[i] = res[i] * 2 - mark;
          return;
      }
    #+end_src 
*** n城市m旅人
    #+begin_src java :classname 
      public String[] calcProbs(int n, int m) {
          int[] distances = new int[n];
          int[][] trips = new int[m][2];
          String[] res = new String[m];
          for (int i = 0; i < m; i++) {
              res[i] = calcProb(n, distances, trips[m]);
          }
      }

      private String calcProb(int n, int[] distances, int[] trip) {
          int start = trip[0], end = trip[1];
          int shorter = calcShorter(distances, start, end);
          int gcd = calcGcd(shorter, n);
          StringBuilder sb = new StringBuilder();
          sb.append(shorter/gcd);
          sb.append("/");
          sb.append(n/gcd);
          return sb.toString();
      }

      private int calcShorter(int[] distances, int start, int end) {
          int total = 0, path = 0;
          for (int i = 0; i < distances.length; i++) {
              total += distances[i];
          }
          if (start > end) {
              int temp = start;
              start = end;
              end = start;
          }
          for (int i = start; i < end; i++) {
              path += distances[i];
          }
          return total > 2*path ? end-start : distances.length-end+start;
      }

      private int calcGcd(int x, int y) {
          if (y % x == 0) return x;
          return calcGcd(x, y%x);
      }
    #+end_src 
** 美团
*** 1 单科成绩优秀奖的人数
    #+begin_src java :classname 

      import java.util.*;

      public class Main {
          public static void main(String[] args){
              Scanner cin = new Scanner(System.in);
              int N = cin.nextInt();
              int M = cin.nextInt();
              int[][] score = new int[N][M];
              int[] maxScore = new int[M];
              List<Set<Integer>> sets = new ArrayList<>();
              for (int i = 0; i < M; i++) sets.add(new HashSet<Integer>());
              Set<Integer> res = new HashSet<>();
              for(int i=0;i<N;i++){
                  for(int j=0;j<M;j++){
                      score[i][j] = cin.nextInt();
                      if (score[i][j] < maxScore[j]) continue;
                      if (score[i][j] > maxScore[j]) {
                          maxScore[j] = score[i][j];
                          sets.get(j).removeAll(sets.get(j));
                      }
                      sets.get(j).add(j);
                  }
              }
              for (int i = 0; i < M; i++) {
                  res.addAll(sets.get(i));
              }
              System.out.println(res.size());
          }
      }
    #+end_src 
*** 2 最短循环周期的长度
    #+begin_src java :classname 
      public int shortest(int a, int b, int m, int x) {
          int res = 0;
          long la = (long) a, lb = (long) b, lm = (long) m, lx = (long) x;
          long temp = lx;
          while (true) {
              res += 1;
              lx = (lx*la+lb) % lm;
              if (lx == temp) break;
          }
          return res;
      }
    #+end_src 
*** 3 第k小的数对
    #+begin_src java :classname 
      public static int[] kthMinPair2(int[] arr, int k) {
          int N = arr.length;
          if (k > N * N) {
              return null;
          }
          Arrays.sort(arr);
          int firstIndex = (k-1) / N;
          int firstNum = arr[firstIndex];
          int leftIndex = firstIndex;
          while (leftIndex >= 0 && arr[leftIndex] == firstNum) leftIndex -= 1;
          leftIndex += 1;
          int rightIndex = firstIndex;
          while (rightIndex < N && arr[rightIndex] == firstNum) rightIndex += 1;
          rightIndex -= 1;
          int afterk = k - leftIndex * N;
          int secondIndex = (afterk-1) / (rightIndex-leftIndex+1);
          int secondNum = arr[secondIndex];
          return new int[] {firstNum, secondNum};
       }
    #+end_src 
    #+begin_src java :classname 
      private class Pair implements Comparable {
          int x;
          int y;

          Pair(int p1, int p2) {
              x = p1;
              y = p2;
          }

          @Override
          int compareTo(Pair other) {
              if (p1.x == p2.x) return p2.y - p1.y;
              return p2.x - p1.y;
          }

          static class pairComparator implements Comparator<Pair> {
              int compare(Pair p1, Pair p2) {
                  return p2.compareTo(p1);
              }
          }
      }

      public int[] kthPair(int[] array, int k) {
          int len = array.length;
          PriorityQueue<Pair> pq = new PriorityQueue<>();
          for (int i = 0; i < len; i++) {
              for (int j = 0; j < len; j++) {
                  Pair p = new Pair(array[i], array[j]);
                  if (pq.size() < k) pq.offer(p);
                  else {
                      Pair curMax = pq.peek();
                      if (curMax.compareTo(p) < 0) {
                      // if (Pair.pairComparator.compare(p, curMax) < 0) {
                          pq.poll();
                          pq.offer(p);
                      }
                  }
              }
          }
          Pair kth = pq.peek();
          return new int[] {kth.x, kth.y};
      }
    #+end_src 
*** 4
*** 5 
** 快手
* Mysql
** 511 游戏玩法分析1
 #+begin_src sql
   SELECT player_id, min(event_date) 'first_login' FROM Activity GROUP BY player_id ORDER BY player_id ASC;
 #+end_src
** 512 游戏玩法分析2
   #+begin_src sql
     SELECT a.player_id, a.device_id FROM Activity a WHERE (a.player_id, a.event_date) IN (SELECT player_id, min(event_date) AS first_login FROM Activity GROUP BY player_id);
   #+end_src
** 577 员工奖金
   #+begin_src sql
     SELECT a.name, b.bonus FROM Employee a LEFT JOIN Bonus b ON a.empId = b.empId WHERE b.bonus IS NULL OR b.bonus < 1000;
   #+end_src
** 584 寻找用户推荐人
   #+begin_src sql
     SELECT name FROM customer WHERE referee_id != 2 OR referee_id IS NULL;
   #+end_src
** 586 订单最多的用户
   #+begin_src sql
     SELECT
         customer_number
     FROM
         orders
     GROUP BY customer_number
     ORDER BY COUNT(*) DESC
     LIMIT 1
     ;
   #+end_src

** 597 好友申请1 总体通过率
   #+begin_src sql
     SELECT
     ROUND(
         IFNULL(
         (SELECT COUNT(DISTINCT requester_id, accepter_id) FROM request_accepted as A)
         /
         (SELECT COUNT(DISTINCT sender_id, send_to_id) FROM friend_request as B),
         0)
     , 2) as accept_rate;
   #+end_src

** 603 连续空余座位
   #+begin_src sql
     SELECT DISTINCT a.seat_id
       FROM cinema a JOIN cinema b
       ON ABS(a.seat_id - b.seat_id) = 1
       AND a.free = TRUE AND b.free = TRUE
       ORDER BY a.seat_id;
   #+end_src
** 607 销售员
   #+begin_src sql
     SELECT
         name
     FROM
         salesperson
     WHERE
         sales_id NOT IN (SELECT
               a.sales_id
           FROM
               orders a
                   LEFT JOIN
               company b ON b.com_id = a.com_id
           WHERE
               b.name = 'RED');
   #+end_src

** 610 判断三角形
   #+begin_src sql
     SELECT x, y, z, CASE
                         WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
                         ELSE 'No'
                     END AS 'triangle' FROM triangle;
   #+end_src

** 613 直线上的最近距离
   #+begin_src sql
     SELECT
         MIN(ABS(p1.x - p2.x)) as shortest
     FROM
         point p1
             JOIN
         point p2 on p1.x != p2.x;
   #+end_src
** 619 只出现一次的最大数字
   - 错误
     #+begin_src sql
       SELECT a.num FROM (SELECT num, COUNT(*) AS times FROM my_numbers GROUP BY num) AS a WHERE a.times = 1 ORDER BY a.num DESC LIMIT 1;
     #+end_src
   - 正确
     #+begin_src sql
       SELECT MAX(num) AS num FROM (SELECT num FROM my_numbers GROUP BY num HAVING COUNT(num) = 1) AS t;
     #+end_src
** 1050 合作过至少三次的演员和导演
   #+begin_src sql
     SELECT actor_id, director_id FROM ActorDirector GROUP BY actor_id, director_id HAVING COUNT(*) > 2;
   #+end_src
** 1068 产品销售分析 1
   - 不使用链接
     #+begin_src sql
       SELECT a.product_name, b.year, b.price FROM Product a, Sales b WHERE a.product_id = b.product_id;
     #+end_src
   - 使用链接
     #+begin_src sql
       SELECT a.product_name, b.year, b.price FROM Product a RIGHT JOIN Sales b ON a.product_id = b.product_id;
     #+end_src
** 1069 产品销售分析 2
   #+begin_src sql
     SELECT product_id, SUM(quantity) as total_quantity FROM Sales GROUP BY product_id;
   #+end_src
** 1075 项目员工 1
   #+begin_src sql
     SELECT a.project_id, ROUND(AVG(b.experience_years), 2) AS average_years FROM Project a LEFT JOIN Employee b ON a.employee_id = b.employee_id GROUP BY a.project_id ORDER BY a.project_id ASC;
   #+end_src
** 1076 项目员工 2
   #+begin_src sql
     SELECT project_id FROM project GROUP BY project_id HAVING COUNT(*) = (SELECT COUNT(*) times FROM project GROUP BY project_id ORDER BY times DESC LIMIT 1);
   #+end_src
** 1082 销售分析 1
   #+begin_src sql
     SELECT seller_id FROM Sales GROUP BY seller_id HAVING SUM(price) = (SELECT SUM(price) total_sale FROM Sales GROUP BY seller_id ORDER BY total_sale DESC LIMIT 1);
   #+end_src
** 1083 销售分析 2
   #+begin_src sql
     SELECT DISTINCT buyer_id
     FROM Product a RIGHT JOIN Sales b
     ON a.product_id = b.product_id
     WHERE product_name = 'S8'
     AND (buyer_id NOT IN (
     SELECT buyer_id FROM Product a RIGHT JOIN Sales b
     ON a.product_id = b.product_id
     WHERE a.product_name = 'iPhone'));
   #+end_src
** 1084 销售分析 4
   #+begin_src sql
     -- SELECT DISTINCT b.product_id, a.product_name
     -- FROM Product a RIGHT JOIN Sales b
     -- ON a.product_id = b.product_id
     -- GROUP BY b.product_id
     -- HAVING SUM(b.sale_date NOT BETWEEN
     -- "2019-01-01" AND "2019-03-31") = 0;

     SELECT S.product_id, P.product_name
     FROM Product P, Sales S
     WHERE P.product_id = S.product_id
     GROUP BY S.product_id
     HAVING SUM(S.sale_date NOT BETWEEN
     "2019-01-01" AND "2019-03-31") = 0;
   #+end_src
** 1113 报告的记录
   #+begin_src sql
     SELECT extra report_reason, COUNT(DISTINCT post_id, extra) report_count
     FROM Actions
     WHERE DATEDIFF('2019-07-05', action_date) = 1
     AND action = 'report'
     GROUP BY report_reason
     ORDER BY report_count ASC;
   #+end_src
** 1141 查询近30天活跃用户数
   #+begin_src sql
     SELECT activity_date day, COUNT(DISTINCT user_id) active_users
     FROM Activity
     WHERE DATEDIFF('2019-07-27', activity_date) < 30
     -- AND (activity_type = 'scroll_down' OR activity_type = 'send_message')
     GROUP BY day
     ORDER BY day ASC;
   #+end_src
** 1142 过去30天的用户活动 2
   #+begin_src sql
     SELECT IFNULL(ROUND(COUNT(DISTINCT session_id)/COUNT(DISTINCT user_id), 2), 0) average_sessions_per_user
     FROM Activity
     WHERE DATEDIFF('2019-07-27', activity_date) < 30;
   #+end_src
** 1143 文章浏览 1
   #+begin_src sql
     SELECT DISTINCT author_id id
     FROM Views
     WHERE author_id = viewer_id
     ORDER BY author_id ASC;
   #+end_src
